"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@noble";
exports.ids = ["vendor-chunks/@noble"];
exports.modules = {

/***/ "(rsc)/./node_modules/@noble/curves/_shortw_utils.js":
/*!*****************************************************!*\
  !*** ./node_modules/@noble/curves/_shortw_utils.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.getHash = getHash;\nexports.createCurve = createCurve;\n/**\n * Utilities for short weierstrass curves, combined with noble-hashes.\n * @module\n */ /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const hmac_1 = __webpack_require__(/*! @noble/hashes/hmac */ \"(rsc)/./node_modules/@noble/hashes/hmac.js\");\nconst utils_1 = __webpack_require__(/*! @noble/hashes/utils */ \"(rsc)/./node_modules/@noble/hashes/utils.js\");\nconst weierstrass_ts_1 = __webpack_require__(/*! ./abstract/weierstrass.js */ \"(rsc)/./node_modules/@noble/curves/abstract/weierstrass.js\");\n/** connects noble-curves to noble-hashes */ function getHash(hash) {\n    return {\n        hash,\n        hmac: (key, ...msgs)=>(0, hmac_1.hmac)(hash, key, (0, utils_1.concatBytes)(...msgs)),\n        randomBytes: utils_1.randomBytes\n    };\n}\nfunction createCurve(curveDef, defHash) {\n    const create = (hash)=>(0, weierstrass_ts_1.weierstrass)({\n            ...curveDef,\n            ...getHash(hash)\n        });\n    return {\n        ...create(defHash),\n        create\n    };\n} //# sourceMappingURL=_shortw_utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9fc2hvcnR3X3V0aWxzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxlQUFlLEdBQUdFO0FBQ2xCRixtQkFBbUIsR0FBR0c7QUFDdEI7OztDQUdDLEdBQ0Qsb0VBQW9FLEdBQ3BFLE1BQU1DLFNBQVNDLG1CQUFPQSxDQUFDLHNFQUFvQjtBQUMzQyxNQUFNQyxVQUFVRCxtQkFBT0EsQ0FBQyx3RUFBcUI7QUFDN0MsTUFBTUUsbUJBQW1CRixtQkFBT0EsQ0FBQyw2RkFBMkI7QUFDNUQsMENBQTBDLEdBQzFDLFNBQVNILFFBQVFNLElBQUk7SUFDakIsT0FBTztRQUNIQTtRQUNBQyxNQUFNLENBQUNDLEtBQUssR0FBR0MsT0FBUyxDQUFDLEdBQUdQLE9BQU9LLElBQUksRUFBRUQsTUFBTUUsS0FBSyxDQUFDLEdBQUdKLFFBQVFNLFdBQVcsS0FBS0Q7UUFDaEZFLGFBQWFQLFFBQVFPLFdBQVc7SUFDcEM7QUFDSjtBQUNBLFNBQVNWLFlBQVlXLFFBQVEsRUFBRUMsT0FBTztJQUNsQyxNQUFNQyxTQUFTLENBQUNSLE9BQVMsQ0FBQyxHQUFHRCxpQkFBaUJVLFdBQVcsRUFBRTtZQUFFLEdBQUdILFFBQVE7WUFBRSxHQUFHWixRQUFRTSxLQUFLO1FBQUM7SUFDM0YsT0FBTztRQUFFLEdBQUdRLE9BQU9ELFFBQVE7UUFBRUM7SUFBTztBQUN4QyxFQUNBLHlDQUF5QyIsInNvdXJjZXMiOlsid2VicGFjazovL2ZhcmNhc3RlcnN0YXRzLy4vbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvX3Nob3J0d191dGlscy5qcz8zMmUwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRIYXNoID0gZ2V0SGFzaDtcbmV4cG9ydHMuY3JlYXRlQ3VydmUgPSBjcmVhdGVDdXJ2ZTtcbi8qKlxuICogVXRpbGl0aWVzIGZvciBzaG9ydCB3ZWllcnN0cmFzcyBjdXJ2ZXMsIGNvbWJpbmVkIHdpdGggbm9ibGUtaGFzaGVzLlxuICogQG1vZHVsZVxuICovXG4vKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG5jb25zdCBobWFjXzEgPSByZXF1aXJlKFwiQG5vYmxlL2hhc2hlcy9obWFjXCIpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCJAbm9ibGUvaGFzaGVzL3V0aWxzXCIpO1xuY29uc3Qgd2VpZXJzdHJhc3NfdHNfMSA9IHJlcXVpcmUoXCIuL2Fic3RyYWN0L3dlaWVyc3RyYXNzLmpzXCIpO1xuLyoqIGNvbm5lY3RzIG5vYmxlLWN1cnZlcyB0byBub2JsZS1oYXNoZXMgKi9cbmZ1bmN0aW9uIGdldEhhc2goaGFzaCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGhhc2gsXG4gICAgICAgIGhtYWM6IChrZXksIC4uLm1zZ3MpID0+ICgwLCBobWFjXzEuaG1hYykoaGFzaCwga2V5LCAoMCwgdXRpbHNfMS5jb25jYXRCeXRlcykoLi4ubXNncykpLFxuICAgICAgICByYW5kb21CeXRlczogdXRpbHNfMS5yYW5kb21CeXRlcyxcbiAgICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlQ3VydmUoY3VydmVEZWYsIGRlZkhhc2gpIHtcbiAgICBjb25zdCBjcmVhdGUgPSAoaGFzaCkgPT4gKDAsIHdlaWVyc3RyYXNzX3RzXzEud2VpZXJzdHJhc3MpKHsgLi4uY3VydmVEZWYsIC4uLmdldEhhc2goaGFzaCkgfSk7XG4gICAgcmV0dXJuIHsgLi4uY3JlYXRlKGRlZkhhc2gpLCBjcmVhdGUgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV9zaG9ydHdfdXRpbHMuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZ2V0SGFzaCIsImNyZWF0ZUN1cnZlIiwiaG1hY18xIiwicmVxdWlyZSIsInV0aWxzXzEiLCJ3ZWllcnN0cmFzc190c18xIiwiaGFzaCIsImhtYWMiLCJrZXkiLCJtc2dzIiwiY29uY2F0Qnl0ZXMiLCJyYW5kb21CeXRlcyIsImN1cnZlRGVmIiwiZGVmSGFzaCIsImNyZWF0ZSIsIndlaWVyc3RyYXNzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@noble/curves/_shortw_utils.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@noble/curves/abstract/curve.js":
/*!******************************************************!*\
  !*** ./node_modules/@noble/curves/abstract/curve.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.wNAF = wNAF;\nexports.pippenger = pippenger;\nexports.precomputeMSMUnsafe = precomputeMSMUnsafe;\nexports.validateBasic = validateBasic;\n/**\n * Methods for elliptic curve multiplication by scalars.\n * Contains wNAF, pippenger\n * @module\n */ /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const modular_ts_1 = __webpack_require__(/*! ./modular.js */ \"(rsc)/./node_modules/@noble/curves/abstract/modular.js\");\nconst utils_ts_1 = __webpack_require__(/*! ./utils.js */ \"(rsc)/./node_modules/@noble/curves/abstract/utils.js\");\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nfunction constTimeNegate(condition, item) {\n    const neg = item.negate();\n    return condition ? neg : item;\n}\nfunction validateW(W, bits) {\n    if (!Number.isSafeInteger(W) || W <= 0 || W > bits) throw new Error(\"invalid window size, expected [1..\" + bits + \"], got W=\" + W);\n}\nfunction calcWOpts(W, scalarBits) {\n    validateW(W, scalarBits);\n    const windows = Math.ceil(scalarBits / W) + 1; // W=8 33. Not 32, because we skip zero\n    const windowSize = 2 ** (W - 1); // W=8 128. Not 256, because we skip zero\n    const maxNumber = 2 ** W; // W=8 256\n    const mask = (0, utils_ts_1.bitMask)(W); // W=8 255 == mask 0b11111111\n    const shiftBy = BigInt(W); // W=8 8\n    return {\n        windows,\n        windowSize,\n        mask,\n        maxNumber,\n        shiftBy\n    };\n}\nfunction calcOffsets(n, window, wOpts) {\n    const { windowSize, mask, maxNumber, shiftBy } = wOpts;\n    let wbits = Number(n & mask); // extract W bits.\n    let nextN = n >> shiftBy; // shift number by W bits.\n    // What actually happens here:\n    // const highestBit = Number(mask ^ (mask >> 1n));\n    // let wbits2 = wbits - 1; // skip zero\n    // if (wbits2 & highestBit) { wbits2 ^= Number(mask); // (~);\n    // split if bits > max: +224 => 256-32\n    if (wbits > windowSize) {\n        // we skip zero, which means instead of `>= size-1`, we do `> size`\n        wbits -= maxNumber; // -32, can be maxNumber - wbits, but then we need to set isNeg here.\n        nextN += _1n; // +256 (carry)\n    }\n    const offsetStart = window * windowSize;\n    const offset = offsetStart + Math.abs(wbits) - 1; // -1 because we skip zero\n    const isZero = wbits === 0; // is current window slice a 0?\n    const isNeg = wbits < 0; // is current window slice negative?\n    const isNegF = window % 2 !== 0; // fake random statement for noise\n    const offsetF = offsetStart; // fake offset for noise\n    return {\n        nextN,\n        offset,\n        isZero,\n        isNeg,\n        isNegF,\n        offsetF\n    };\n}\nfunction validateMSMPoints(points, c) {\n    if (!Array.isArray(points)) throw new Error(\"array expected\");\n    points.forEach((p, i)=>{\n        if (!(p instanceof c)) throw new Error(\"invalid point at index \" + i);\n    });\n}\nfunction validateMSMScalars(scalars, field) {\n    if (!Array.isArray(scalars)) throw new Error(\"array of scalars expected\");\n    scalars.forEach((s, i)=>{\n        if (!field.isValid(s)) throw new Error(\"invalid scalar at index \" + i);\n    });\n}\n// Since points in different groups cannot be equal (different object constructor),\n// we can have single place to store precomputes.\n// Allows to make points frozen / immutable.\nconst pointPrecomputes = new WeakMap();\nconst pointWindowSizes = new WeakMap();\nfunction getW(P) {\n    return pointWindowSizes.get(P) || 1;\n}\n/**\n * Elliptic curve multiplication of Point by scalar. Fragile.\n * Scalars should always be less than curve order: this should be checked inside of a curve itself.\n * Creates precomputation tables for fast multiplication:\n * - private scalar is split by fixed size windows of W bits\n * - every window point is collected from window's table & added to accumulator\n * - since windows are different, same point inside tables won't be accessed more than once per calc\n * - each multiplication is 'Math.ceil(CURVE_ORDER / ùëä) + 1' point additions (fixed for any scalar)\n * - +1 window is neccessary for wNAF\n * - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication\n *\n * @todo Research returning 2d JS array of windows, instead of a single window.\n * This would allow windows to be in different memory locations\n */ function wNAF(c, bits) {\n    return {\n        constTimeNegate,\n        hasPrecomputes (elm) {\n            return getW(elm) !== 1;\n        },\n        // non-const time multiplication ladder\n        unsafeLadder (elm, n, p = c.ZERO) {\n            let d = elm;\n            while(n > _0n){\n                if (n & _1n) p = p.add(d);\n                d = d.double();\n                n >>= _1n;\n            }\n            return p;\n        },\n        /**\n         * Creates a wNAF precomputation window. Used for caching.\n         * Default window size is set by `utils.precompute()` and is equal to 8.\n         * Number of precomputed points depends on the curve size:\n         * 2^(ùëä‚àí1) * (Math.ceil(ùëõ / ùëä) + 1), where:\n         * - ùëä is the window size\n         * - ùëõ is the bitlength of the curve order.\n         * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.\n         * @param elm Point instance\n         * @param W window size\n         * @returns precomputed point tables flattened to a single array\n         */ precomputeWindow (elm, W) {\n            const { windows, windowSize } = calcWOpts(W, bits);\n            const points = [];\n            let p = elm;\n            let base = p;\n            for(let window = 0; window < windows; window++){\n                base = p;\n                points.push(base);\n                // i=1, bc we skip 0\n                for(let i = 1; i < windowSize; i++){\n                    base = base.add(p);\n                    points.push(base);\n                }\n                p = base.double();\n            }\n            return points;\n        },\n        /**\n         * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.\n         * @param W window size\n         * @param precomputes precomputed tables\n         * @param n scalar (we don't check here, but should be less than curve order)\n         * @returns real and fake (for const-time) points\n         */ wNAF (W, precomputes, n) {\n            // Smaller version:\n            // https://github.com/paulmillr/noble-secp256k1/blob/47cb1669b6e506ad66b35fe7d76132ae97465da2/index.ts#L502-L541\n            // TODO: check the scalar is less than group order?\n            // wNAF behavior is undefined otherwise. But have to carefully remove\n            // other checks before wNAF. ORDER == bits here.\n            // Accumulators\n            let p = c.ZERO;\n            let f = c.BASE;\n            // This code was first written with assumption that 'f' and 'p' will never be infinity point:\n            // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,\n            // there is negate now: it is possible that negated element from low value\n            // would be the same as high element, which will create carry into next window.\n            // It's not obvious how this can fail, but still worth investigating later.\n            const wo = calcWOpts(W, bits);\n            for(let window = 0; window < wo.windows; window++){\n                // (n === _0n) is handled and not early-exited. isEven and offsetF are used for noise\n                const { nextN, offset, isZero, isNeg, isNegF, offsetF } = calcOffsets(n, window, wo);\n                n = nextN;\n                if (isZero) {\n                    // bits are 0: add garbage to fake point\n                    // Important part for const-time getPublicKey: add random \"noise\" point to f.\n                    f = f.add(constTimeNegate(isNegF, precomputes[offsetF]));\n                } else {\n                    // bits are 1: add to result point\n                    p = p.add(constTimeNegate(isNeg, precomputes[offset]));\n                }\n            }\n            // Return both real and fake points: JIT won't eliminate f.\n            // At this point there is a way to F be infinity-point even if p is not,\n            // which makes it less const-time: around 1 bigint multiply.\n            return {\n                p,\n                f\n            };\n        },\n        /**\n         * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.\n         * @param W window size\n         * @param precomputes precomputed tables\n         * @param n scalar (we don't check here, but should be less than curve order)\n         * @param acc accumulator point to add result of multiplication\n         * @returns point\n         */ wNAFUnsafe (W, precomputes, n, acc = c.ZERO) {\n            const wo = calcWOpts(W, bits);\n            for(let window = 0; window < wo.windows; window++){\n                if (n === _0n) break; // Early-exit, skip 0 value\n                const { nextN, offset, isZero, isNeg } = calcOffsets(n, window, wo);\n                n = nextN;\n                if (isZero) {\n                    continue;\n                } else {\n                    const item = precomputes[offset];\n                    acc = acc.add(isNeg ? item.negate() : item); // Re-using acc allows to save adds in MSM\n                }\n            }\n            return acc;\n        },\n        getPrecomputes (W, P, transform) {\n            // Calculate precomputes on a first run, reuse them after\n            let comp = pointPrecomputes.get(P);\n            if (!comp) {\n                comp = this.precomputeWindow(P, W);\n                if (W !== 1) pointPrecomputes.set(P, transform(comp));\n            }\n            return comp;\n        },\n        wNAFCached (P, n, transform) {\n            const W = getW(P);\n            return this.wNAF(W, this.getPrecomputes(W, P, transform), n);\n        },\n        wNAFCachedUnsafe (P, n, transform, prev) {\n            const W = getW(P);\n            if (W === 1) return this.unsafeLadder(P, n, prev); // For W=1 ladder is ~x2 faster\n            return this.wNAFUnsafe(W, this.getPrecomputes(W, P, transform), n, prev);\n        },\n        // We calculate precomputes for elliptic curve point multiplication\n        // using windowed method. This specifies window size and\n        // stores precomputed values. Usually only base point would be precomputed.\n        setWindowSize (P, W) {\n            validateW(W, bits);\n            pointWindowSizes.set(P, W);\n            pointPrecomputes.delete(P);\n        }\n    };\n}\n/**\n * Pippenger algorithm for multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).\n * 30x faster vs naive addition on L=4096, 10x faster than precomputes.\n * For N=254bit, L=1, it does: 1024 ADD + 254 DBL. For L=5: 1536 ADD + 254 DBL.\n * Algorithmically constant-time (for same L), even when 1 point + scalar, or when scalar = 0.\n * @param c Curve Point constructor\n * @param fieldN field over CURVE.N - important that it's not over CURVE.P\n * @param points array of L curve points\n * @param scalars array of L scalars (aka private keys / bigints)\n */ function pippenger(c, fieldN, points, scalars) {\n    // If we split scalars by some window (let's say 8 bits), every chunk will only\n    // take 256 buckets even if there are 4096 scalars, also re-uses double.\n    // TODO:\n    // - https://eprint.iacr.org/2024/750.pdf\n    // - https://tches.iacr.org/index.php/TCHES/article/view/10287\n    // 0 is accepted in scalars\n    validateMSMPoints(points, c);\n    validateMSMScalars(scalars, fieldN);\n    const plength = points.length;\n    const slength = scalars.length;\n    if (plength !== slength) throw new Error(\"arrays of points and scalars must have equal length\");\n    // if (plength === 0) throw new Error('array must be of length >= 2');\n    const zero = c.ZERO;\n    const wbits = (0, utils_ts_1.bitLen)(BigInt(plength));\n    let windowSize = 1; // bits\n    if (wbits > 12) windowSize = wbits - 3;\n    else if (wbits > 4) windowSize = wbits - 2;\n    else if (wbits > 0) windowSize = 2;\n    const MASK = (0, utils_ts_1.bitMask)(windowSize);\n    const buckets = new Array(Number(MASK) + 1).fill(zero); // +1 for zero array\n    const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;\n    let sum = zero;\n    for(let i = lastBits; i >= 0; i -= windowSize){\n        buckets.fill(zero);\n        for(let j = 0; j < slength; j++){\n            const scalar = scalars[j];\n            const wbits = Number(scalar >> BigInt(i) & MASK);\n            buckets[wbits] = buckets[wbits].add(points[j]);\n        }\n        let resI = zero; // not using this will do small speed-up, but will lose ct\n        // Skip first bucket, because it is zero\n        for(let j = buckets.length - 1, sumI = zero; j > 0; j--){\n            sumI = sumI.add(buckets[j]);\n            resI = resI.add(sumI);\n        }\n        sum = sum.add(resI);\n        if (i !== 0) for(let j = 0; j < windowSize; j++)sum = sum.double();\n    }\n    return sum;\n}\n/**\n * Precomputed multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).\n * @param c Curve Point constructor\n * @param fieldN field over CURVE.N - important that it's not over CURVE.P\n * @param points array of L curve points\n * @returns function which multiplies points with scaars\n */ function precomputeMSMUnsafe(c, fieldN, points, windowSize) {\n    /**\n     * Performance Analysis of Window-based Precomputation\n     *\n     * Base Case (256-bit scalar, 8-bit window):\n     * - Standard precomputation requires:\n     *   - 31 additions per scalar √ó 256 scalars = 7,936 ops\n     *   - Plus 255 summary additions = 8,191 total ops\n     *   Note: Summary additions can be optimized via accumulator\n     *\n     * Chunked Precomputation Analysis:\n     * - Using 32 chunks requires:\n     *   - 255 additions per chunk\n     *   - 256 doublings\n     *   - Total: (255 √ó 32) + 256 = 8,416 ops\n     *\n     * Memory Usage Comparison:\n     * Window Size | Standard Points | Chunked Points\n     * ------------|-----------------|---------------\n     *     4-bit   |     520         |      15\n     *     8-bit   |    4,224        |     255\n     *    10-bit   |   13,824        |   1,023\n     *    16-bit   |  557,056        |  65,535\n     *\n     * Key Advantages:\n     * 1. Enables larger window sizes due to reduced memory overhead\n     * 2. More efficient for smaller scalar counts:\n     *    - 16 chunks: (16 √ó 255) + 256 = 4,336 ops\n     *    - ~2x faster than standard 8,191 ops\n     *\n     * Limitations:\n     * - Not suitable for plain precomputes (requires 256 constant doublings)\n     * - Performance degrades with larger scalar counts:\n     *   - Optimal for ~256 scalars\n     *   - Less efficient for 4096+ scalars (Pippenger preferred)\n     */ validateW(windowSize, fieldN.BITS);\n    validateMSMPoints(points, c);\n    const zero = c.ZERO;\n    const tableSize = 2 ** windowSize - 1; // table size (without zero)\n    const chunks = Math.ceil(fieldN.BITS / windowSize); // chunks of item\n    const MASK = (0, utils_ts_1.bitMask)(windowSize);\n    const tables = points.map((p)=>{\n        const res = [];\n        for(let i = 0, acc = p; i < tableSize; i++){\n            res.push(acc);\n            acc = acc.add(p);\n        }\n        return res;\n    });\n    return (scalars)=>{\n        validateMSMScalars(scalars, fieldN);\n        if (scalars.length > points.length) throw new Error(\"array of scalars must be smaller than array of points\");\n        let res = zero;\n        for(let i = 0; i < chunks; i++){\n            // No need to double if accumulator is still zero.\n            if (res !== zero) for(let j = 0; j < windowSize; j++)res = res.double();\n            const shiftBy = BigInt(chunks * windowSize - (i + 1) * windowSize);\n            for(let j = 0; j < scalars.length; j++){\n                const n = scalars[j];\n                const curr = Number(n >> shiftBy & MASK);\n                if (!curr) continue; // skip zero scalars chunks\n                res = res.add(tables[j][curr - 1]);\n            }\n        }\n        return res;\n    };\n}\nfunction validateBasic(curve) {\n    (0, modular_ts_1.validateField)(curve.Fp);\n    (0, utils_ts_1.validateObject)(curve, {\n        n: \"bigint\",\n        h: \"bigint\",\n        Gx: \"field\",\n        Gy: \"field\"\n    }, {\n        nBitLength: \"isSafeInteger\",\n        nByteLength: \"isSafeInteger\"\n    });\n    // Set defaults\n    return Object.freeze({\n        ...(0, modular_ts_1.nLength)(curve.n, curve.nBitLength),\n        ...curve,\n        ...{\n            p: curve.Fp.ORDER\n        }\n    });\n} //# sourceMappingURL=curve.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9hYnN0cmFjdC9jdXJ2ZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsWUFBWSxHQUFHRTtBQUNmRixpQkFBaUIsR0FBR0c7QUFDcEJILDJCQUEyQixHQUFHSTtBQUM5QkoscUJBQXFCLEdBQUdLO0FBQ3hCOzs7O0NBSUMsR0FDRCxvRUFBb0UsR0FDcEUsTUFBTUMsZUFBZUMsbUJBQU9BLENBQUMsNEVBQWM7QUFDM0MsTUFBTUMsYUFBYUQsbUJBQU9BLENBQUMsd0VBQVk7QUFDdkMsTUFBTUUsTUFBTUMsT0FBTztBQUNuQixNQUFNQyxNQUFNRCxPQUFPO0FBQ25CLFNBQVNFLGdCQUFnQkMsU0FBUyxFQUFFQyxJQUFJO0lBQ3BDLE1BQU1DLE1BQU1ELEtBQUtFLE1BQU07SUFDdkIsT0FBT0gsWUFBWUUsTUFBTUQ7QUFDN0I7QUFDQSxTQUFTRyxVQUFVQyxDQUFDLEVBQUVDLElBQUk7SUFDdEIsSUFBSSxDQUFDQyxPQUFPQyxhQUFhLENBQUNILE1BQU1BLEtBQUssS0FBS0EsSUFBSUMsTUFDMUMsTUFBTSxJQUFJRyxNQUFNLHVDQUF1Q0gsT0FBTyxjQUFjRDtBQUNwRjtBQUNBLFNBQVNLLFVBQVVMLENBQUMsRUFBRU0sVUFBVTtJQUM1QlAsVUFBVUMsR0FBR007SUFDYixNQUFNQyxVQUFVQyxLQUFLQyxJQUFJLENBQUNILGFBQWFOLEtBQUssR0FBRyx1Q0FBdUM7SUFDdEYsTUFBTVUsYUFBYSxLQUFNVixDQUFBQSxJQUFJLElBQUkseUNBQXlDO0lBQzFFLE1BQU1XLFlBQVksS0FBS1gsR0FBRyxVQUFVO0lBQ3BDLE1BQU1ZLE9BQU8sQ0FBQyxHQUFHdEIsV0FBV3VCLE9BQU8sRUFBRWIsSUFBSSw2QkFBNkI7SUFDdEUsTUFBTWMsVUFBVXRCLE9BQU9RLElBQUksUUFBUTtJQUNuQyxPQUFPO1FBQUVPO1FBQVNHO1FBQVlFO1FBQU1EO1FBQVdHO0lBQVE7QUFDM0Q7QUFDQSxTQUFTQyxZQUFZQyxDQUFDLEVBQUVDLE1BQU0sRUFBRUMsS0FBSztJQUNqQyxNQUFNLEVBQUVSLFVBQVUsRUFBRUUsSUFBSSxFQUFFRCxTQUFTLEVBQUVHLE9BQU8sRUFBRSxHQUFHSTtJQUNqRCxJQUFJQyxRQUFRakIsT0FBT2MsSUFBSUosT0FBTyxrQkFBa0I7SUFDaEQsSUFBSVEsUUFBUUosS0FBS0YsU0FBUywwQkFBMEI7SUFDcEQsOEJBQThCO0lBQzlCLGtEQUFrRDtJQUNsRCx1Q0FBdUM7SUFDdkMsNkRBQTZEO0lBQzdELHNDQUFzQztJQUN0QyxJQUFJSyxRQUFRVCxZQUFZO1FBQ3BCLG1FQUFtRTtRQUNuRVMsU0FBU1IsV0FBVyxxRUFBcUU7UUFDekZTLFNBQVMzQixLQUFLLGVBQWU7SUFDakM7SUFDQSxNQUFNNEIsY0FBY0osU0FBU1A7SUFDN0IsTUFBTVksU0FBU0QsY0FBY2IsS0FBS2UsR0FBRyxDQUFDSixTQUFTLEdBQUcsMEJBQTBCO0lBQzVFLE1BQU1LLFNBQVNMLFVBQVUsR0FBRywrQkFBK0I7SUFDM0QsTUFBTU0sUUFBUU4sUUFBUSxHQUFHLG9DQUFvQztJQUM3RCxNQUFNTyxTQUFTVCxTQUFTLE1BQU0sR0FBRyxrQ0FBa0M7SUFDbkUsTUFBTVUsVUFBVU4sYUFBYSx3QkFBd0I7SUFDckQsT0FBTztRQUFFRDtRQUFPRTtRQUFRRTtRQUFRQztRQUFPQztRQUFRQztJQUFRO0FBQzNEO0FBQ0EsU0FBU0Msa0JBQWtCQyxNQUFNLEVBQUVDLENBQUM7SUFDaEMsSUFBSSxDQUFDQyxNQUFNQyxPQUFPLENBQUNILFNBQ2YsTUFBTSxJQUFJekIsTUFBTTtJQUNwQnlCLE9BQU9JLE9BQU8sQ0FBQyxDQUFDQyxHQUFHQztRQUNmLElBQUksQ0FBRUQsQ0FBQUEsYUFBYUosQ0FBQUEsR0FDZixNQUFNLElBQUkxQixNQUFNLDRCQUE0QitCO0lBQ3BEO0FBQ0o7QUFDQSxTQUFTQyxtQkFBbUJDLE9BQU8sRUFBRUMsS0FBSztJQUN0QyxJQUFJLENBQUNQLE1BQU1DLE9BQU8sQ0FBQ0ssVUFDZixNQUFNLElBQUlqQyxNQUFNO0lBQ3BCaUMsUUFBUUosT0FBTyxDQUFDLENBQUNNLEdBQUdKO1FBQ2hCLElBQUksQ0FBQ0csTUFBTUUsT0FBTyxDQUFDRCxJQUNmLE1BQU0sSUFBSW5DLE1BQU0sNkJBQTZCK0I7SUFDckQ7QUFDSjtBQUNBLG1GQUFtRjtBQUNuRixpREFBaUQ7QUFDakQsNENBQTRDO0FBQzVDLE1BQU1NLG1CQUFtQixJQUFJQztBQUM3QixNQUFNQyxtQkFBbUIsSUFBSUQ7QUFDN0IsU0FBU0UsS0FBS0MsQ0FBQztJQUNYLE9BQU9GLGlCQUFpQkcsR0FBRyxDQUFDRCxNQUFNO0FBQ3RDO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Q0FhQyxHQUNELFNBQVM3RCxLQUFLOEMsQ0FBQyxFQUFFN0IsSUFBSTtJQUNqQixPQUFPO1FBQ0hQO1FBQ0FxRCxnQkFBZUMsR0FBRztZQUNkLE9BQU9KLEtBQUtJLFNBQVM7UUFDekI7UUFDQSx1Q0FBdUM7UUFDdkNDLGNBQWFELEdBQUcsRUFBRWhDLENBQUMsRUFBRWtCLElBQUlKLEVBQUVvQixJQUFJO1lBQzNCLElBQUlDLElBQUlIO1lBQ1IsTUFBT2hDLElBQUl6QixJQUFLO2dCQUNaLElBQUl5QixJQUFJdkIsS0FDSnlDLElBQUlBLEVBQUVrQixHQUFHLENBQUNEO2dCQUNkQSxJQUFJQSxFQUFFRSxNQUFNO2dCQUNackMsTUFBTXZCO1lBQ1Y7WUFDQSxPQUFPeUM7UUFDWDtRQUNBOzs7Ozs7Ozs7OztTQVdDLEdBQ0RvQixrQkFBaUJOLEdBQUcsRUFBRWhELENBQUM7WUFDbkIsTUFBTSxFQUFFTyxPQUFPLEVBQUVHLFVBQVUsRUFBRSxHQUFHTCxVQUFVTCxHQUFHQztZQUM3QyxNQUFNNEIsU0FBUyxFQUFFO1lBQ2pCLElBQUlLLElBQUljO1lBQ1IsSUFBSU8sT0FBT3JCO1lBQ1gsSUFBSyxJQUFJakIsU0FBUyxHQUFHQSxTQUFTVixTQUFTVSxTQUFVO2dCQUM3Q3NDLE9BQU9yQjtnQkFDUEwsT0FBTzJCLElBQUksQ0FBQ0Q7Z0JBQ1osb0JBQW9CO2dCQUNwQixJQUFLLElBQUlwQixJQUFJLEdBQUdBLElBQUl6QixZQUFZeUIsSUFBSztvQkFDakNvQixPQUFPQSxLQUFLSCxHQUFHLENBQUNsQjtvQkFDaEJMLE9BQU8yQixJQUFJLENBQUNEO2dCQUNoQjtnQkFDQXJCLElBQUlxQixLQUFLRixNQUFNO1lBQ25CO1lBQ0EsT0FBT3hCO1FBQ1g7UUFDQTs7Ozs7O1NBTUMsR0FDRDdDLE1BQUtnQixDQUFDLEVBQUV5RCxXQUFXLEVBQUV6QyxDQUFDO1lBQ2xCLG1CQUFtQjtZQUNuQixnSEFBZ0g7WUFDaEgsbURBQW1EO1lBQ25ELHFFQUFxRTtZQUNyRSxnREFBZ0Q7WUFDaEQsZUFBZTtZQUNmLElBQUlrQixJQUFJSixFQUFFb0IsSUFBSTtZQUNkLElBQUlRLElBQUk1QixFQUFFNkIsSUFBSTtZQUNkLDZGQUE2RjtZQUM3RixxRkFBcUY7WUFDckYsMEVBQTBFO1lBQzFFLCtFQUErRTtZQUMvRSwyRUFBMkU7WUFDM0UsTUFBTUMsS0FBS3ZELFVBQVVMLEdBQUdDO1lBQ3hCLElBQUssSUFBSWdCLFNBQVMsR0FBR0EsU0FBUzJDLEdBQUdyRCxPQUFPLEVBQUVVLFNBQVU7Z0JBQ2hELHFGQUFxRjtnQkFDckYsTUFBTSxFQUFFRyxLQUFLLEVBQUVFLE1BQU0sRUFBRUUsTUFBTSxFQUFFQyxLQUFLLEVBQUVDLE1BQU0sRUFBRUMsT0FBTyxFQUFFLEdBQUdaLFlBQVlDLEdBQUdDLFFBQVEyQztnQkFDakY1QyxJQUFJSTtnQkFDSixJQUFJSSxRQUFRO29CQUNSLHdDQUF3QztvQkFDeEMsNkVBQTZFO29CQUM3RWtDLElBQUlBLEVBQUVOLEdBQUcsQ0FBQzFELGdCQUFnQmdDLFFBQVErQixXQUFXLENBQUM5QixRQUFRO2dCQUMxRCxPQUNLO29CQUNELGtDQUFrQztvQkFDbENPLElBQUlBLEVBQUVrQixHQUFHLENBQUMxRCxnQkFBZ0IrQixPQUFPZ0MsV0FBVyxDQUFDbkMsT0FBTztnQkFDeEQ7WUFDSjtZQUNBLDJEQUEyRDtZQUMzRCx3RUFBd0U7WUFDeEUsNERBQTREO1lBQzVELE9BQU87Z0JBQUVZO2dCQUFHd0I7WUFBRTtRQUNsQjtRQUNBOzs7Ozs7O1NBT0MsR0FDREcsWUFBVzdELENBQUMsRUFBRXlELFdBQVcsRUFBRXpDLENBQUMsRUFBRThDLE1BQU1oQyxFQUFFb0IsSUFBSTtZQUN0QyxNQUFNVSxLQUFLdkQsVUFBVUwsR0FBR0M7WUFDeEIsSUFBSyxJQUFJZ0IsU0FBUyxHQUFHQSxTQUFTMkMsR0FBR3JELE9BQU8sRUFBRVUsU0FBVTtnQkFDaEQsSUFBSUQsTUFBTXpCLEtBQ04sT0FBTywyQkFBMkI7Z0JBQ3RDLE1BQU0sRUFBRTZCLEtBQUssRUFBRUUsTUFBTSxFQUFFRSxNQUFNLEVBQUVDLEtBQUssRUFBRSxHQUFHVixZQUFZQyxHQUFHQyxRQUFRMkM7Z0JBQ2hFNUMsSUFBSUk7Z0JBQ0osSUFBSUksUUFBUTtvQkFHUjtnQkFDSixPQUNLO29CQUNELE1BQU01QixPQUFPNkQsV0FBVyxDQUFDbkMsT0FBTztvQkFDaEN3QyxNQUFNQSxJQUFJVixHQUFHLENBQUMzQixRQUFRN0IsS0FBS0UsTUFBTSxLQUFLRixPQUFPLDBDQUEwQztnQkFDM0Y7WUFDSjtZQUNBLE9BQU9rRTtRQUNYO1FBQ0FDLGdCQUFlL0QsQ0FBQyxFQUFFNkMsQ0FBQyxFQUFFbUIsU0FBUztZQUMxQix5REFBeUQ7WUFDekQsSUFBSUMsT0FBT3hCLGlCQUFpQkssR0FBRyxDQUFDRDtZQUNoQyxJQUFJLENBQUNvQixNQUFNO2dCQUNQQSxPQUFPLElBQUksQ0FBQ1gsZ0JBQWdCLENBQUNULEdBQUc3QztnQkFDaEMsSUFBSUEsTUFBTSxHQUNOeUMsaUJBQWlCeUIsR0FBRyxDQUFDckIsR0FBR21CLFVBQVVDO1lBQzFDO1lBQ0EsT0FBT0E7UUFDWDtRQUNBRSxZQUFXdEIsQ0FBQyxFQUFFN0IsQ0FBQyxFQUFFZ0QsU0FBUztZQUN0QixNQUFNaEUsSUFBSTRDLEtBQUtDO1lBQ2YsT0FBTyxJQUFJLENBQUM3RCxJQUFJLENBQUNnQixHQUFHLElBQUksQ0FBQytELGNBQWMsQ0FBQy9ELEdBQUc2QyxHQUFHbUIsWUFBWWhEO1FBQzlEO1FBQ0FvRCxrQkFBaUJ2QixDQUFDLEVBQUU3QixDQUFDLEVBQUVnRCxTQUFTLEVBQUVLLElBQUk7WUFDbEMsTUFBTXJFLElBQUk0QyxLQUFLQztZQUNmLElBQUk3QyxNQUFNLEdBQ04sT0FBTyxJQUFJLENBQUNpRCxZQUFZLENBQUNKLEdBQUc3QixHQUFHcUQsT0FBTywrQkFBK0I7WUFDekUsT0FBTyxJQUFJLENBQUNSLFVBQVUsQ0FBQzdELEdBQUcsSUFBSSxDQUFDK0QsY0FBYyxDQUFDL0QsR0FBRzZDLEdBQUdtQixZQUFZaEQsR0FBR3FEO1FBQ3ZFO1FBQ0EsbUVBQW1FO1FBQ25FLHdEQUF3RDtRQUN4RCwyRUFBMkU7UUFDM0VDLGVBQWN6QixDQUFDLEVBQUU3QyxDQUFDO1lBQ2RELFVBQVVDLEdBQUdDO1lBQ2IwQyxpQkFBaUJ1QixHQUFHLENBQUNyQixHQUFHN0M7WUFDeEJ5QyxpQkFBaUI4QixNQUFNLENBQUMxQjtRQUM1QjtJQUNKO0FBQ0o7QUFDQTs7Ozs7Ozs7O0NBU0MsR0FDRCxTQUFTNUQsVUFBVTZDLENBQUMsRUFBRTBDLE1BQU0sRUFBRTNDLE1BQU0sRUFBRVEsT0FBTztJQUN6QywrRUFBK0U7SUFDL0Usd0VBQXdFO0lBQ3hFLFFBQVE7SUFDUix5Q0FBeUM7SUFDekMsOERBQThEO0lBQzlELDJCQUEyQjtJQUMzQlQsa0JBQWtCQyxRQUFRQztJQUMxQk0sbUJBQW1CQyxTQUFTbUM7SUFDNUIsTUFBTUMsVUFBVTVDLE9BQU82QyxNQUFNO0lBQzdCLE1BQU1DLFVBQVV0QyxRQUFRcUMsTUFBTTtJQUM5QixJQUFJRCxZQUFZRSxTQUNaLE1BQU0sSUFBSXZFLE1BQU07SUFDcEIsc0VBQXNFO0lBQ3RFLE1BQU13RSxPQUFPOUMsRUFBRW9CLElBQUk7SUFDbkIsTUFBTS9CLFFBQVEsQ0FBQyxHQUFHN0IsV0FBV3VGLE1BQU0sRUFBRXJGLE9BQU9pRjtJQUM1QyxJQUFJL0QsYUFBYSxHQUFHLE9BQU87SUFDM0IsSUFBSVMsUUFBUSxJQUNSVCxhQUFhUyxRQUFRO1NBQ3BCLElBQUlBLFFBQVEsR0FDYlQsYUFBYVMsUUFBUTtTQUNwQixJQUFJQSxRQUFRLEdBQ2JULGFBQWE7SUFDakIsTUFBTW9FLE9BQU8sQ0FBQyxHQUFHeEYsV0FBV3VCLE9BQU8sRUFBRUg7SUFDckMsTUFBTXFFLFVBQVUsSUFBSWhELE1BQU03QixPQUFPNEUsUUFBUSxHQUFHRSxJQUFJLENBQUNKLE9BQU8sb0JBQW9CO0lBQzVFLE1BQU1LLFdBQVd6RSxLQUFLMEUsS0FBSyxDQUFDLENBQUNWLE9BQU9XLElBQUksR0FBRyxLQUFLekUsY0FBY0E7SUFDOUQsSUFBSTBFLE1BQU1SO0lBQ1YsSUFBSyxJQUFJekMsSUFBSThDLFVBQVU5QyxLQUFLLEdBQUdBLEtBQUt6QixXQUFZO1FBQzVDcUUsUUFBUUMsSUFBSSxDQUFDSjtRQUNiLElBQUssSUFBSVMsSUFBSSxHQUFHQSxJQUFJVixTQUFTVSxJQUFLO1lBQzlCLE1BQU1DLFNBQVNqRCxPQUFPLENBQUNnRCxFQUFFO1lBQ3pCLE1BQU1sRSxRQUFRakIsT0FBTyxVQUFXVixPQUFPMkMsS0FBTTJDO1lBQzdDQyxPQUFPLENBQUM1RCxNQUFNLEdBQUc0RCxPQUFPLENBQUM1RCxNQUFNLENBQUNpQyxHQUFHLENBQUN2QixNQUFNLENBQUN3RCxFQUFFO1FBQ2pEO1FBQ0EsSUFBSUUsT0FBT1gsTUFBTSwwREFBMEQ7UUFDM0Usd0NBQXdDO1FBQ3hDLElBQUssSUFBSVMsSUFBSU4sUUFBUUwsTUFBTSxHQUFHLEdBQUdjLE9BQU9aLE1BQU1TLElBQUksR0FBR0EsSUFBSztZQUN0REcsT0FBT0EsS0FBS3BDLEdBQUcsQ0FBQzJCLE9BQU8sQ0FBQ00sRUFBRTtZQUMxQkUsT0FBT0EsS0FBS25DLEdBQUcsQ0FBQ29DO1FBQ3BCO1FBQ0FKLE1BQU1BLElBQUloQyxHQUFHLENBQUNtQztRQUNkLElBQUlwRCxNQUFNLEdBQ04sSUFBSyxJQUFJa0QsSUFBSSxHQUFHQSxJQUFJM0UsWUFBWTJFLElBQzVCRCxNQUFNQSxJQUFJL0IsTUFBTTtJQUM1QjtJQUNBLE9BQU8rQjtBQUNYO0FBQ0E7Ozs7OztDQU1DLEdBQ0QsU0FBU2xHLG9CQUFvQjRDLENBQUMsRUFBRTBDLE1BQU0sRUFBRTNDLE1BQU0sRUFBRW5CLFVBQVU7SUFDdEQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7S0FrQ0MsR0FDRFgsVUFBVVcsWUFBWThELE9BQU9XLElBQUk7SUFDakN2RCxrQkFBa0JDLFFBQVFDO0lBQzFCLE1BQU04QyxPQUFPOUMsRUFBRW9CLElBQUk7SUFDbkIsTUFBTXVDLFlBQVksS0FBSy9FLGFBQWEsR0FBRyw0QkFBNEI7SUFDbkUsTUFBTWdGLFNBQVNsRixLQUFLQyxJQUFJLENBQUMrRCxPQUFPVyxJQUFJLEdBQUd6RSxhQUFhLGlCQUFpQjtJQUNyRSxNQUFNb0UsT0FBTyxDQUFDLEdBQUd4RixXQUFXdUIsT0FBTyxFQUFFSDtJQUNyQyxNQUFNaUYsU0FBUzlELE9BQU8rRCxHQUFHLENBQUMsQ0FBQzFEO1FBQ3ZCLE1BQU0yRCxNQUFNLEVBQUU7UUFDZCxJQUFLLElBQUkxRCxJQUFJLEdBQUcyQixNQUFNNUIsR0FBR0MsSUFBSXNELFdBQVd0RCxJQUFLO1lBQ3pDMEQsSUFBSXJDLElBQUksQ0FBQ007WUFDVEEsTUFBTUEsSUFBSVYsR0FBRyxDQUFDbEI7UUFDbEI7UUFDQSxPQUFPMkQ7SUFDWDtJQUNBLE9BQU8sQ0FBQ3hEO1FBQ0pELG1CQUFtQkMsU0FBU21DO1FBQzVCLElBQUluQyxRQUFRcUMsTUFBTSxHQUFHN0MsT0FBTzZDLE1BQU0sRUFDOUIsTUFBTSxJQUFJdEUsTUFBTTtRQUNwQixJQUFJeUYsTUFBTWpCO1FBQ1YsSUFBSyxJQUFJekMsSUFBSSxHQUFHQSxJQUFJdUQsUUFBUXZELElBQUs7WUFDN0Isa0RBQWtEO1lBQ2xELElBQUkwRCxRQUFRakIsTUFDUixJQUFLLElBQUlTLElBQUksR0FBR0EsSUFBSTNFLFlBQVkyRSxJQUM1QlEsTUFBTUEsSUFBSXhDLE1BQU07WUFDeEIsTUFBTXZDLFVBQVV0QixPQUFPa0csU0FBU2hGLGFBQWEsQ0FBQ3lCLElBQUksS0FBS3pCO1lBQ3ZELElBQUssSUFBSTJFLElBQUksR0FBR0EsSUFBSWhELFFBQVFxQyxNQUFNLEVBQUVXLElBQUs7Z0JBQ3JDLE1BQU1yRSxJQUFJcUIsT0FBTyxDQUFDZ0QsRUFBRTtnQkFDcEIsTUFBTVMsT0FBTzVGLE9BQU8sS0FBTVksVUFBV2dFO2dCQUNyQyxJQUFJLENBQUNnQixNQUNELFVBQVUsMkJBQTJCO2dCQUN6Q0QsTUFBTUEsSUFBSXpDLEdBQUcsQ0FBQ3VDLE1BQU0sQ0FBQ04sRUFBRSxDQUFDUyxPQUFPLEVBQUU7WUFDckM7UUFDSjtRQUNBLE9BQU9EO0lBQ1g7QUFDSjtBQUNBLFNBQVMxRyxjQUFjNEcsS0FBSztJQUN2QixJQUFHM0csYUFBYTRHLGFBQWEsRUFBRUQsTUFBTUUsRUFBRTtJQUN2QyxJQUFHM0csV0FBVzRHLGNBQWMsRUFBRUgsT0FBTztRQUNsQy9FLEdBQUc7UUFDSG1GLEdBQUc7UUFDSEMsSUFBSTtRQUNKQyxJQUFJO0lBQ1IsR0FBRztRQUNDQyxZQUFZO1FBQ1pDLGFBQWE7SUFDakI7SUFDQSxlQUFlO0lBQ2YsT0FBTzNILE9BQU80SCxNQUFNLENBQUM7UUFDakIsR0FBRyxDQUFDLEdBQUdwSCxhQUFhcUgsT0FBTyxFQUFFVixNQUFNL0UsQ0FBQyxFQUFFK0UsTUFBTU8sVUFBVSxDQUFDO1FBQ3ZELEdBQUdQLEtBQUs7UUFDUixHQUFHO1lBQUU3RCxHQUFHNkQsTUFBTUUsRUFBRSxDQUFDUyxLQUFLO1FBQUMsQ0FBQztJQUM1QjtBQUNKLEVBQ0EsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZmFyY2FzdGVyc3RhdHMvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9hYnN0cmFjdC9jdXJ2ZS5qcz84OGU3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy53TkFGID0gd05BRjtcbmV4cG9ydHMucGlwcGVuZ2VyID0gcGlwcGVuZ2VyO1xuZXhwb3J0cy5wcmVjb21wdXRlTVNNVW5zYWZlID0gcHJlY29tcHV0ZU1TTVVuc2FmZTtcbmV4cG9ydHMudmFsaWRhdGVCYXNpYyA9IHZhbGlkYXRlQmFzaWM7XG4vKipcbiAqIE1ldGhvZHMgZm9yIGVsbGlwdGljIGN1cnZlIG11bHRpcGxpY2F0aW9uIGJ5IHNjYWxhcnMuXG4gKiBDb250YWlucyB3TkFGLCBwaXBwZW5nZXJcbiAqIEBtb2R1bGVcbiAqL1xuLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuY29uc3QgbW9kdWxhcl90c18xID0gcmVxdWlyZShcIi4vbW9kdWxhci5qc1wiKTtcbmNvbnN0IHV0aWxzX3RzXzEgPSByZXF1aXJlKFwiLi91dGlscy5qc1wiKTtcbmNvbnN0IF8wbiA9IEJpZ0ludCgwKTtcbmNvbnN0IF8xbiA9IEJpZ0ludCgxKTtcbmZ1bmN0aW9uIGNvbnN0VGltZU5lZ2F0ZShjb25kaXRpb24sIGl0ZW0pIHtcbiAgICBjb25zdCBuZWcgPSBpdGVtLm5lZ2F0ZSgpO1xuICAgIHJldHVybiBjb25kaXRpb24gPyBuZWcgOiBpdGVtO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVXKFcsIGJpdHMpIHtcbiAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKFcpIHx8IFcgPD0gMCB8fCBXID4gYml0cylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHdpbmRvdyBzaXplLCBleHBlY3RlZCBbMS4uJyArIGJpdHMgKyAnXSwgZ290IFc9JyArIFcpO1xufVxuZnVuY3Rpb24gY2FsY1dPcHRzKFcsIHNjYWxhckJpdHMpIHtcbiAgICB2YWxpZGF0ZVcoVywgc2NhbGFyQml0cyk7XG4gICAgY29uc3Qgd2luZG93cyA9IE1hdGguY2VpbChzY2FsYXJCaXRzIC8gVykgKyAxOyAvLyBXPTggMzMuIE5vdCAzMiwgYmVjYXVzZSB3ZSBza2lwIHplcm9cbiAgICBjb25zdCB3aW5kb3dTaXplID0gMiAqKiAoVyAtIDEpOyAvLyBXPTggMTI4LiBOb3QgMjU2LCBiZWNhdXNlIHdlIHNraXAgemVyb1xuICAgIGNvbnN0IG1heE51bWJlciA9IDIgKiogVzsgLy8gVz04IDI1NlxuICAgIGNvbnN0IG1hc2sgPSAoMCwgdXRpbHNfdHNfMS5iaXRNYXNrKShXKTsgLy8gVz04IDI1NSA9PSBtYXNrIDBiMTExMTExMTFcbiAgICBjb25zdCBzaGlmdEJ5ID0gQmlnSW50KFcpOyAvLyBXPTggOFxuICAgIHJldHVybiB7IHdpbmRvd3MsIHdpbmRvd1NpemUsIG1hc2ssIG1heE51bWJlciwgc2hpZnRCeSB9O1xufVxuZnVuY3Rpb24gY2FsY09mZnNldHMobiwgd2luZG93LCB3T3B0cykge1xuICAgIGNvbnN0IHsgd2luZG93U2l6ZSwgbWFzaywgbWF4TnVtYmVyLCBzaGlmdEJ5IH0gPSB3T3B0cztcbiAgICBsZXQgd2JpdHMgPSBOdW1iZXIobiAmIG1hc2spOyAvLyBleHRyYWN0IFcgYml0cy5cbiAgICBsZXQgbmV4dE4gPSBuID4+IHNoaWZ0Qnk7IC8vIHNoaWZ0IG51bWJlciBieSBXIGJpdHMuXG4gICAgLy8gV2hhdCBhY3R1YWxseSBoYXBwZW5zIGhlcmU6XG4gICAgLy8gY29uc3QgaGlnaGVzdEJpdCA9IE51bWJlcihtYXNrIF4gKG1hc2sgPj4gMW4pKTtcbiAgICAvLyBsZXQgd2JpdHMyID0gd2JpdHMgLSAxOyAvLyBza2lwIHplcm9cbiAgICAvLyBpZiAod2JpdHMyICYgaGlnaGVzdEJpdCkgeyB3Yml0czIgXj0gTnVtYmVyKG1hc2spOyAvLyAofik7XG4gICAgLy8gc3BsaXQgaWYgYml0cyA+IG1heDogKzIyNCA9PiAyNTYtMzJcbiAgICBpZiAod2JpdHMgPiB3aW5kb3dTaXplKSB7XG4gICAgICAgIC8vIHdlIHNraXAgemVybywgd2hpY2ggbWVhbnMgaW5zdGVhZCBvZiBgPj0gc2l6ZS0xYCwgd2UgZG8gYD4gc2l6ZWBcbiAgICAgICAgd2JpdHMgLT0gbWF4TnVtYmVyOyAvLyAtMzIsIGNhbiBiZSBtYXhOdW1iZXIgLSB3Yml0cywgYnV0IHRoZW4gd2UgbmVlZCB0byBzZXQgaXNOZWcgaGVyZS5cbiAgICAgICAgbmV4dE4gKz0gXzFuOyAvLyArMjU2IChjYXJyeSlcbiAgICB9XG4gICAgY29uc3Qgb2Zmc2V0U3RhcnQgPSB3aW5kb3cgKiB3aW5kb3dTaXplO1xuICAgIGNvbnN0IG9mZnNldCA9IG9mZnNldFN0YXJ0ICsgTWF0aC5hYnMod2JpdHMpIC0gMTsgLy8gLTEgYmVjYXVzZSB3ZSBza2lwIHplcm9cbiAgICBjb25zdCBpc1plcm8gPSB3Yml0cyA9PT0gMDsgLy8gaXMgY3VycmVudCB3aW5kb3cgc2xpY2UgYSAwP1xuICAgIGNvbnN0IGlzTmVnID0gd2JpdHMgPCAwOyAvLyBpcyBjdXJyZW50IHdpbmRvdyBzbGljZSBuZWdhdGl2ZT9cbiAgICBjb25zdCBpc05lZ0YgPSB3aW5kb3cgJSAyICE9PSAwOyAvLyBmYWtlIHJhbmRvbSBzdGF0ZW1lbnQgZm9yIG5vaXNlXG4gICAgY29uc3Qgb2Zmc2V0RiA9IG9mZnNldFN0YXJ0OyAvLyBmYWtlIG9mZnNldCBmb3Igbm9pc2VcbiAgICByZXR1cm4geyBuZXh0Tiwgb2Zmc2V0LCBpc1plcm8sIGlzTmVnLCBpc05lZ0YsIG9mZnNldEYgfTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlTVNNUG9pbnRzKHBvaW50cywgYykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShwb2ludHMpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FycmF5IGV4cGVjdGVkJyk7XG4gICAgcG9pbnRzLmZvckVhY2goKHAsIGkpID0+IHtcbiAgICAgICAgaWYgKCEocCBpbnN0YW5jZW9mIGMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHBvaW50IGF0IGluZGV4ICcgKyBpKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlTVNNU2NhbGFycyhzY2FsYXJzLCBmaWVsZCkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShzY2FsYXJzKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhcnJheSBvZiBzY2FsYXJzIGV4cGVjdGVkJyk7XG4gICAgc2NhbGFycy5mb3JFYWNoKChzLCBpKSA9PiB7XG4gICAgICAgIGlmICghZmllbGQuaXNWYWxpZChzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBzY2FsYXIgYXQgaW5kZXggJyArIGkpO1xuICAgIH0pO1xufVxuLy8gU2luY2UgcG9pbnRzIGluIGRpZmZlcmVudCBncm91cHMgY2Fubm90IGJlIGVxdWFsIChkaWZmZXJlbnQgb2JqZWN0IGNvbnN0cnVjdG9yKSxcbi8vIHdlIGNhbiBoYXZlIHNpbmdsZSBwbGFjZSB0byBzdG9yZSBwcmVjb21wdXRlcy5cbi8vIEFsbG93cyB0byBtYWtlIHBvaW50cyBmcm96ZW4gLyBpbW11dGFibGUuXG5jb25zdCBwb2ludFByZWNvbXB1dGVzID0gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IHBvaW50V2luZG93U2l6ZXMgPSBuZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gZ2V0VyhQKSB7XG4gICAgcmV0dXJuIHBvaW50V2luZG93U2l6ZXMuZ2V0KFApIHx8IDE7XG59XG4vKipcbiAqIEVsbGlwdGljIGN1cnZlIG11bHRpcGxpY2F0aW9uIG9mIFBvaW50IGJ5IHNjYWxhci4gRnJhZ2lsZS5cbiAqIFNjYWxhcnMgc2hvdWxkIGFsd2F5cyBiZSBsZXNzIHRoYW4gY3VydmUgb3JkZXI6IHRoaXMgc2hvdWxkIGJlIGNoZWNrZWQgaW5zaWRlIG9mIGEgY3VydmUgaXRzZWxmLlxuICogQ3JlYXRlcyBwcmVjb21wdXRhdGlvbiB0YWJsZXMgZm9yIGZhc3QgbXVsdGlwbGljYXRpb246XG4gKiAtIHByaXZhdGUgc2NhbGFyIGlzIHNwbGl0IGJ5IGZpeGVkIHNpemUgd2luZG93cyBvZiBXIGJpdHNcbiAqIC0gZXZlcnkgd2luZG93IHBvaW50IGlzIGNvbGxlY3RlZCBmcm9tIHdpbmRvdydzIHRhYmxlICYgYWRkZWQgdG8gYWNjdW11bGF0b3JcbiAqIC0gc2luY2Ugd2luZG93cyBhcmUgZGlmZmVyZW50LCBzYW1lIHBvaW50IGluc2lkZSB0YWJsZXMgd29uJ3QgYmUgYWNjZXNzZWQgbW9yZSB0aGFuIG9uY2UgcGVyIGNhbGNcbiAqIC0gZWFjaCBtdWx0aXBsaWNhdGlvbiBpcyAnTWF0aC5jZWlsKENVUlZFX09SREVSIC8g8J2RiikgKyAxJyBwb2ludCBhZGRpdGlvbnMgKGZpeGVkIGZvciBhbnkgc2NhbGFyKVxuICogLSArMSB3aW5kb3cgaXMgbmVjY2Vzc2FyeSBmb3Igd05BRlxuICogLSB3TkFGIHJlZHVjZXMgdGFibGUgc2l6ZTogMnggbGVzcyBtZW1vcnkgKyAyeCBmYXN0ZXIgZ2VuZXJhdGlvbiwgYnV0IDEwJSBzbG93ZXIgbXVsdGlwbGljYXRpb25cbiAqXG4gKiBAdG9kbyBSZXNlYXJjaCByZXR1cm5pbmcgMmQgSlMgYXJyYXkgb2Ygd2luZG93cywgaW5zdGVhZCBvZiBhIHNpbmdsZSB3aW5kb3cuXG4gKiBUaGlzIHdvdWxkIGFsbG93IHdpbmRvd3MgdG8gYmUgaW4gZGlmZmVyZW50IG1lbW9yeSBsb2NhdGlvbnNcbiAqL1xuZnVuY3Rpb24gd05BRihjLCBiaXRzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29uc3RUaW1lTmVnYXRlLFxuICAgICAgICBoYXNQcmVjb21wdXRlcyhlbG0pIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRXKGVsbSkgIT09IDE7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIG5vbi1jb25zdCB0aW1lIG11bHRpcGxpY2F0aW9uIGxhZGRlclxuICAgICAgICB1bnNhZmVMYWRkZXIoZWxtLCBuLCBwID0gYy5aRVJPKSB7XG4gICAgICAgICAgICBsZXQgZCA9IGVsbTtcbiAgICAgICAgICAgIHdoaWxlIChuID4gXzBuKSB7XG4gICAgICAgICAgICAgICAgaWYgKG4gJiBfMW4pXG4gICAgICAgICAgICAgICAgICAgIHAgPSBwLmFkZChkKTtcbiAgICAgICAgICAgICAgICBkID0gZC5kb3VibGUoKTtcbiAgICAgICAgICAgICAgICBuID4+PSBfMW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSB3TkFGIHByZWNvbXB1dGF0aW9uIHdpbmRvdy4gVXNlZCBmb3IgY2FjaGluZy5cbiAgICAgICAgICogRGVmYXVsdCB3aW5kb3cgc2l6ZSBpcyBzZXQgYnkgYHV0aWxzLnByZWNvbXB1dGUoKWAgYW5kIGlzIGVxdWFsIHRvIDguXG4gICAgICAgICAqIE51bWJlciBvZiBwcmVjb21wdXRlZCBwb2ludHMgZGVwZW5kcyBvbiB0aGUgY3VydmUgc2l6ZTpcbiAgICAgICAgICogMl4o8J2RiuKIkjEpICogKE1hdGguY2VpbCjwnZGbIC8g8J2RiikgKyAxKSwgd2hlcmU6XG4gICAgICAgICAqIC0g8J2RiiBpcyB0aGUgd2luZG93IHNpemVcbiAgICAgICAgICogLSDwnZGbIGlzIHRoZSBiaXRsZW5ndGggb2YgdGhlIGN1cnZlIG9yZGVyLlxuICAgICAgICAgKiBGb3IgYSAyNTYtYml0IGN1cnZlIGFuZCB3aW5kb3cgc2l6ZSA4LCB0aGUgbnVtYmVyIG9mIHByZWNvbXB1dGVkIHBvaW50cyBpcyAxMjggKiAzMyA9IDQyMjQuXG4gICAgICAgICAqIEBwYXJhbSBlbG0gUG9pbnQgaW5zdGFuY2VcbiAgICAgICAgICogQHBhcmFtIFcgd2luZG93IHNpemVcbiAgICAgICAgICogQHJldHVybnMgcHJlY29tcHV0ZWQgcG9pbnQgdGFibGVzIGZsYXR0ZW5lZCB0byBhIHNpbmdsZSBhcnJheVxuICAgICAgICAgKi9cbiAgICAgICAgcHJlY29tcHV0ZVdpbmRvdyhlbG0sIFcpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgd2luZG93cywgd2luZG93U2l6ZSB9ID0gY2FsY1dPcHRzKFcsIGJpdHMpO1xuICAgICAgICAgICAgY29uc3QgcG9pbnRzID0gW107XG4gICAgICAgICAgICBsZXQgcCA9IGVsbTtcbiAgICAgICAgICAgIGxldCBiYXNlID0gcDtcbiAgICAgICAgICAgIGZvciAobGV0IHdpbmRvdyA9IDA7IHdpbmRvdyA8IHdpbmRvd3M7IHdpbmRvdysrKSB7XG4gICAgICAgICAgICAgICAgYmFzZSA9IHA7XG4gICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goYmFzZSk7XG4gICAgICAgICAgICAgICAgLy8gaT0xLCBiYyB3ZSBza2lwIDBcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHdpbmRvd1NpemU7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBiYXNlID0gYmFzZS5hZGQocCk7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKGJhc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwID0gYmFzZS5kb3VibGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwb2ludHM7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbXBsZW1lbnRzIGVjIG11bHRpcGxpY2F0aW9uIHVzaW5nIHByZWNvbXB1dGVkIHRhYmxlcyBhbmQgdy1hcnkgbm9uLWFkamFjZW50IGZvcm0uXG4gICAgICAgICAqIEBwYXJhbSBXIHdpbmRvdyBzaXplXG4gICAgICAgICAqIEBwYXJhbSBwcmVjb21wdXRlcyBwcmVjb21wdXRlZCB0YWJsZXNcbiAgICAgICAgICogQHBhcmFtIG4gc2NhbGFyICh3ZSBkb24ndCBjaGVjayBoZXJlLCBidXQgc2hvdWxkIGJlIGxlc3MgdGhhbiBjdXJ2ZSBvcmRlcilcbiAgICAgICAgICogQHJldHVybnMgcmVhbCBhbmQgZmFrZSAoZm9yIGNvbnN0LXRpbWUpIHBvaW50c1xuICAgICAgICAgKi9cbiAgICAgICAgd05BRihXLCBwcmVjb21wdXRlcywgbikge1xuICAgICAgICAgICAgLy8gU21hbGxlciB2ZXJzaW9uOlxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BhdWxtaWxsci9ub2JsZS1zZWNwMjU2azEvYmxvYi80N2NiMTY2OWI2ZTUwNmFkNjZiMzVmZTdkNzYxMzJhZTk3NDY1ZGEyL2luZGV4LnRzI0w1MDItTDU0MVxuICAgICAgICAgICAgLy8gVE9ETzogY2hlY2sgdGhlIHNjYWxhciBpcyBsZXNzIHRoYW4gZ3JvdXAgb3JkZXI/XG4gICAgICAgICAgICAvLyB3TkFGIGJlaGF2aW9yIGlzIHVuZGVmaW5lZCBvdGhlcndpc2UuIEJ1dCBoYXZlIHRvIGNhcmVmdWxseSByZW1vdmVcbiAgICAgICAgICAgIC8vIG90aGVyIGNoZWNrcyBiZWZvcmUgd05BRi4gT1JERVIgPT0gYml0cyBoZXJlLlxuICAgICAgICAgICAgLy8gQWNjdW11bGF0b3JzXG4gICAgICAgICAgICBsZXQgcCA9IGMuWkVSTztcbiAgICAgICAgICAgIGxldCBmID0gYy5CQVNFO1xuICAgICAgICAgICAgLy8gVGhpcyBjb2RlIHdhcyBmaXJzdCB3cml0dGVuIHdpdGggYXNzdW1wdGlvbiB0aGF0ICdmJyBhbmQgJ3AnIHdpbGwgbmV2ZXIgYmUgaW5maW5pdHkgcG9pbnQ6XG4gICAgICAgICAgICAvLyBzaW5jZSBlYWNoIGFkZGl0aW9uIGlzIG11bHRpcGxpZWQgYnkgMiAqKiBXLCBpdCBjYW5ub3QgY2FuY2VsIGVhY2ggb3RoZXIuIEhvd2V2ZXIsXG4gICAgICAgICAgICAvLyB0aGVyZSBpcyBuZWdhdGUgbm93OiBpdCBpcyBwb3NzaWJsZSB0aGF0IG5lZ2F0ZWQgZWxlbWVudCBmcm9tIGxvdyB2YWx1ZVxuICAgICAgICAgICAgLy8gd291bGQgYmUgdGhlIHNhbWUgYXMgaGlnaCBlbGVtZW50LCB3aGljaCB3aWxsIGNyZWF0ZSBjYXJyeSBpbnRvIG5leHQgd2luZG93LlxuICAgICAgICAgICAgLy8gSXQncyBub3Qgb2J2aW91cyBob3cgdGhpcyBjYW4gZmFpbCwgYnV0IHN0aWxsIHdvcnRoIGludmVzdGlnYXRpbmcgbGF0ZXIuXG4gICAgICAgICAgICBjb25zdCB3byA9IGNhbGNXT3B0cyhXLCBiaXRzKTtcbiAgICAgICAgICAgIGZvciAobGV0IHdpbmRvdyA9IDA7IHdpbmRvdyA8IHdvLndpbmRvd3M7IHdpbmRvdysrKSB7XG4gICAgICAgICAgICAgICAgLy8gKG4gPT09IF8wbikgaXMgaGFuZGxlZCBhbmQgbm90IGVhcmx5LWV4aXRlZC4gaXNFdmVuIGFuZCBvZmZzZXRGIGFyZSB1c2VkIGZvciBub2lzZVxuICAgICAgICAgICAgICAgIGNvbnN0IHsgbmV4dE4sIG9mZnNldCwgaXNaZXJvLCBpc05lZywgaXNOZWdGLCBvZmZzZXRGIH0gPSBjYWxjT2Zmc2V0cyhuLCB3aW5kb3csIHdvKTtcbiAgICAgICAgICAgICAgICBuID0gbmV4dE47XG4gICAgICAgICAgICAgICAgaWYgKGlzWmVybykge1xuICAgICAgICAgICAgICAgICAgICAvLyBiaXRzIGFyZSAwOiBhZGQgZ2FyYmFnZSB0byBmYWtlIHBvaW50XG4gICAgICAgICAgICAgICAgICAgIC8vIEltcG9ydGFudCBwYXJ0IGZvciBjb25zdC10aW1lIGdldFB1YmxpY0tleTogYWRkIHJhbmRvbSBcIm5vaXNlXCIgcG9pbnQgdG8gZi5cbiAgICAgICAgICAgICAgICAgICAgZiA9IGYuYWRkKGNvbnN0VGltZU5lZ2F0ZShpc05lZ0YsIHByZWNvbXB1dGVzW29mZnNldEZdKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBiaXRzIGFyZSAxOiBhZGQgdG8gcmVzdWx0IHBvaW50XG4gICAgICAgICAgICAgICAgICAgIHAgPSBwLmFkZChjb25zdFRpbWVOZWdhdGUoaXNOZWcsIHByZWNvbXB1dGVzW29mZnNldF0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSZXR1cm4gYm90aCByZWFsIGFuZCBmYWtlIHBvaW50czogSklUIHdvbid0IGVsaW1pbmF0ZSBmLlxuICAgICAgICAgICAgLy8gQXQgdGhpcyBwb2ludCB0aGVyZSBpcyBhIHdheSB0byBGIGJlIGluZmluaXR5LXBvaW50IGV2ZW4gaWYgcCBpcyBub3QsXG4gICAgICAgICAgICAvLyB3aGljaCBtYWtlcyBpdCBsZXNzIGNvbnN0LXRpbWU6IGFyb3VuZCAxIGJpZ2ludCBtdWx0aXBseS5cbiAgICAgICAgICAgIHJldHVybiB7IHAsIGYgfTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEltcGxlbWVudHMgZWMgdW5zYWZlIChub24gY29uc3QtdGltZSkgbXVsdGlwbGljYXRpb24gdXNpbmcgcHJlY29tcHV0ZWQgdGFibGVzIGFuZCB3LWFyeSBub24tYWRqYWNlbnQgZm9ybS5cbiAgICAgICAgICogQHBhcmFtIFcgd2luZG93IHNpemVcbiAgICAgICAgICogQHBhcmFtIHByZWNvbXB1dGVzIHByZWNvbXB1dGVkIHRhYmxlc1xuICAgICAgICAgKiBAcGFyYW0gbiBzY2FsYXIgKHdlIGRvbid0IGNoZWNrIGhlcmUsIGJ1dCBzaG91bGQgYmUgbGVzcyB0aGFuIGN1cnZlIG9yZGVyKVxuICAgICAgICAgKiBAcGFyYW0gYWNjIGFjY3VtdWxhdG9yIHBvaW50IHRvIGFkZCByZXN1bHQgb2YgbXVsdGlwbGljYXRpb25cbiAgICAgICAgICogQHJldHVybnMgcG9pbnRcbiAgICAgICAgICovXG4gICAgICAgIHdOQUZVbnNhZmUoVywgcHJlY29tcHV0ZXMsIG4sIGFjYyA9IGMuWkVSTykge1xuICAgICAgICAgICAgY29uc3Qgd28gPSBjYWxjV09wdHMoVywgYml0cyk7XG4gICAgICAgICAgICBmb3IgKGxldCB3aW5kb3cgPSAwOyB3aW5kb3cgPCB3by53aW5kb3dzOyB3aW5kb3crKykge1xuICAgICAgICAgICAgICAgIGlmIChuID09PSBfMG4pXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrOyAvLyBFYXJseS1leGl0LCBza2lwIDAgdmFsdWVcbiAgICAgICAgICAgICAgICBjb25zdCB7IG5leHROLCBvZmZzZXQsIGlzWmVybywgaXNOZWcgfSA9IGNhbGNPZmZzZXRzKG4sIHdpbmRvdywgd28pO1xuICAgICAgICAgICAgICAgIG4gPSBuZXh0TjtcbiAgICAgICAgICAgICAgICBpZiAoaXNaZXJvKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdpbmRvdyBiaXRzIGFyZSAwOiBza2lwIHByb2Nlc3NpbmcuXG4gICAgICAgICAgICAgICAgICAgIC8vIE1vdmUgdG8gbmV4dCB3aW5kb3cuXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaXRlbSA9IHByZWNvbXB1dGVzW29mZnNldF07XG4gICAgICAgICAgICAgICAgICAgIGFjYyA9IGFjYy5hZGQoaXNOZWcgPyBpdGVtLm5lZ2F0ZSgpIDogaXRlbSk7IC8vIFJlLXVzaW5nIGFjYyBhbGxvd3MgdG8gc2F2ZSBhZGRzIGluIE1TTVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIH0sXG4gICAgICAgIGdldFByZWNvbXB1dGVzKFcsIFAsIHRyYW5zZm9ybSkge1xuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHByZWNvbXB1dGVzIG9uIGEgZmlyc3QgcnVuLCByZXVzZSB0aGVtIGFmdGVyXG4gICAgICAgICAgICBsZXQgY29tcCA9IHBvaW50UHJlY29tcHV0ZXMuZ2V0KFApO1xuICAgICAgICAgICAgaWYgKCFjb21wKSB7XG4gICAgICAgICAgICAgICAgY29tcCA9IHRoaXMucHJlY29tcHV0ZVdpbmRvdyhQLCBXKTtcbiAgICAgICAgICAgICAgICBpZiAoVyAhPT0gMSlcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRQcmVjb21wdXRlcy5zZXQoUCwgdHJhbnNmb3JtKGNvbXApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjb21wO1xuICAgICAgICB9LFxuICAgICAgICB3TkFGQ2FjaGVkKFAsIG4sIHRyYW5zZm9ybSkge1xuICAgICAgICAgICAgY29uc3QgVyA9IGdldFcoUCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53TkFGKFcsIHRoaXMuZ2V0UHJlY29tcHV0ZXMoVywgUCwgdHJhbnNmb3JtKSwgbik7XG4gICAgICAgIH0sXG4gICAgICAgIHdOQUZDYWNoZWRVbnNhZmUoUCwgbiwgdHJhbnNmb3JtLCBwcmV2KSB7XG4gICAgICAgICAgICBjb25zdCBXID0gZ2V0VyhQKTtcbiAgICAgICAgICAgIGlmIChXID09PSAxKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnVuc2FmZUxhZGRlcihQLCBuLCBwcmV2KTsgLy8gRm9yIFc9MSBsYWRkZXIgaXMgfngyIGZhc3RlclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMud05BRlVuc2FmZShXLCB0aGlzLmdldFByZWNvbXB1dGVzKFcsIFAsIHRyYW5zZm9ybSksIG4sIHByZXYpO1xuICAgICAgICB9LFxuICAgICAgICAvLyBXZSBjYWxjdWxhdGUgcHJlY29tcHV0ZXMgZm9yIGVsbGlwdGljIGN1cnZlIHBvaW50IG11bHRpcGxpY2F0aW9uXG4gICAgICAgIC8vIHVzaW5nIHdpbmRvd2VkIG1ldGhvZC4gVGhpcyBzcGVjaWZpZXMgd2luZG93IHNpemUgYW5kXG4gICAgICAgIC8vIHN0b3JlcyBwcmVjb21wdXRlZCB2YWx1ZXMuIFVzdWFsbHkgb25seSBiYXNlIHBvaW50IHdvdWxkIGJlIHByZWNvbXB1dGVkLlxuICAgICAgICBzZXRXaW5kb3dTaXplKFAsIFcpIHtcbiAgICAgICAgICAgIHZhbGlkYXRlVyhXLCBiaXRzKTtcbiAgICAgICAgICAgIHBvaW50V2luZG93U2l6ZXMuc2V0KFAsIFcpO1xuICAgICAgICAgICAgcG9pbnRQcmVjb21wdXRlcy5kZWxldGUoUCk7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbi8qKlxuICogUGlwcGVuZ2VyIGFsZ29yaXRobSBmb3IgbXVsdGktc2NhbGFyIG11bHRpcGxpY2F0aW9uIChNU00sIFBhICsgUWIgKyBSYyArIC4uLikuXG4gKiAzMHggZmFzdGVyIHZzIG5haXZlIGFkZGl0aW9uIG9uIEw9NDA5NiwgMTB4IGZhc3RlciB0aGFuIHByZWNvbXB1dGVzLlxuICogRm9yIE49MjU0Yml0LCBMPTEsIGl0IGRvZXM6IDEwMjQgQUREICsgMjU0IERCTC4gRm9yIEw9NTogMTUzNiBBREQgKyAyNTQgREJMLlxuICogQWxnb3JpdGhtaWNhbGx5IGNvbnN0YW50LXRpbWUgKGZvciBzYW1lIEwpLCBldmVuIHdoZW4gMSBwb2ludCArIHNjYWxhciwgb3Igd2hlbiBzY2FsYXIgPSAwLlxuICogQHBhcmFtIGMgQ3VydmUgUG9pbnQgY29uc3RydWN0b3JcbiAqIEBwYXJhbSBmaWVsZE4gZmllbGQgb3ZlciBDVVJWRS5OIC0gaW1wb3J0YW50IHRoYXQgaXQncyBub3Qgb3ZlciBDVVJWRS5QXG4gKiBAcGFyYW0gcG9pbnRzIGFycmF5IG9mIEwgY3VydmUgcG9pbnRzXG4gKiBAcGFyYW0gc2NhbGFycyBhcnJheSBvZiBMIHNjYWxhcnMgKGFrYSBwcml2YXRlIGtleXMgLyBiaWdpbnRzKVxuICovXG5mdW5jdGlvbiBwaXBwZW5nZXIoYywgZmllbGROLCBwb2ludHMsIHNjYWxhcnMpIHtcbiAgICAvLyBJZiB3ZSBzcGxpdCBzY2FsYXJzIGJ5IHNvbWUgd2luZG93IChsZXQncyBzYXkgOCBiaXRzKSwgZXZlcnkgY2h1bmsgd2lsbCBvbmx5XG4gICAgLy8gdGFrZSAyNTYgYnVja2V0cyBldmVuIGlmIHRoZXJlIGFyZSA0MDk2IHNjYWxhcnMsIGFsc28gcmUtdXNlcyBkb3VibGUuXG4gICAgLy8gVE9ETzpcbiAgICAvLyAtIGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMjQvNzUwLnBkZlxuICAgIC8vIC0gaHR0cHM6Ly90Y2hlcy5pYWNyLm9yZy9pbmRleC5waHAvVENIRVMvYXJ0aWNsZS92aWV3LzEwMjg3XG4gICAgLy8gMCBpcyBhY2NlcHRlZCBpbiBzY2FsYXJzXG4gICAgdmFsaWRhdGVNU01Qb2ludHMocG9pbnRzLCBjKTtcbiAgICB2YWxpZGF0ZU1TTVNjYWxhcnMoc2NhbGFycywgZmllbGROKTtcbiAgICBjb25zdCBwbGVuZ3RoID0gcG9pbnRzLmxlbmd0aDtcbiAgICBjb25zdCBzbGVuZ3RoID0gc2NhbGFycy5sZW5ndGg7XG4gICAgaWYgKHBsZW5ndGggIT09IHNsZW5ndGgpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYXJyYXlzIG9mIHBvaW50cyBhbmQgc2NhbGFycyBtdXN0IGhhdmUgZXF1YWwgbGVuZ3RoJyk7XG4gICAgLy8gaWYgKHBsZW5ndGggPT09IDApIHRocm93IG5ldyBFcnJvcignYXJyYXkgbXVzdCBiZSBvZiBsZW5ndGggPj0gMicpO1xuICAgIGNvbnN0IHplcm8gPSBjLlpFUk87XG4gICAgY29uc3Qgd2JpdHMgPSAoMCwgdXRpbHNfdHNfMS5iaXRMZW4pKEJpZ0ludChwbGVuZ3RoKSk7XG4gICAgbGV0IHdpbmRvd1NpemUgPSAxOyAvLyBiaXRzXG4gICAgaWYgKHdiaXRzID4gMTIpXG4gICAgICAgIHdpbmRvd1NpemUgPSB3Yml0cyAtIDM7XG4gICAgZWxzZSBpZiAod2JpdHMgPiA0KVxuICAgICAgICB3aW5kb3dTaXplID0gd2JpdHMgLSAyO1xuICAgIGVsc2UgaWYgKHdiaXRzID4gMClcbiAgICAgICAgd2luZG93U2l6ZSA9IDI7XG4gICAgY29uc3QgTUFTSyA9ICgwLCB1dGlsc190c18xLmJpdE1hc2spKHdpbmRvd1NpemUpO1xuICAgIGNvbnN0IGJ1Y2tldHMgPSBuZXcgQXJyYXkoTnVtYmVyKE1BU0spICsgMSkuZmlsbCh6ZXJvKTsgLy8gKzEgZm9yIHplcm8gYXJyYXlcbiAgICBjb25zdCBsYXN0Qml0cyA9IE1hdGguZmxvb3IoKGZpZWxkTi5CSVRTIC0gMSkgLyB3aW5kb3dTaXplKSAqIHdpbmRvd1NpemU7XG4gICAgbGV0IHN1bSA9IHplcm87XG4gICAgZm9yIChsZXQgaSA9IGxhc3RCaXRzOyBpID49IDA7IGkgLT0gd2luZG93U2l6ZSkge1xuICAgICAgICBidWNrZXRzLmZpbGwoemVybyk7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgc2xlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBjb25zdCBzY2FsYXIgPSBzY2FsYXJzW2pdO1xuICAgICAgICAgICAgY29uc3Qgd2JpdHMgPSBOdW1iZXIoKHNjYWxhciA+PiBCaWdJbnQoaSkpICYgTUFTSyk7XG4gICAgICAgICAgICBidWNrZXRzW3diaXRzXSA9IGJ1Y2tldHNbd2JpdHNdLmFkZChwb2ludHNbal0pO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXNJID0gemVybzsgLy8gbm90IHVzaW5nIHRoaXMgd2lsbCBkbyBzbWFsbCBzcGVlZC11cCwgYnV0IHdpbGwgbG9zZSBjdFxuICAgICAgICAvLyBTa2lwIGZpcnN0IGJ1Y2tldCwgYmVjYXVzZSBpdCBpcyB6ZXJvXG4gICAgICAgIGZvciAobGV0IGogPSBidWNrZXRzLmxlbmd0aCAtIDEsIHN1bUkgPSB6ZXJvOyBqID4gMDsgai0tKSB7XG4gICAgICAgICAgICBzdW1JID0gc3VtSS5hZGQoYnVja2V0c1tqXSk7XG4gICAgICAgICAgICByZXNJID0gcmVzSS5hZGQoc3VtSSk7XG4gICAgICAgIH1cbiAgICAgICAgc3VtID0gc3VtLmFkZChyZXNJKTtcbiAgICAgICAgaWYgKGkgIT09IDApXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHdpbmRvd1NpemU7IGorKylcbiAgICAgICAgICAgICAgICBzdW0gPSBzdW0uZG91YmxlKCk7XG4gICAgfVxuICAgIHJldHVybiBzdW07XG59XG4vKipcbiAqIFByZWNvbXB1dGVkIG11bHRpLXNjYWxhciBtdWx0aXBsaWNhdGlvbiAoTVNNLCBQYSArIFFiICsgUmMgKyAuLi4pLlxuICogQHBhcmFtIGMgQ3VydmUgUG9pbnQgY29uc3RydWN0b3JcbiAqIEBwYXJhbSBmaWVsZE4gZmllbGQgb3ZlciBDVVJWRS5OIC0gaW1wb3J0YW50IHRoYXQgaXQncyBub3Qgb3ZlciBDVVJWRS5QXG4gKiBAcGFyYW0gcG9pbnRzIGFycmF5IG9mIEwgY3VydmUgcG9pbnRzXG4gKiBAcmV0dXJucyBmdW5jdGlvbiB3aGljaCBtdWx0aXBsaWVzIHBvaW50cyB3aXRoIHNjYWFyc1xuICovXG5mdW5jdGlvbiBwcmVjb21wdXRlTVNNVW5zYWZlKGMsIGZpZWxkTiwgcG9pbnRzLCB3aW5kb3dTaXplKSB7XG4gICAgLyoqXG4gICAgICogUGVyZm9ybWFuY2UgQW5hbHlzaXMgb2YgV2luZG93LWJhc2VkIFByZWNvbXB1dGF0aW9uXG4gICAgICpcbiAgICAgKiBCYXNlIENhc2UgKDI1Ni1iaXQgc2NhbGFyLCA4LWJpdCB3aW5kb3cpOlxuICAgICAqIC0gU3RhbmRhcmQgcHJlY29tcHV0YXRpb24gcmVxdWlyZXM6XG4gICAgICogICAtIDMxIGFkZGl0aW9ucyBwZXIgc2NhbGFyIMOXIDI1NiBzY2FsYXJzID0gNyw5MzYgb3BzXG4gICAgICogICAtIFBsdXMgMjU1IHN1bW1hcnkgYWRkaXRpb25zID0gOCwxOTEgdG90YWwgb3BzXG4gICAgICogICBOb3RlOiBTdW1tYXJ5IGFkZGl0aW9ucyBjYW4gYmUgb3B0aW1pemVkIHZpYSBhY2N1bXVsYXRvclxuICAgICAqXG4gICAgICogQ2h1bmtlZCBQcmVjb21wdXRhdGlvbiBBbmFseXNpczpcbiAgICAgKiAtIFVzaW5nIDMyIGNodW5rcyByZXF1aXJlczpcbiAgICAgKiAgIC0gMjU1IGFkZGl0aW9ucyBwZXIgY2h1bmtcbiAgICAgKiAgIC0gMjU2IGRvdWJsaW5nc1xuICAgICAqICAgLSBUb3RhbDogKDI1NSDDlyAzMikgKyAyNTYgPSA4LDQxNiBvcHNcbiAgICAgKlxuICAgICAqIE1lbW9yeSBVc2FnZSBDb21wYXJpc29uOlxuICAgICAqIFdpbmRvdyBTaXplIHwgU3RhbmRhcmQgUG9pbnRzIHwgQ2h1bmtlZCBQb2ludHNcbiAgICAgKiAtLS0tLS0tLS0tLS18LS0tLS0tLS0tLS0tLS0tLS18LS0tLS0tLS0tLS0tLS0tXG4gICAgICogICAgIDQtYml0ICAgfCAgICAgNTIwICAgICAgICAgfCAgICAgIDE1XG4gICAgICogICAgIDgtYml0ICAgfCAgICA0LDIyNCAgICAgICAgfCAgICAgMjU1XG4gICAgICogICAgMTAtYml0ICAgfCAgIDEzLDgyNCAgICAgICAgfCAgIDEsMDIzXG4gICAgICogICAgMTYtYml0ICAgfCAgNTU3LDA1NiAgICAgICAgfCAgNjUsNTM1XG4gICAgICpcbiAgICAgKiBLZXkgQWR2YW50YWdlczpcbiAgICAgKiAxLiBFbmFibGVzIGxhcmdlciB3aW5kb3cgc2l6ZXMgZHVlIHRvIHJlZHVjZWQgbWVtb3J5IG92ZXJoZWFkXG4gICAgICogMi4gTW9yZSBlZmZpY2llbnQgZm9yIHNtYWxsZXIgc2NhbGFyIGNvdW50czpcbiAgICAgKiAgICAtIDE2IGNodW5rczogKDE2IMOXIDI1NSkgKyAyNTYgPSA0LDMzNiBvcHNcbiAgICAgKiAgICAtIH4yeCBmYXN0ZXIgdGhhbiBzdGFuZGFyZCA4LDE5MSBvcHNcbiAgICAgKlxuICAgICAqIExpbWl0YXRpb25zOlxuICAgICAqIC0gTm90IHN1aXRhYmxlIGZvciBwbGFpbiBwcmVjb21wdXRlcyAocmVxdWlyZXMgMjU2IGNvbnN0YW50IGRvdWJsaW5ncylcbiAgICAgKiAtIFBlcmZvcm1hbmNlIGRlZ3JhZGVzIHdpdGggbGFyZ2VyIHNjYWxhciBjb3VudHM6XG4gICAgICogICAtIE9wdGltYWwgZm9yIH4yNTYgc2NhbGFyc1xuICAgICAqICAgLSBMZXNzIGVmZmljaWVudCBmb3IgNDA5Nisgc2NhbGFycyAoUGlwcGVuZ2VyIHByZWZlcnJlZClcbiAgICAgKi9cbiAgICB2YWxpZGF0ZVcod2luZG93U2l6ZSwgZmllbGROLkJJVFMpO1xuICAgIHZhbGlkYXRlTVNNUG9pbnRzKHBvaW50cywgYyk7XG4gICAgY29uc3QgemVybyA9IGMuWkVSTztcbiAgICBjb25zdCB0YWJsZVNpemUgPSAyICoqIHdpbmRvd1NpemUgLSAxOyAvLyB0YWJsZSBzaXplICh3aXRob3V0IHplcm8pXG4gICAgY29uc3QgY2h1bmtzID0gTWF0aC5jZWlsKGZpZWxkTi5CSVRTIC8gd2luZG93U2l6ZSk7IC8vIGNodW5rcyBvZiBpdGVtXG4gICAgY29uc3QgTUFTSyA9ICgwLCB1dGlsc190c18xLmJpdE1hc2spKHdpbmRvd1NpemUpO1xuICAgIGNvbnN0IHRhYmxlcyA9IHBvaW50cy5tYXAoKHApID0+IHtcbiAgICAgICAgY29uc3QgcmVzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBhY2MgPSBwOyBpIDwgdGFibGVTaXplOyBpKyspIHtcbiAgICAgICAgICAgIHJlcy5wdXNoKGFjYyk7XG4gICAgICAgICAgICBhY2MgPSBhY2MuYWRkKHApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfSk7XG4gICAgcmV0dXJuIChzY2FsYXJzKSA9PiB7XG4gICAgICAgIHZhbGlkYXRlTVNNU2NhbGFycyhzY2FsYXJzLCBmaWVsZE4pO1xuICAgICAgICBpZiAoc2NhbGFycy5sZW5ndGggPiBwb2ludHMubGVuZ3RoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhcnJheSBvZiBzY2FsYXJzIG11c3QgYmUgc21hbGxlciB0aGFuIGFycmF5IG9mIHBvaW50cycpO1xuICAgICAgICBsZXQgcmVzID0gemVybztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaHVua3M7IGkrKykge1xuICAgICAgICAgICAgLy8gTm8gbmVlZCB0byBkb3VibGUgaWYgYWNjdW11bGF0b3IgaXMgc3RpbGwgemVyby5cbiAgICAgICAgICAgIGlmIChyZXMgIT09IHplcm8pXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB3aW5kb3dTaXplOyBqKyspXG4gICAgICAgICAgICAgICAgICAgIHJlcyA9IHJlcy5kb3VibGUoKTtcbiAgICAgICAgICAgIGNvbnN0IHNoaWZ0QnkgPSBCaWdJbnQoY2h1bmtzICogd2luZG93U2l6ZSAtIChpICsgMSkgKiB3aW5kb3dTaXplKTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgc2NhbGFycy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG4gPSBzY2FsYXJzW2pdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnIgPSBOdW1iZXIoKG4gPj4gc2hpZnRCeSkgJiBNQVNLKTtcbiAgICAgICAgICAgICAgICBpZiAoIWN1cnIpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlOyAvLyBza2lwIHplcm8gc2NhbGFycyBjaHVua3NcbiAgICAgICAgICAgICAgICByZXMgPSByZXMuYWRkKHRhYmxlc1tqXVtjdXJyIC0gMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlQmFzaWMoY3VydmUpIHtcbiAgICAoMCwgbW9kdWxhcl90c18xLnZhbGlkYXRlRmllbGQpKGN1cnZlLkZwKTtcbiAgICAoMCwgdXRpbHNfdHNfMS52YWxpZGF0ZU9iamVjdCkoY3VydmUsIHtcbiAgICAgICAgbjogJ2JpZ2ludCcsXG4gICAgICAgIGg6ICdiaWdpbnQnLFxuICAgICAgICBHeDogJ2ZpZWxkJyxcbiAgICAgICAgR3k6ICdmaWVsZCcsXG4gICAgfSwge1xuICAgICAgICBuQml0TGVuZ3RoOiAnaXNTYWZlSW50ZWdlcicsXG4gICAgICAgIG5CeXRlTGVuZ3RoOiAnaXNTYWZlSW50ZWdlcicsXG4gICAgfSk7XG4gICAgLy8gU2V0IGRlZmF1bHRzXG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoe1xuICAgICAgICAuLi4oMCwgbW9kdWxhcl90c18xLm5MZW5ndGgpKGN1cnZlLm4sIGN1cnZlLm5CaXRMZW5ndGgpLFxuICAgICAgICAuLi5jdXJ2ZSxcbiAgICAgICAgLi4ueyBwOiBjdXJ2ZS5GcC5PUkRFUiB9LFxuICAgIH0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3VydmUuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwid05BRiIsInBpcHBlbmdlciIsInByZWNvbXB1dGVNU01VbnNhZmUiLCJ2YWxpZGF0ZUJhc2ljIiwibW9kdWxhcl90c18xIiwicmVxdWlyZSIsInV0aWxzX3RzXzEiLCJfMG4iLCJCaWdJbnQiLCJfMW4iLCJjb25zdFRpbWVOZWdhdGUiLCJjb25kaXRpb24iLCJpdGVtIiwibmVnIiwibmVnYXRlIiwidmFsaWRhdGVXIiwiVyIsImJpdHMiLCJOdW1iZXIiLCJpc1NhZmVJbnRlZ2VyIiwiRXJyb3IiLCJjYWxjV09wdHMiLCJzY2FsYXJCaXRzIiwid2luZG93cyIsIk1hdGgiLCJjZWlsIiwid2luZG93U2l6ZSIsIm1heE51bWJlciIsIm1hc2siLCJiaXRNYXNrIiwic2hpZnRCeSIsImNhbGNPZmZzZXRzIiwibiIsIndpbmRvdyIsIndPcHRzIiwid2JpdHMiLCJuZXh0TiIsIm9mZnNldFN0YXJ0Iiwib2Zmc2V0IiwiYWJzIiwiaXNaZXJvIiwiaXNOZWciLCJpc05lZ0YiLCJvZmZzZXRGIiwidmFsaWRhdGVNU01Qb2ludHMiLCJwb2ludHMiLCJjIiwiQXJyYXkiLCJpc0FycmF5IiwiZm9yRWFjaCIsInAiLCJpIiwidmFsaWRhdGVNU01TY2FsYXJzIiwic2NhbGFycyIsImZpZWxkIiwicyIsImlzVmFsaWQiLCJwb2ludFByZWNvbXB1dGVzIiwiV2Vha01hcCIsInBvaW50V2luZG93U2l6ZXMiLCJnZXRXIiwiUCIsImdldCIsImhhc1ByZWNvbXB1dGVzIiwiZWxtIiwidW5zYWZlTGFkZGVyIiwiWkVSTyIsImQiLCJhZGQiLCJkb3VibGUiLCJwcmVjb21wdXRlV2luZG93IiwiYmFzZSIsInB1c2giLCJwcmVjb21wdXRlcyIsImYiLCJCQVNFIiwid28iLCJ3TkFGVW5zYWZlIiwiYWNjIiwiZ2V0UHJlY29tcHV0ZXMiLCJ0cmFuc2Zvcm0iLCJjb21wIiwic2V0Iiwid05BRkNhY2hlZCIsIndOQUZDYWNoZWRVbnNhZmUiLCJwcmV2Iiwic2V0V2luZG93U2l6ZSIsImRlbGV0ZSIsImZpZWxkTiIsInBsZW5ndGgiLCJsZW5ndGgiLCJzbGVuZ3RoIiwiemVybyIsImJpdExlbiIsIk1BU0siLCJidWNrZXRzIiwiZmlsbCIsImxhc3RCaXRzIiwiZmxvb3IiLCJCSVRTIiwic3VtIiwiaiIsInNjYWxhciIsInJlc0kiLCJzdW1JIiwidGFibGVTaXplIiwiY2h1bmtzIiwidGFibGVzIiwibWFwIiwicmVzIiwiY3VyciIsImN1cnZlIiwidmFsaWRhdGVGaWVsZCIsIkZwIiwidmFsaWRhdGVPYmplY3QiLCJoIiwiR3giLCJHeSIsIm5CaXRMZW5ndGgiLCJuQnl0ZUxlbmd0aCIsImZyZWV6ZSIsIm5MZW5ndGgiLCJPUkRFUiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@noble/curves/abstract/curve.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@noble/curves/abstract/hash-to-curve.js":
/*!**************************************************************!*\
  !*** ./node_modules/@noble/curves/abstract/hash-to-curve.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.expand_message_xmd = expand_message_xmd;\nexports.expand_message_xof = expand_message_xof;\nexports.hash_to_field = hash_to_field;\nexports.isogenyMap = isogenyMap;\nexports.createHasher = createHasher;\nconst modular_ts_1 = __webpack_require__(/*! ./modular.js */ \"(rsc)/./node_modules/@noble/curves/abstract/modular.js\");\nconst utils_ts_1 = __webpack_require__(/*! ./utils.js */ \"(rsc)/./node_modules/@noble/curves/abstract/utils.js\");\n// Octet Stream to Integer. \"spec\" implementation of os2ip is 2.5x slower vs bytesToNumberBE.\nconst os2ip = utils_ts_1.bytesToNumberBE;\n// Integer to Octet Stream (numberToBytesBE)\nfunction i2osp(value, length) {\n    anum(value);\n    anum(length);\n    if (value < 0 || value >= 1 << 8 * length) throw new Error(\"invalid I2OSP input: \" + value);\n    const res = Array.from({\n        length\n    }).fill(0);\n    for(let i = length - 1; i >= 0; i--){\n        res[i] = value & 0xff;\n        value >>>= 8;\n    }\n    return new Uint8Array(res);\n}\nfunction strxor(a, b) {\n    const arr = new Uint8Array(a.length);\n    for(let i = 0; i < a.length; i++){\n        arr[i] = a[i] ^ b[i];\n    }\n    return arr;\n}\nfunction anum(item) {\n    if (!Number.isSafeInteger(item)) throw new Error(\"number expected\");\n}\n/**\n * Produces a uniformly random byte string using a cryptographic hash function H that outputs b bits.\n * [RFC 9380 5.3.1](https://www.rfc-editor.org/rfc/rfc9380#section-5.3.1).\n */ function expand_message_xmd(msg, DST, lenInBytes, H) {\n    (0, utils_ts_1.abytes)(msg);\n    (0, utils_ts_1.abytes)(DST);\n    anum(lenInBytes);\n    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n    if (DST.length > 255) DST = H((0, utils_ts_1.concatBytes)((0, utils_ts_1.utf8ToBytes)(\"H2C-OVERSIZE-DST-\"), DST));\n    const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;\n    const ell = Math.ceil(lenInBytes / b_in_bytes);\n    if (lenInBytes > 65535 || ell > 255) throw new Error(\"expand_message_xmd: invalid lenInBytes\");\n    const DST_prime = (0, utils_ts_1.concatBytes)(DST, i2osp(DST.length, 1));\n    const Z_pad = i2osp(0, r_in_bytes);\n    const l_i_b_str = i2osp(lenInBytes, 2); // len_in_bytes_str\n    const b = new Array(ell);\n    const b_0 = H((0, utils_ts_1.concatBytes)(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));\n    b[0] = H((0, utils_ts_1.concatBytes)(b_0, i2osp(1, 1), DST_prime));\n    for(let i = 1; i <= ell; i++){\n        const args = [\n            strxor(b_0, b[i - 1]),\n            i2osp(i + 1, 1),\n            DST_prime\n        ];\n        b[i] = H((0, utils_ts_1.concatBytes)(...args));\n    }\n    const pseudo_random_bytes = (0, utils_ts_1.concatBytes)(...b);\n    return pseudo_random_bytes.slice(0, lenInBytes);\n}\n/**\n * Produces a uniformly random byte string using an extendable-output function (XOF) H.\n * 1. The collision resistance of H MUST be at least k bits.\n * 2. H MUST be an XOF that has been proved indifferentiable from\n *    a random oracle under a reasonable cryptographic assumption.\n * [RFC 9380 5.3.2](https://www.rfc-editor.org/rfc/rfc9380#section-5.3.2).\n */ function expand_message_xof(msg, DST, lenInBytes, k, H) {\n    (0, utils_ts_1.abytes)(msg);\n    (0, utils_ts_1.abytes)(DST);\n    anum(lenInBytes);\n    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n    // DST = H('H2C-OVERSIZE-DST-' || a_very_long_DST, Math.ceil((lenInBytes * k) / 8));\n    if (DST.length > 255) {\n        const dkLen = Math.ceil(2 * k / 8);\n        DST = H.create({\n            dkLen\n        }).update((0, utils_ts_1.utf8ToBytes)(\"H2C-OVERSIZE-DST-\")).update(DST).digest();\n    }\n    if (lenInBytes > 65535 || DST.length > 255) throw new Error(\"expand_message_xof: invalid lenInBytes\");\n    return H.create({\n        dkLen: lenInBytes\n    }).update(msg).update(i2osp(lenInBytes, 2))// 2. DST_prime = DST || I2OSP(len(DST), 1)\n    .update(DST).update(i2osp(DST.length, 1)).digest();\n}\n/**\n * Hashes arbitrary-length byte strings to a list of one or more elements of a finite field F.\n * [RFC 9380 5.2](https://www.rfc-editor.org/rfc/rfc9380#section-5.2).\n * @param msg a byte string containing the message to hash\n * @param count the number of elements of F to output\n * @param options `{DST: string, p: bigint, m: number, k: number, expand: 'xmd' | 'xof', hash: H}`, see above\n * @returns [u_0, ..., u_(count - 1)], a list of field elements.\n */ function hash_to_field(msg, count, options) {\n    (0, utils_ts_1.validateObject)(options, {\n        DST: \"stringOrUint8Array\",\n        p: \"bigint\",\n        m: \"isSafeInteger\",\n        k: \"isSafeInteger\",\n        hash: \"hash\"\n    });\n    const { p, k, m, hash, expand, DST: _DST } = options;\n    (0, utils_ts_1.abytes)(msg);\n    anum(count);\n    const DST = typeof _DST === \"string\" ? (0, utils_ts_1.utf8ToBytes)(_DST) : _DST;\n    const log2p = p.toString(2).length;\n    const L = Math.ceil((log2p + k) / 8); // section 5.1 of ietf draft link above\n    const len_in_bytes = count * m * L;\n    let prb; // pseudo_random_bytes\n    if (expand === \"xmd\") {\n        prb = expand_message_xmd(msg, DST, len_in_bytes, hash);\n    } else if (expand === \"xof\") {\n        prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);\n    } else if (expand === \"_internal_pass\") {\n        // for internal tests only\n        prb = msg;\n    } else {\n        throw new Error('expand must be \"xmd\" or \"xof\"');\n    }\n    const u = new Array(count);\n    for(let i = 0; i < count; i++){\n        const e = new Array(m);\n        for(let j = 0; j < m; j++){\n            const elm_offset = L * (j + i * m);\n            const tv = prb.subarray(elm_offset, elm_offset + L);\n            e[j] = (0, modular_ts_1.mod)(os2ip(tv), p);\n        }\n        u[i] = e;\n    }\n    return u;\n}\nfunction isogenyMap(field, map) {\n    // Make same order as in spec\n    const coeff = map.map((i)=>Array.from(i).reverse());\n    return (x, y)=>{\n        const [xn, xd, yn, yd] = coeff.map((val)=>val.reduce((acc, i)=>field.add(field.mul(acc, x), i)));\n        // 6.6.3\n        // Exceptional cases of iso_map are inputs that cause the denominator of\n        // either rational function to evaluate to zero; such cases MUST return\n        // the identity point on E.\n        const [xd_inv, yd_inv] = (0, modular_ts_1.FpInvertBatch)(field, [\n            xd,\n            yd\n        ], true);\n        x = field.mul(xn, xd_inv); // xNum / xDen\n        y = field.mul(y, field.mul(yn, yd_inv)); // y * (yNum / yDev)\n        return {\n            x,\n            y\n        };\n    };\n}\n/** Creates hash-to-curve methods from EC Point and mapToCurve function. */ function createHasher(Point, mapToCurve, defaults) {\n    if (typeof mapToCurve !== \"function\") throw new Error(\"mapToCurve() must be defined\");\n    function map(num) {\n        return Point.fromAffine(mapToCurve(num));\n    }\n    function clear(initial) {\n        const P = initial.clearCofactor();\n        if (P.equals(Point.ZERO)) return Point.ZERO; // zero will throw in assert\n        P.assertValidity();\n        return P;\n    }\n    return {\n        defaults,\n        // Encodes byte string to elliptic curve.\n        // hash_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3\n        hashToCurve (msg, options) {\n            const u = hash_to_field(msg, 2, {\n                ...defaults,\n                DST: defaults.DST,\n                ...options\n            });\n            const u0 = map(u[0]);\n            const u1 = map(u[1]);\n            return clear(u0.add(u1));\n        },\n        // Encodes byte string to elliptic curve.\n        // encode_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3\n        encodeToCurve (msg, options) {\n            const u = hash_to_field(msg, 1, {\n                ...defaults,\n                DST: defaults.encodeDST,\n                ...options\n            });\n            return clear(map(u[0]));\n        },\n        // Same as encodeToCurve, but without hash\n        mapToCurve (scalars) {\n            if (!Array.isArray(scalars)) throw new Error(\"expected array of bigints\");\n            for (const i of scalars)if (typeof i !== \"bigint\") throw new Error(\"expected array of bigints\");\n            return clear(map(scalars));\n        }\n    };\n} //# sourceMappingURL=hash-to-curve.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9hYnN0cmFjdC9oYXNoLXRvLWN1cnZlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCwwQkFBMEIsR0FBR0U7QUFDN0JGLDBCQUEwQixHQUFHRztBQUM3QkgscUJBQXFCLEdBQUdJO0FBQ3hCSixrQkFBa0IsR0FBR0s7QUFDckJMLG9CQUFvQixHQUFHTTtBQUN2QixNQUFNQyxlQUFlQyxtQkFBT0EsQ0FBQyw0RUFBYztBQUMzQyxNQUFNQyxhQUFhRCxtQkFBT0EsQ0FBQyx3RUFBWTtBQUN2Qyw2RkFBNkY7QUFDN0YsTUFBTUUsUUFBUUQsV0FBV0UsZUFBZTtBQUN4Qyw0Q0FBNEM7QUFDNUMsU0FBU0MsTUFBTVgsS0FBSyxFQUFFWSxNQUFNO0lBQ3hCQyxLQUFLYjtJQUNMYSxLQUFLRDtJQUNMLElBQUlaLFFBQVEsS0FBS0EsU0FBUyxLQUFNLElBQUlZLFFBQ2hDLE1BQU0sSUFBSUUsTUFBTSwwQkFBMEJkO0lBQzlDLE1BQU1lLE1BQU1DLE1BQU1DLElBQUksQ0FBQztRQUFFTDtJQUFPLEdBQUdNLElBQUksQ0FBQztJQUN4QyxJQUFLLElBQUlDLElBQUlQLFNBQVMsR0FBR08sS0FBSyxHQUFHQSxJQUFLO1FBQ2xDSixHQUFHLENBQUNJLEVBQUUsR0FBR25CLFFBQVE7UUFDakJBLFdBQVc7SUFDZjtJQUNBLE9BQU8sSUFBSW9CLFdBQVdMO0FBQzFCO0FBQ0EsU0FBU00sT0FBT0MsQ0FBQyxFQUFFQyxDQUFDO0lBQ2hCLE1BQU1DLE1BQU0sSUFBSUosV0FBV0UsRUFBRVYsTUFBTTtJQUNuQyxJQUFLLElBQUlPLElBQUksR0FBR0EsSUFBSUcsRUFBRVYsTUFBTSxFQUFFTyxJQUFLO1FBQy9CSyxHQUFHLENBQUNMLEVBQUUsR0FBR0csQ0FBQyxDQUFDSCxFQUFFLEdBQUdJLENBQUMsQ0FBQ0osRUFBRTtJQUN4QjtJQUNBLE9BQU9LO0FB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QUFJL0YsTUFBTTtZQUNwQixLQUFLLE1BQU1LLEtBQUswRixRQUNaLElBQUksT0FBTzFGLE1BQU0sVUFDYixNQUFNLElBQUlMLE1BQU07WUFDeEIsT0FBT21GLE1BQU10QixJQUFJa0M7UUFDckI7SUFDSjtBQUNKLEVBQ0EseUNBQXlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZmFyY2FzdGVyc3RhdHMvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9hYnN0cmFjdC9oYXNoLXRvLWN1cnZlLmpzPzMyOTQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmV4cGFuZF9tZXNzYWdlX3htZCA9IGV4cGFuZF9tZXNzYWdlX3htZDtcbmV4cG9ydHMuZXhwYW5kX21lc3NhZ2VfeG9mID0gZXhwYW5kX21lc3NhZ2VfeG9mO1xuZXhwb3J0cy5oYXNoX3RvX2ZpZWxkID0gaGFzaF90b19maWVsZDtcbmV4cG9ydHMuaXNvZ2VueU1hcCA9IGlzb2dlbnlNYXA7XG5leHBvcnRzLmNyZWF0ZUhhc2hlciA9IGNyZWF0ZUhhc2hlcjtcbmNvbnN0IG1vZHVsYXJfdHNfMSA9IHJlcXVpcmUoXCIuL21vZHVsYXIuanNcIik7XG5jb25zdCB1dGlsc190c18xID0gcmVxdWlyZShcIi4vdXRpbHMuanNcIik7XG4vLyBPY3RldCBTdHJlYW0gdG8gSW50ZWdlci4gXCJzcGVjXCIgaW1wbGVtZW50YXRpb24gb2Ygb3MyaXAgaXMgMi41eCBzbG93ZXIgdnMgYnl0ZXNUb051bWJlckJFLlxuY29uc3Qgb3MyaXAgPSB1dGlsc190c18xLmJ5dGVzVG9OdW1iZXJCRTtcbi8vIEludGVnZXIgdG8gT2N0ZXQgU3RyZWFtIChudW1iZXJUb0J5dGVzQkUpXG5mdW5jdGlvbiBpMm9zcCh2YWx1ZSwgbGVuZ3RoKSB7XG4gICAgYW51bSh2YWx1ZSk7XG4gICAgYW51bShsZW5ndGgpO1xuICAgIGlmICh2YWx1ZSA8IDAgfHwgdmFsdWUgPj0gMSA8PCAoOCAqIGxlbmd0aCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBJMk9TUCBpbnB1dDogJyArIHZhbHVlKTtcbiAgICBjb25zdCByZXMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoIH0pLmZpbGwoMCk7XG4gICAgZm9yIChsZXQgaSA9IGxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHJlc1tpXSA9IHZhbHVlICYgMHhmZjtcbiAgICAgICAgdmFsdWUgPj4+PSA4O1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkocmVzKTtcbn1cbmZ1bmN0aW9uIHN0cnhvcihhLCBiKSB7XG4gICAgY29uc3QgYXJyID0gbmV3IFVpbnQ4QXJyYXkoYS5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICBhcnJbaV0gPSBhW2ldIF4gYltpXTtcbiAgICB9XG4gICAgcmV0dXJuIGFycjtcbn1cbmZ1bmN0aW9uIGFudW0oaXRlbSkge1xuICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIoaXRlbSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbnVtYmVyIGV4cGVjdGVkJyk7XG59XG4vKipcbiAqIFByb2R1Y2VzIGEgdW5pZm9ybWx5IHJhbmRvbSBieXRlIHN0cmluZyB1c2luZyBhIGNyeXB0b2dyYXBoaWMgaGFzaCBmdW5jdGlvbiBIIHRoYXQgb3V0cHV0cyBiIGJpdHMuXG4gKiBbUkZDIDkzODAgNS4zLjFdKGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tNS4zLjEpLlxuICovXG5mdW5jdGlvbiBleHBhbmRfbWVzc2FnZV94bWQobXNnLCBEU1QsIGxlbkluQnl0ZXMsIEgpIHtcbiAgICAoMCwgdXRpbHNfdHNfMS5hYnl0ZXMpKG1zZyk7XG4gICAgKDAsIHV0aWxzX3RzXzEuYWJ5dGVzKShEU1QpO1xuICAgIGFudW0obGVuSW5CeXRlcyk7XG4gICAgLy8gaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi01LjMuM1xuICAgIGlmIChEU1QubGVuZ3RoID4gMjU1KVxuICAgICAgICBEU1QgPSBIKCgwLCB1dGlsc190c18xLmNvbmNhdEJ5dGVzKSgoMCwgdXRpbHNfdHNfMS51dGY4VG9CeXRlcykoJ0gyQy1PVkVSU0laRS1EU1QtJyksIERTVCkpO1xuICAgIGNvbnN0IHsgb3V0cHV0TGVuOiBiX2luX2J5dGVzLCBibG9ja0xlbjogcl9pbl9ieXRlcyB9ID0gSDtcbiAgICBjb25zdCBlbGwgPSBNYXRoLmNlaWwobGVuSW5CeXRlcyAvIGJfaW5fYnl0ZXMpO1xuICAgIGlmIChsZW5JbkJ5dGVzID4gNjU1MzUgfHwgZWxsID4gMjU1KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGFuZF9tZXNzYWdlX3htZDogaW52YWxpZCBsZW5JbkJ5dGVzJyk7XG4gICAgY29uc3QgRFNUX3ByaW1lID0gKDAsIHV0aWxzX3RzXzEuY29uY2F0Qnl0ZXMpKERTVCwgaTJvc3AoRFNULmxlbmd0aCwgMSkpO1xuICAgIGNvbnN0IFpfcGFkID0gaTJvc3AoMCwgcl9pbl9ieXRlcyk7XG4gICAgY29uc3QgbF9pX2Jfc3RyID0gaTJvc3AobGVuSW5CeXRlcywgMik7IC8vIGxlbl9pbl9ieXRlc19zdHJcbiAgICBjb25zdCBiID0gbmV3IEFycmF5KGVsbCk7XG4gICAgY29uc3QgYl8wID0gSCgoMCwgdXRpbHNfdHNfMS5jb25jYXRCeXRlcykoWl9wYWQsIG1zZywgbF9pX2Jfc3RyLCBpMm9zcCgwLCAxKSwgRFNUX3ByaW1lKSk7XG4gICAgYlswXSA9IEgoKDAsIHV0aWxzX3RzXzEuY29uY2F0Qnl0ZXMpKGJfMCwgaTJvc3AoMSwgMSksIERTVF9wcmltZSkpO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDw9IGVsbDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSBbc3RyeG9yKGJfMCwgYltpIC0gMV0pLCBpMm9zcChpICsgMSwgMSksIERTVF9wcmltZV07XG4gICAgICAgIGJbaV0gPSBIKCgwLCB1dGlsc190c18xLmNvbmNhdEJ5dGVzKSguLi5hcmdzKSk7XG4gICAgfVxuICAgIGNvbnN0IHBzZXVkb19yYW5kb21fYnl0ZXMgPSAoMCwgdXRpbHNfdHNfMS5jb25jYXRCeXRlcykoLi4uYik7XG4gICAgcmV0dXJuIHBzZXVkb19yYW5kb21fYnl0ZXMuc2xpY2UoMCwgbGVuSW5CeXRlcyk7XG59XG4vKipcbiAqIFByb2R1Y2VzIGEgdW5pZm9ybWx5IHJhbmRvbSBieXRlIHN0cmluZyB1c2luZyBhbiBleHRlbmRhYmxlLW91dHB1dCBmdW5jdGlvbiAoWE9GKSBILlxuICogMS4gVGhlIGNvbGxpc2lvbiByZXNpc3RhbmNlIG9mIEggTVVTVCBiZSBhdCBsZWFzdCBrIGJpdHMuXG4gKiAyLiBIIE1VU1QgYmUgYW4gWE9GIHRoYXQgaGFzIGJlZW4gcHJvdmVkIGluZGlmZmVyZW50aWFibGUgZnJvbVxuICogICAgYSByYW5kb20gb3JhY2xlIHVuZGVyIGEgcmVhc29uYWJsZSBjcnlwdG9ncmFwaGljIGFzc3VtcHRpb24uXG4gKiBbUkZDIDkzODAgNS4zLjJdKGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tNS4zLjIpLlxuICovXG5mdW5jdGlvbiBleHBhbmRfbWVzc2FnZV94b2YobXNnLCBEU1QsIGxlbkluQnl0ZXMsIGssIEgpIHtcbiAgICAoMCwgdXRpbHNfdHNfMS5hYnl0ZXMpKG1zZyk7XG4gICAgKDAsIHV0aWxzX3RzXzEuYWJ5dGVzKShEU1QpO1xuICAgIGFudW0obGVuSW5CeXRlcyk7XG4gICAgLy8gaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi01LjMuM1xuICAgIC8vIERTVCA9IEgoJ0gyQy1PVkVSU0laRS1EU1QtJyB8fCBhX3ZlcnlfbG9uZ19EU1QsIE1hdGguY2VpbCgobGVuSW5CeXRlcyAqIGspIC8gOCkpO1xuICAgIGlmIChEU1QubGVuZ3RoID4gMjU1KSB7XG4gICAgICAgIGNvbnN0IGRrTGVuID0gTWF0aC5jZWlsKCgyICogaykgLyA4KTtcbiAgICAgICAgRFNUID0gSC5jcmVhdGUoeyBka0xlbiB9KS51cGRhdGUoKDAsIHV0aWxzX3RzXzEudXRmOFRvQnl0ZXMpKCdIMkMtT1ZFUlNJWkUtRFNULScpKS51cGRhdGUoRFNUKS5kaWdlc3QoKTtcbiAgICB9XG4gICAgaWYgKGxlbkluQnl0ZXMgPiA2NTUzNSB8fCBEU1QubGVuZ3RoID4gMjU1KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGFuZF9tZXNzYWdlX3hvZjogaW52YWxpZCBsZW5JbkJ5dGVzJyk7XG4gICAgcmV0dXJuIChILmNyZWF0ZSh7IGRrTGVuOiBsZW5JbkJ5dGVzIH0pXG4gICAgICAgIC51cGRhdGUobXNnKVxuICAgICAgICAudXBkYXRlKGkyb3NwKGxlbkluQnl0ZXMsIDIpKVxuICAgICAgICAvLyAyLiBEU1RfcHJpbWUgPSBEU1QgfHwgSTJPU1AobGVuKERTVCksIDEpXG4gICAgICAgIC51cGRhdGUoRFNUKVxuICAgICAgICAudXBkYXRlKGkyb3NwKERTVC5sZW5ndGgsIDEpKVxuICAgICAgICAuZGlnZXN0KCkpO1xufVxuLyoqXG4gKiBIYXNoZXMgYXJiaXRyYXJ5LWxlbmd0aCBieXRlIHN0cmluZ3MgdG8gYSBsaXN0IG9mIG9uZSBvciBtb3JlIGVsZW1lbnRzIG9mIGEgZmluaXRlIGZpZWxkIEYuXG4gKiBbUkZDIDkzODAgNS4yXShodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTUuMikuXG4gKiBAcGFyYW0gbXNnIGEgYnl0ZSBzdHJpbmcgY29udGFpbmluZyB0aGUgbWVzc2FnZSB0byBoYXNoXG4gKiBAcGFyYW0gY291bnQgdGhlIG51bWJlciBvZiBlbGVtZW50cyBvZiBGIHRvIG91dHB1dFxuICogQHBhcmFtIG9wdGlvbnMgYHtEU1Q6IHN0cmluZywgcDogYmlnaW50LCBtOiBudW1iZXIsIGs6IG51bWJlciwgZXhwYW5kOiAneG1kJyB8ICd4b2YnLCBoYXNoOiBIfWAsIHNlZSBhYm92ZVxuICogQHJldHVybnMgW3VfMCwgLi4uLCB1Xyhjb3VudCAtIDEpXSwgYSBsaXN0IG9mIGZpZWxkIGVsZW1lbnRzLlxuICovXG5mdW5jdGlvbiBoYXNoX3RvX2ZpZWxkKG1zZywgY291bnQsIG9wdGlvbnMpIHtcbiAgICAoMCwgdXRpbHNfdHNfMS52YWxpZGF0ZU9iamVjdCkob3B0aW9ucywge1xuICAgICAgICBEU1Q6ICdzdHJpbmdPclVpbnQ4QXJyYXknLFxuICAgICAgICBwOiAnYmlnaW50JyxcbiAgICAgICAgbTogJ2lzU2FmZUludGVnZXInLFxuICAgICAgICBrOiAnaXNTYWZlSW50ZWdlcicsXG4gICAgICAgIGhhc2g6ICdoYXNoJyxcbiAgICB9KTtcbiAgICBjb25zdCB7IHAsIGssIG0sIGhhc2gsIGV4cGFuZCwgRFNUOiBfRFNUIH0gPSBvcHRpb25zO1xuICAgICgwLCB1dGlsc190c18xLmFieXRlcykobXNnKTtcbiAgICBhbnVtKGNvdW50KTtcbiAgICBjb25zdCBEU1QgPSB0eXBlb2YgX0RTVCA9PT0gJ3N0cmluZycgPyAoMCwgdXRpbHNfdHNfMS51dGY4VG9CeXRlcykoX0RTVCkgOiBfRFNUO1xuICAgIGNvbnN0IGxvZzJwID0gcC50b1N0cmluZygyKS5sZW5ndGg7XG4gICAgY29uc3QgTCA9IE1hdGguY2VpbCgobG9nMnAgKyBrKSAvIDgpOyAvLyBzZWN0aW9uIDUuMSBvZiBpZXRmIGRyYWZ0IGxpbmsgYWJvdmVcbiAgICBjb25zdCBsZW5faW5fYnl0ZXMgPSBjb3VudCAqIG0gKiBMO1xuICAgIGxldCBwcmI7IC8vIHBzZXVkb19yYW5kb21fYnl0ZXNcbiAgICBpZiAoZXhwYW5kID09PSAneG1kJykge1xuICAgICAgICBwcmIgPSBleHBhbmRfbWVzc2FnZV94bWQobXNnLCBEU1QsIGxlbl9pbl9ieXRlcywgaGFzaCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGV4cGFuZCA9PT0gJ3hvZicpIHtcbiAgICAgICAgcHJiID0gZXhwYW5kX21lc3NhZ2VfeG9mKG1zZywgRFNULCBsZW5faW5fYnl0ZXMsIGssIGhhc2gpO1xuICAgIH1cbiAgICBlbHNlIGlmIChleHBhbmQgPT09ICdfaW50ZXJuYWxfcGFzcycpIHtcbiAgICAgICAgLy8gZm9yIGludGVybmFsIHRlc3RzIG9ubHlcbiAgICAgICAgcHJiID0gbXNnO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBhbmQgbXVzdCBiZSBcInhtZFwiIG9yIFwieG9mXCInKTtcbiAgICB9XG4gICAgY29uc3QgdSA9IG5ldyBBcnJheShjb3VudCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGUgPSBuZXcgQXJyYXkobSk7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbTsgaisrKSB7XG4gICAgICAgICAgICBjb25zdCBlbG1fb2Zmc2V0ID0gTCAqIChqICsgaSAqIG0pO1xuICAgICAgICAgICAgY29uc3QgdHYgPSBwcmIuc3ViYXJyYXkoZWxtX29mZnNldCwgZWxtX29mZnNldCArIEwpO1xuICAgICAgICAgICAgZVtqXSA9ICgwLCBtb2R1bGFyX3RzXzEubW9kKShvczJpcCh0diksIHApO1xuICAgICAgICB9XG4gICAgICAgIHVbaV0gPSBlO1xuICAgIH1cbiAgICByZXR1cm4gdTtcbn1cbmZ1bmN0aW9uIGlzb2dlbnlNYXAoZmllbGQsIG1hcCkge1xuICAgIC8vIE1ha2Ugc2FtZSBvcmRlciBhcyBpbiBzcGVjXG4gICAgY29uc3QgY29lZmYgPSBtYXAubWFwKChpKSA9PiBBcnJheS5mcm9tKGkpLnJldmVyc2UoKSk7XG4gICAgcmV0dXJuICh4LCB5KSA9PiB7XG4gICAgICAgIGNvbnN0IFt4biwgeGQsIHluLCB5ZF0gPSBjb2VmZi5tYXAoKHZhbCkgPT4gdmFsLnJlZHVjZSgoYWNjLCBpKSA9PiBmaWVsZC5hZGQoZmllbGQubXVsKGFjYywgeCksIGkpKSk7XG4gICAgICAgIC8vIDYuNi4zXG4gICAgICAgIC8vIEV4Y2VwdGlvbmFsIGNhc2VzIG9mIGlzb19tYXAgYXJlIGlucHV0cyB0aGF0IGNhdXNlIHRoZSBkZW5vbWluYXRvciBvZlxuICAgICAgICAvLyBlaXRoZXIgcmF0aW9uYWwgZnVuY3Rpb24gdG8gZXZhbHVhdGUgdG8gemVybzsgc3VjaCBjYXNlcyBNVVNUIHJldHVyblxuICAgICAgICAvLyB0aGUgaWRlbnRpdHkgcG9pbnQgb24gRS5cbiAgICAgICAgY29uc3QgW3hkX2ludiwgeWRfaW52XSA9ICgwLCBtb2R1bGFyX3RzXzEuRnBJbnZlcnRCYXRjaCkoZmllbGQsIFt4ZCwgeWRdLCB0cnVlKTtcbiAgICAgICAgeCA9IGZpZWxkLm11bCh4biwgeGRfaW52KTsgLy8geE51bSAvIHhEZW5cbiAgICAgICAgeSA9IGZpZWxkLm11bCh5LCBmaWVsZC5tdWwoeW4sIHlkX2ludikpOyAvLyB5ICogKHlOdW0gLyB5RGV2KVxuICAgICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgfTtcbn1cbi8qKiBDcmVhdGVzIGhhc2gtdG8tY3VydmUgbWV0aG9kcyBmcm9tIEVDIFBvaW50IGFuZCBtYXBUb0N1cnZlIGZ1bmN0aW9uLiAqL1xuZnVuY3Rpb24gY3JlYXRlSGFzaGVyKFBvaW50LCBtYXBUb0N1cnZlLCBkZWZhdWx0cykge1xuICAgIGlmICh0eXBlb2YgbWFwVG9DdXJ2ZSAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtYXBUb0N1cnZlKCkgbXVzdCBiZSBkZWZpbmVkJyk7XG4gICAgZnVuY3Rpb24gbWFwKG51bSkge1xuICAgICAgICByZXR1cm4gUG9pbnQuZnJvbUFmZmluZShtYXBUb0N1cnZlKG51bSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjbGVhcihpbml0aWFsKSB7XG4gICAgICAgIGNvbnN0IFAgPSBpbml0aWFsLmNsZWFyQ29mYWN0b3IoKTtcbiAgICAgICAgaWYgKFAuZXF1YWxzKFBvaW50LlpFUk8pKVxuICAgICAgICAgICAgcmV0dXJuIFBvaW50LlpFUk87IC8vIHplcm8gd2lsbCB0aHJvdyBpbiBhc3NlcnRcbiAgICAgICAgUC5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICByZXR1cm4gUDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGVmYXVsdHMsXG4gICAgICAgIC8vIEVuY29kZXMgYnl0ZSBzdHJpbmcgdG8gZWxsaXB0aWMgY3VydmUuXG4gICAgICAgIC8vIGhhc2hfdG9fY3VydmUgZnJvbSBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTNcbiAgICAgICAgaGFzaFRvQ3VydmUobXNnLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCB1ID0gaGFzaF90b19maWVsZChtc2csIDIsIHsgLi4uZGVmYXVsdHMsIERTVDogZGVmYXVsdHMuRFNULCAuLi5vcHRpb25zIH0pO1xuICAgICAgICAgICAgY29uc3QgdTAgPSBtYXAodVswXSk7XG4gICAgICAgICAgICBjb25zdCB1MSA9IG1hcCh1WzFdKTtcbiAgICAgICAgICAgIHJldHVybiBjbGVhcih1MC5hZGQodTEpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gRW5jb2RlcyBieXRlIHN0cmluZyB0byBlbGxpcHRpYyBjdXJ2ZS5cbiAgICAgICAgLy8gZW5jb2RlX3RvX2N1cnZlIGZyb20gaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi0zXG4gICAgICAgIGVuY29kZVRvQ3VydmUobXNnLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCB1ID0gaGFzaF90b19maWVsZChtc2csIDEsIHsgLi4uZGVmYXVsdHMsIERTVDogZGVmYXVsdHMuZW5jb2RlRFNULCAuLi5vcHRpb25zIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGNsZWFyKG1hcCh1WzBdKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIFNhbWUgYXMgZW5jb2RlVG9DdXJ2ZSwgYnV0IHdpdGhvdXQgaGFzaFxuICAgICAgICBtYXBUb0N1cnZlKHNjYWxhcnMpIHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShzY2FsYXJzKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGVjdGVkIGFycmF5IG9mIGJpZ2ludHMnKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaSBvZiBzY2FsYXJzKVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaSAhPT0gJ2JpZ2ludCcpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZXhwZWN0ZWQgYXJyYXkgb2YgYmlnaW50cycpO1xuICAgICAgICAgICAgcmV0dXJuIGNsZWFyKG1hcChzY2FsYXJzKSk7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhhc2gtdG8tY3VydmUuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZXhwYW5kX21lc3NhZ2VfeG1kIiwiZXhwYW5kX21lc3NhZ2VfeG9mIiwiaGFzaF90b19maWVsZCIsImlzb2dlbnlNYXAiLCJjcmVhdGVIYXNoZXIiLCJtb2R1bGFyX3RzXzEiLCJyZXF1aXJlIiwidXRpbHNfdHNfMSIsIm9zMmlwIiwiYnl0ZXNUb051bWJlckJFIiwiaTJvc3AiLCJsZW5ndGgiLCJhbnVtIiwiRXJyb3IiLCJyZXMiLCJBcnJheSIsImZyb20iLCJmaWxsIiwiaSIsIlVpbnQ4QXJyYXkiLCJzdHJ4b3IiLCJhIiwiYiIsImFyciIsIml0ZW0iLCJOdW1iZXIiLCJpc1NhZmVJbnRlZ2VyIiwibXNnIiwiRFNUIiwibGVuSW5CeXRlcyIsIkgiLCJhYnl0ZXMiLCJjb25jYXRCeXRlcyIsInV0ZjhUb0J5dGVzIiwib3V0cHV0TGVuIiwiYl9pbl9ieXRlcyIsImJsb2NrTGVuIiwicl9pbl9ieXRlcyIsImVsbCIsIk1hdGgiLCJjZWlsIiwiRFNUX3ByaW1lIiwiWl9wYWQiLCJsX2lfYl9zdHIiLCJiXzAiLCJhcmdzIiwicHNldWRvX3JhbmRvbV9ieXRlcyIsInNsaWNlIiwiayIsImRrTGVuIiwiY3JlYXRlIiwidXBkYXRlIiwiZGlnZXN0IiwiY291bnQiLCJvcHRpb25zIiwidmFsaWRhdGVPYmplY3QiLCJwIiwibSIsImhhc2giLCJleHBhbmQiLCJfRFNUIiwibG9nMnAiLCJ0b1N0cmluZyIsIkwiLCJsZW5faW5fYnl0ZXMiLCJwcmIiLCJ1IiwiZSIsImoiLCJlbG1fb2Zmc2V0IiwidHYiLCJzdWJhcnJheSIsIm1vZCIsImZpZWxkIiwibWFwIiwiY29lZmYiLCJyZXZlcnNlIiwieCIsInkiLCJ4biIsInhkIiwieW4iLCJ5ZCIsInZhbCIsInJlZHVjZSIsImFjYyIsImFkZCIsIm11bCIsInhkX2ludiIsInlkX2ludiIsIkZwSW52ZXJ0QmF0Y2giLCJQb2ludCIsIm1hcFRvQ3VydmUiLCJkZWZhdWx0cyIsIm51bSIsImZyb21BZmZpbmUiLCJjbGVhciIsImluaXRpYWwiLCJQIiwiY2xlYXJDb2ZhY3RvciIsImVxdWFscyIsIlpFUk8iLCJhc3NlcnRWYWxpZGl0eSIsImhhc2hUb0N1cnZlIiwidTAiLCJ1MSIsImVuY29kZVRvQ3VydmUiLCJlbmNvZGVEU1QiLCJzY2FsYXJzIiwiaXNBcnJheSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@noble/curves/abstract/hash-to-curve.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@noble/curves/abstract/modular.js":
/*!********************************************************!*\
  !*** ./node_modules/@noble/curves/abstract/modular.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.isNegativeLE = void 0;\nexports.mod = mod;\nexports.pow = pow;\nexports.pow2 = pow2;\nexports.invert = invert;\nexports.tonelliShanks = tonelliShanks;\nexports.FpSqrt = FpSqrt;\nexports.validateField = validateField;\nexports.FpPow = FpPow;\nexports.FpInvertBatch = FpInvertBatch;\nexports.FpDiv = FpDiv;\nexports.FpLegendre = FpLegendre;\nexports.FpIsSquare = FpIsSquare;\nexports.nLength = nLength;\nexports.Field = Field;\nexports.FpSqrtOdd = FpSqrtOdd;\nexports.FpSqrtEven = FpSqrtEven;\nexports.hashToPrivateScalar = hashToPrivateScalar;\nexports.getFieldBytesLength = getFieldBytesLength;\nexports.getMinHashLength = getMinHashLength;\nexports.mapHashToField = mapHashToField;\n/**\n * Utils for modular division and finite fields.\n * A finite field over 11 is integer number operations `mod 11`.\n * There is no division: it is replaced by modular multiplicative inverse.\n * @module\n */ /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const utils_1 = __webpack_require__(/*! @noble/hashes/utils */ \"(rsc)/./node_modules/@noble/hashes/utils.js\");\nconst utils_ts_1 = __webpack_require__(/*! ./utils.js */ \"(rsc)/./node_modules/@noble/curves/abstract/utils.js\");\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = /* @__PURE__ */ BigInt(2), _3n = /* @__PURE__ */ BigInt(3);\n// prettier-ignore\nconst _4n = /* @__PURE__ */ BigInt(4), _5n = /* @__PURE__ */ BigInt(5), _8n = /* @__PURE__ */ BigInt(8);\n// Calculates a modulo b\nfunction mod(a, b) {\n    const result = a % b;\n    return result >= _0n ? result : b + result;\n}\n/**\n * Efficiently raise num to power and do modular division.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n * TODO: remove.\n * @example\n * pow(2n, 6n, 11n) // 64n % 11n == 9n\n */ function pow(num, power, modulo) {\n    return FpPow(Field(modulo), num, power);\n}\n/** Does `x^(2^power)` mod p. `pow2(30, 4)` == `30^(2^4)` */ function pow2(x, power, modulo) {\n    let res = x;\n    while(power-- > _0n){\n        res *= res;\n        res %= modulo;\n    }\n    return res;\n}\n/**\n * Inverses number over modulo.\n * Implemented using [Euclidean GCD](https://brilliant.org/wiki/extended-euclidean-algorithm/).\n */ function invert(number, modulo) {\n    if (number === _0n) throw new Error(\"invert: expected non-zero number\");\n    if (modulo <= _0n) throw new Error(\"invert: expected positive modulus, got \" + modulo);\n    // Fermat's little theorem \"CT-like\" version inv(n) = n^(m-2) mod m is 30x slower.\n    let a = mod(number, modulo);\n    let b = modulo;\n    // prettier-ignore\n    let x = _0n, y = _1n, u = _1n, v = _0n;\n    while(a !== _0n){\n        // JIT applies optimization if those two lines follow each other\n        const q = b / a;\n        const r = b % a;\n        const m = x - u * q;\n        const n = y - v * q;\n        // prettier-ignore\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    const gcd = b;\n    if (gcd !== _1n) throw new Error(\"invert: does not exist\");\n    return mod(x, modulo);\n}\n// Not all roots are possible! Example which will throw:\n// const NUM =\n// n = 72057594037927816n;\n// Fp = Field(BigInt('0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab'));\nfunction sqrt3mod4(Fp, n) {\n    const p1div4 = (Fp.ORDER + _1n) / _4n;\n    const root = Fp.pow(n, p1div4);\n    // Throw if root^2 != n\n    if (!Fp.eql(Fp.sqr(root), n)) throw new Error(\"Cannot find square root\");\n    return root;\n}\nfunction sqrt5mod8(Fp, n) {\n    const p5div8 = (Fp.ORDER - _5n) / _8n;\n    const n2 = Fp.mul(n, _2n);\n    const v = Fp.pow(n2, p5div8);\n    const nv = Fp.mul(n, v);\n    const i = Fp.mul(Fp.mul(nv, _2n), v);\n    const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));\n    if (!Fp.eql(Fp.sqr(root), n)) throw new Error(\"Cannot find square root\");\n    return root;\n}\n// TODO: Commented-out for now. Provide test vectors.\n// Tonelli is too slow for extension fields Fp2.\n// That means we can't use sqrt (c1, c2...) even for initialization constants.\n// if (P % _16n === _9n) return sqrt9mod16;\n// // prettier-ignore\n// function sqrt9mod16<T>(Fp: IField<T>, n: T, p7div16?: bigint) {\n//   if (p7div16 === undefined) p7div16 = (Fp.ORDER + BigInt(7)) / _16n;\n//   const c1 = Fp.sqrt(Fp.neg(Fp.ONE)); //  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F\n//   const c2 = Fp.sqrt(c1);             //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F\n//   const c3 = Fp.sqrt(Fp.neg(c1));     //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F\n//   const c4 = p7div16;                 //  4. c4 = (q + 7) / 16        # Integer arithmetic\n//   let tv1 = Fp.pow(n, c4);            //  1. tv1 = x^c4\n//   let tv2 = Fp.mul(c1, tv1);          //  2. tv2 = c1 * tv1\n//   const tv3 = Fp.mul(c2, tv1);        //  3. tv3 = c2 * tv1\n//   let tv4 = Fp.mul(c3, tv1);          //  4. tv4 = c3 * tv1\n//   const e1 = Fp.eql(Fp.sqr(tv2), n);  //  5.  e1 = (tv2^2) == x\n//   const e2 = Fp.eql(Fp.sqr(tv3), n);  //  6.  e2 = (tv3^2) == x\n//   tv1 = Fp.cmov(tv1, tv2, e1); //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x\n//   tv2 = Fp.cmov(tv4, tv3, e2); //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x\n//   const e3 = Fp.eql(Fp.sqr(tv2), n);  //  9.  e3 = (tv2^2) == x\n//   return Fp.cmov(tv1, tv2, e3); // 10.  z = CMOV(tv1, tv2, e3) # Select the sqrt from tv1 and tv2\n// }\n/**\n * Tonelli-Shanks square root search algorithm.\n * 1. https://eprint.iacr.org/2012/685.pdf (page 12)\n * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks\n * @param P field order\n * @returns function that takes field Fp (created from P) and number n\n */ function tonelliShanks(P) {\n    // Initialization (precomputation).\n    if (P < BigInt(3)) throw new Error(\"sqrt is not defined for small field\");\n    // Factor P - 1 = Q * 2^S, where Q is odd\n    let Q = P - _1n;\n    let S = 0;\n    while(Q % _2n === _0n){\n        Q /= _2n;\n        S++;\n    }\n    // Find the first quadratic non-residue Z >= 2\n    let Z = _2n;\n    const _Fp = Field(P);\n    while(FpLegendre(_Fp, Z) === 1){\n        // Basic primality test for P. After x iterations, chance of\n        // not finding quadratic non-residue is 2^x, so 2^1000.\n        if (Z++ > 1000) throw new Error(\"Cannot find square root: probably non-prime P\");\n    }\n    // Fast-path; usually done before Z, but we do \"primality test\".\n    if (S === 1) return sqrt3mod4;\n    // Slow-path\n    // TODO: test on Fp2 and others\n    let cc = _Fp.pow(Z, Q); // c = z^Q\n    const Q1div2 = (Q + _1n) / _2n;\n    return function tonelliSlow(Fp, n) {\n        if (Fp.is0(n)) return n;\n        // Check if n is a quadratic residue using Legendre symbol\n        if (FpLegendre(Fp, n) !== 1) throw new Error(\"Cannot find square root\");\n        // Initialize variables for the main loop\n        let M = S;\n        let c = Fp.mul(Fp.ONE, cc); // c = z^Q, move cc from field _Fp into field Fp\n        let t = Fp.pow(n, Q); // t = n^Q, first guess at the fudge factor\n        let R = Fp.pow(n, Q1div2); // R = n^((Q+1)/2), first guess at the square root\n        // Main loop\n        // while t != 1\n        while(!Fp.eql(t, Fp.ONE)){\n            if (Fp.is0(t)) return Fp.ZERO; // if t=0 return R=0\n            let i = 1;\n            // Find the smallest i >= 1 such that t^(2^i) ‚â° 1 (mod P)\n            let t_tmp = Fp.sqr(t); // t^(2^1)\n            while(!Fp.eql(t_tmp, Fp.ONE)){\n                i++;\n                t_tmp = Fp.sqr(t_tmp); // t^(2^2)...\n                if (i === M) throw new Error(\"Cannot find square root\");\n            }\n            // Calculate the exponent for b: 2^(M - i - 1)\n            const exponent = _1n << BigInt(M - i - 1); // bigint is important\n            const b = Fp.pow(c, exponent); // b = 2^(M - i - 1)\n            // Update variables\n            M = i;\n            c = Fp.sqr(b); // c = b^2\n            t = Fp.mul(t, c); // t = (t * b^2)\n            R = Fp.mul(R, b); // R = R*b\n        }\n        return R;\n    };\n}\n/**\n * Square root for a finite field. Will try optimized versions first:\n *\n * 1. P ‚â° 3 (mod 4)\n * 2. P ‚â° 5 (mod 8)\n * 3. Tonelli-Shanks algorithm\n *\n * Different algorithms can give different roots, it is up to user to decide which one they want.\n * For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).\n */ function FpSqrt(P) {\n    // P ‚â° 3 (mod 4) => ‚àön = n^((P+1)/4)\n    if (P % _4n === _3n) return sqrt3mod4;\n    // P ‚â° 5 (mod 8) => Atkin algorithm, page 10 of https://eprint.iacr.org/2012/685.pdf\n    if (P % _8n === _5n) return sqrt5mod8;\n    // P ‚â° 9 (mod 16) not implemented, see above\n    // Tonelli-Shanks algorithm\n    return tonelliShanks(P);\n}\n// Little-endian check for first LE bit (last BE bit);\nconst isNegativeLE = (num, modulo)=>(mod(num, modulo) & _1n) === _1n;\nexports.isNegativeLE = isNegativeLE;\n// prettier-ignore\nconst FIELD_FIELDS = [\n    \"create\",\n    \"isValid\",\n    \"is0\",\n    \"neg\",\n    \"inv\",\n    \"sqrt\",\n    \"sqr\",\n    \"eql\",\n    \"add\",\n    \"sub\",\n    \"mul\",\n    \"pow\",\n    \"div\",\n    \"addN\",\n    \"subN\",\n    \"mulN\",\n    \"sqrN\"\n];\nfunction validateField(field) {\n    const initial = {\n        ORDER: \"bigint\",\n        MASK: \"bigint\",\n        BYTES: \"isSafeInteger\",\n        BITS: \"isSafeInteger\"\n    };\n    const opts = FIELD_FIELDS.reduce((map, val)=>{\n        map[val] = \"function\";\n        return map;\n    }, initial);\n    return (0, utils_ts_1.validateObject)(field, opts);\n}\n// Generic field functions\n/**\n * Same as `pow` but for Fp: non-constant-time.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n */ function FpPow(Fp, num, power) {\n    if (power < _0n) throw new Error(\"invalid exponent, negatives unsupported\");\n    if (power === _0n) return Fp.ONE;\n    if (power === _1n) return num;\n    let p = Fp.ONE;\n    let d = num;\n    while(power > _0n){\n        if (power & _1n) p = Fp.mul(p, d);\n        d = Fp.sqr(d);\n        power >>= _1n;\n    }\n    return p;\n}\n/**\n * Efficiently invert an array of Field elements.\n * Exception-free. Will return `undefined` for 0 elements.\n * @param passZero map 0 to 0 (instead of undefined)\n */ function FpInvertBatch(Fp, nums, passZero = false) {\n    const inverted = new Array(nums.length).fill(passZero ? Fp.ZERO : undefined);\n    // Walk from first to last, multiply them by each other MOD p\n    const multipliedAcc = nums.reduce((acc, num, i)=>{\n        if (Fp.is0(num)) return acc;\n        inverted[i] = acc;\n        return Fp.mul(acc, num);\n    }, Fp.ONE);\n    // Invert last element\n    const invertedAcc = Fp.inv(multipliedAcc);\n    // Walk from last to first, multiply them by inverted each other MOD p\n    nums.reduceRight((acc, num, i)=>{\n        if (Fp.is0(num)) return acc;\n        inverted[i] = Fp.mul(acc, inverted[i]);\n        return Fp.mul(acc, num);\n    }, invertedAcc);\n    return inverted;\n}\n// TODO: remove\nfunction FpDiv(Fp, lhs, rhs) {\n    return Fp.mul(lhs, typeof rhs === \"bigint\" ? invert(rhs, Fp.ORDER) : Fp.inv(rhs));\n}\n/**\n * Legendre symbol.\n * Legendre constant is used to calculate Legendre symbol (a | p)\n * which denotes the value of a^((p-1)/2) (mod p).\n *\n * * (a | p) ‚â° 1    if a is a square (mod p), quadratic residue\n * * (a | p) ‚â° -1   if a is not a square (mod p), quadratic non residue\n * * (a | p) ‚â° 0    if a ‚â° 0 (mod p)\n */ function FpLegendre(Fp, n) {\n    // We can use 3rd argument as optional cache of this value\n    // but seems unneeded for now. The operation is very fast.\n    const p1mod2 = (Fp.ORDER - _1n) / _2n;\n    const powered = Fp.pow(n, p1mod2);\n    const yes = Fp.eql(powered, Fp.ONE);\n    const zero = Fp.eql(powered, Fp.ZERO);\n    const no = Fp.eql(powered, Fp.neg(Fp.ONE));\n    if (!yes && !zero && !no) throw new Error(\"invalid Legendre symbol result\");\n    return yes ? 1 : zero ? 0 : -1;\n}\n// This function returns True whenever the value x is a square in the field F.\nfunction FpIsSquare(Fp, n) {\n    const l = FpLegendre(Fp, n);\n    return l === 1;\n}\n// CURVE.n lengths\nfunction nLength(n, nBitLength) {\n    // Bit size, byte size of CURVE.n\n    if (nBitLength !== undefined) (0, utils_1.anumber)(nBitLength);\n    const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;\n    const nByteLength = Math.ceil(_nBitLength / 8);\n    return {\n        nBitLength: _nBitLength,\n        nByteLength\n    };\n}\n/**\n * Initializes a finite field over prime.\n * Major performance optimizations:\n * * a) denormalized operations like mulN instead of mul\n * * b) same object shape: never add or remove keys\n * * c) Object.freeze\n * Fragile: always run a benchmark on a change.\n * Security note: operations don't check 'isValid' for all elements for performance reasons,\n * it is caller responsibility to check this.\n * This is low-level code, please make sure you know what you're doing.\n * @param ORDER prime positive bigint\n * @param bitLen how many bits the field consumes\n * @param isLE (def: false) if encoding / decoding should be in little-endian\n * @param redef optional faster redefinitions of sqrt and other methods\n */ function Field(ORDER, bitLen, isLE = false, redef = {}) {\n    if (ORDER <= _0n) throw new Error(\"invalid field: expected ORDER > 0, got \" + ORDER);\n    const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);\n    if (BYTES > 2048) throw new Error(\"invalid field: expected ORDER of <= 2048 bytes\");\n    let sqrtP; // cached sqrtP\n    const f = Object.freeze({\n        ORDER,\n        isLE,\n        BITS,\n        BYTES,\n        MASK: (0, utils_ts_1.bitMask)(BITS),\n        ZERO: _0n,\n        ONE: _1n,\n        create: (num)=>mod(num, ORDER),\n        isValid: (num)=>{\n            if (typeof num !== \"bigint\") throw new Error(\"invalid field element: expected bigint, got \" + typeof num);\n            return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible\n        },\n        is0: (num)=>num === _0n,\n        isOdd: (num)=>(num & _1n) === _1n,\n        neg: (num)=>mod(-num, ORDER),\n        eql: (lhs, rhs)=>lhs === rhs,\n        sqr: (num)=>mod(num * num, ORDER),\n        add: (lhs, rhs)=>mod(lhs + rhs, ORDER),\n        sub: (lhs, rhs)=>mod(lhs - rhs, ORDER),\n        mul: (lhs, rhs)=>mod(lhs * rhs, ORDER),\n        pow: (num, power)=>FpPow(f, num, power),\n        div: (lhs, rhs)=>mod(lhs * invert(rhs, ORDER), ORDER),\n        // Same as above, but doesn't normalize\n        sqrN: (num)=>num * num,\n        addN: (lhs, rhs)=>lhs + rhs,\n        subN: (lhs, rhs)=>lhs - rhs,\n        mulN: (lhs, rhs)=>lhs * rhs,\n        inv: (num)=>invert(num, ORDER),\n        sqrt: redef.sqrt || ((n)=>{\n            if (!sqrtP) sqrtP = FpSqrt(ORDER);\n            return sqrtP(f, n);\n        }),\n        toBytes: (num)=>isLE ? (0, utils_ts_1.numberToBytesLE)(num, BYTES) : (0, utils_ts_1.numberToBytesBE)(num, BYTES),\n        fromBytes: (bytes)=>{\n            if (bytes.length !== BYTES) throw new Error(\"Field.fromBytes: expected \" + BYTES + \" bytes, got \" + bytes.length);\n            return isLE ? (0, utils_ts_1.bytesToNumberLE)(bytes) : (0, utils_ts_1.bytesToNumberBE)(bytes);\n        },\n        // TODO: we don't need it here, move out to separate fn\n        invertBatch: (lst)=>FpInvertBatch(f, lst),\n        // We can't move this out because Fp6, Fp12 implement it\n        // and it's unclear what to return in there.\n        cmov: (a, b, c)=>c ? b : a\n    });\n    return Object.freeze(f);\n}\nfunction FpSqrtOdd(Fp, elm) {\n    if (!Fp.isOdd) throw new Error(\"Field doesn't have isOdd\");\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? root : Fp.neg(root);\n}\nfunction FpSqrtEven(Fp, elm) {\n    if (!Fp.isOdd) throw new Error(\"Field doesn't have isOdd\");\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? Fp.neg(root) : root;\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Same as mapKeyToField, but accepts less bytes (40 instead of 48 for 32-byte field).\n * Which makes it slightly more biased, less secure.\n * @deprecated use `mapKeyToField` instead\n */ function hashToPrivateScalar(hash, groupOrder, isLE = false) {\n    hash = (0, utils_ts_1.ensureBytes)(\"privateHash\", hash);\n    const hashLen = hash.length;\n    const minLen = nLength(groupOrder).nByteLength + 8;\n    if (minLen < 24 || hashLen < minLen || hashLen > 1024) throw new Error(\"hashToPrivateScalar: expected \" + minLen + \"-1024 bytes of input, got \" + hashLen);\n    const num = isLE ? (0, utils_ts_1.bytesToNumberLE)(hash) : (0, utils_ts_1.bytesToNumberBE)(hash);\n    return mod(num, groupOrder - _1n) + _1n;\n}\n/**\n * Returns total number of bytes consumed by the field element.\n * For example, 32 bytes for usual 256-bit weierstrass curve.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of field\n */ function getFieldBytesLength(fieldOrder) {\n    if (typeof fieldOrder !== \"bigint\") throw new Error(\"field order must be bigint\");\n    const bitLength = fieldOrder.toString(2).length;\n    return Math.ceil(bitLength / 8);\n}\n/**\n * Returns minimal amount of bytes that can be safely reduced\n * by field order.\n * Should be 2^-128 for 128-bit curve such as P256.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of target hash\n */ function getMinHashLength(fieldOrder) {\n    const length = getFieldBytesLength(fieldOrder);\n    return length + Math.ceil(length / 2);\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF\n * and convert them into private scalar, with the modulo bias being negligible.\n * Needs at least 48 bytes of input for 32-byte private key.\n * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/\n * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final\n * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5\n * @param hash hash output from SHA3 or a similar function\n * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)\n * @param isLE interpret hash bytes as LE num\n * @returns valid private scalar\n */ function mapHashToField(key, fieldOrder, isLE = false) {\n    const len = key.length;\n    const fieldLen = getFieldBytesLength(fieldOrder);\n    const minLen = getMinHashLength(fieldOrder);\n    // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.\n    if (len < 16 || len < minLen || len > 1024) throw new Error(\"expected \" + minLen + \"-1024 bytes of input, got \" + len);\n    const num = isLE ? (0, utils_ts_1.bytesToNumberLE)(key) : (0, utils_ts_1.bytesToNumberBE)(key);\n    // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0\n    const reduced = mod(num, fieldOrder - _1n) + _1n;\n    return isLE ? (0, utils_ts_1.numberToBytesLE)(reduced, fieldLen) : (0, utils_ts_1.numberToBytesBE)(reduced, fieldLen);\n} //# sourceMappingURL=modular.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9hYnN0cmFjdC9tb2R1bGFyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxvQkFBb0IsR0FBRyxLQUFLO0FBQzVCQSxXQUFXLEdBQUdHO0FBQ2RILFdBQVcsR0FBR0k7QUFDZEosWUFBWSxHQUFHSztBQUNmTCxjQUFjLEdBQUdNO0FBQ2pCTixxQkFBcUIsR0FBR087QUFDeEJQLGNBQWMsR0FBR1E7QUFDakJSLHFCQUFxQixHQUFHUztBQUN4QlQsYUFBYSxHQUFHVTtBQUNoQlYscUJBQXFCLEdBQUdXO0FBQ3hCWCxhQUFhLEdBQUdZO0FBQ2hCWixrQkFBa0IsR0FBR2E7QUFDckJiLGtCQUFrQixHQUFHYztBQUNyQmQsZUFBZSxHQUFHZTtBQUNsQmYsYUFBYSxHQUFHZ0I7QUFDaEJoQixpQkFBaUIsR0FBR2lCO0FBQ3BCakIsa0JBQWtCLEdBQUdrQjtBQUNyQmxCLDJCQUEyQixHQUFHbUI7QUFDOUJuQiwyQkFBMkIsR0FBR29CO0FBQzlCcEIsd0JBQXdCLEdBQUdxQjtBQUMzQnJCLHNCQUFzQixHQUFHc0I7QUFDekI7Ozs7O0NBS0MsR0FDRCxvRUFBb0UsR0FDcEUsTUFBTUMsVUFBVUMsbUJBQU9BLENBQUMsd0VBQXFCO0FBQzdDLE1BQU1DLGFBQWFELG1CQUFPQSxDQUFDLHdFQUFZO0FBQ3ZDLGtCQUFrQjtBQUNsQixNQUFNRSxNQUFNQyxPQUFPLElBQUlDLE1BQU1ELE9BQU8sSUFBSUUsTUFBTSxhQUFhLEdBQUdGLE9BQU8sSUFBSUcsTUFBTSxhQUFhLEdBQUdILE9BQU87QUFDdEcsa0JBQWtCO0FBQ2xCLE1BQU1JLE1BQU0sYUFBYSxHQUFHSixPQUFPLElBQUlLLE1BQU0sYUFBYSxHQUFHTCxPQUFPLElBQUlNLE1BQU0sYUFBYSxHQUFHTixPQUFPO0FBQ3JHLHdCQUF3QjtBQUN4QixTQUFTeEIsSUFBSStCLENBQUMsRUFBRUMs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LEtBQUtDLElBQUksQ0FBQ21DLFlBQVk7QUFDakM7QUFDQTs7Ozs7O0NBTUMsR0FDRCxTQUFTekksaUJBQWlCd0ksVUFBVTtJQUNoQyxNQUFNekQsU0FBU2hGLG9CQUFvQnlJO0lBQ25DLE9BQU96RCxTQUFTc0IsS0FBS0MsSUFBSSxDQUFDdkIsU0FBUztBQUN2QztBQUNBOzs7Ozs7Ozs7Ozs7Q0FZQyxHQUNELFNBQVM5RSxlQUFleUksR0FBRyxFQUFFRixVQUFVLEVBQUVoQyxPQUFPLEtBQUs7SUFDakQsTUFBTW1DLE1BQU1ELElBQUkzRCxNQUFNO0lBQ3RCLE1BQU02RCxXQUFXN0ksb0JBQW9CeUk7SUFDckMsTUFBTUQsU0FBU3ZJLGlCQUFpQndJO0lBQ2hDLGlHQUFpRztJQUNqRyxJQUFJRyxNQUFNLE1BQU1BLE1BQU1KLFVBQVVJLE1BQU0sTUFDbEMsTUFBTSxJQUFJckgsTUFBTSxjQUFjaUgsU0FBUywrQkFBK0JJO0lBQzFFLE1BQU0zSCxNQUFNd0YsT0FBTyxDQUFDLEdBQUdwRyxXQUFXeUgsZUFBZSxFQUFFYSxPQUFPLENBQUMsR0FBR3RJLFdBQVcwSCxlQUFlLEVBQUVZO0lBQzFGLCtFQUErRTtJQUMvRSxNQUFNRyxVQUFVL0osSUFBSWtDLEtBQUt3SCxhQUFhakksT0FBT0E7SUFDN0MsT0FBT2lHLE9BQU8sQ0FBQyxHQUFHcEcsV0FBV3FILGVBQWUsRUFBRW9CLFNBQVNELFlBQVksQ0FBQyxHQUFHeEksV0FBV3NILGVBQWUsRUFBRW1CLFNBQVNEO0FBQ2hILEVBQ0EsbUNBQW1DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZmFyY2FzdGVyc3RhdHMvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9hYnN0cmFjdC9tb2R1bGFyLmpzPzk3MDQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmlzTmVnYXRpdmVMRSA9IHZvaWQgMDtcbmV4cG9ydHMubW9kID0gbW9kO1xuZXhwb3J0cy5wb3cgPSBwb3c7XG5leHBvcnRzLnBvdzIgPSBwb3cyO1xuZXhwb3J0cy5pbnZlcnQgPSBpbnZlcnQ7XG5leHBvcnRzLnRvbmVsbGlTaGFua3MgPSB0b25lbGxpU2hhbmtzO1xuZXhwb3J0cy5GcFNxcnQgPSBGcFNxcnQ7XG5leHBvcnRzLnZhbGlkYXRlRmllbGQgPSB2YWxpZGF0ZUZpZWxkO1xuZXhwb3J0cy5GcFBvdyA9IEZwUG93O1xuZXhwb3J0cy5GcEludmVydEJhdGNoID0gRnBJbnZlcnRCYXRjaDtcbmV4cG9ydHMuRnBEaXYgPSBGcERpdjtcbmV4cG9ydHMuRnBMZWdlbmRyZSA9IEZwTGVnZW5kcmU7XG5leHBvcnRzLkZwSXNTcXVhcmUgPSBGcElzU3F1YXJlO1xuZXhwb3J0cy5uTGVuZ3RoID0gbkxlbmd0aDtcbmV4cG9ydHMuRmllbGQgPSBGaWVsZDtcbmV4cG9ydHMuRnBTcXJ0T2RkID0gRnBTcXJ0T2RkO1xuZXhwb3J0cy5GcFNxcnRFdmVuID0gRnBTcXJ0RXZlbjtcbmV4cG9ydHMuaGFzaFRvUHJpdmF0ZVNjYWxhciA9IGhhc2hUb1ByaXZhdGVTY2FsYXI7XG5leHBvcnRzLmdldEZpZWxkQnl0ZXNMZW5ndGggPSBnZXRGaWVsZEJ5dGVzTGVuZ3RoO1xuZXhwb3J0cy5nZXRNaW5IYXNoTGVuZ3RoID0gZ2V0TWluSGFzaExlbmd0aDtcbmV4cG9ydHMubWFwSGFzaFRvRmllbGQgPSBtYXBIYXNoVG9GaWVsZDtcbi8qKlxuICogVXRpbHMgZm9yIG1vZHVsYXIgZGl2aXNpb24gYW5kIGZpbml0ZSBmaWVsZHMuXG4gKiBBIGZpbml0ZSBmaWVsZCBvdmVyIDExIGlzIGludGVnZXIgbnVtYmVyIG9wZXJhdGlvbnMgYG1vZCAxMWAuXG4gKiBUaGVyZSBpcyBubyBkaXZpc2lvbjogaXQgaXMgcmVwbGFjZWQgYnkgbW9kdWxhciBtdWx0aXBsaWNhdGl2ZSBpbnZlcnNlLlxuICogQG1vZHVsZVxuICovXG4vKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIkBub2JsZS9oYXNoZXMvdXRpbHNcIik7XG5jb25zdCB1dGlsc190c18xID0gcmVxdWlyZShcIi4vdXRpbHMuanNcIik7XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IF8wbiA9IEJpZ0ludCgwKSwgXzFuID0gQmlnSW50KDEpLCBfMm4gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDIpLCBfM24gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDMpO1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBfNG4gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDQpLCBfNW4gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDUpLCBfOG4gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDgpO1xuLy8gQ2FsY3VsYXRlcyBhIG1vZHVsbyBiXG5mdW5jdGlvbiBtb2QoYSwgYikge1xuICAgIGNvbnN0IHJlc3VsdCA9IGEgJSBiO1xuICAgIHJldHVybiByZXN1bHQgPj0gXzBuID8gcmVzdWx0IDogYiArIHJlc3VsdDtcbn1cbi8qKlxuICogRWZmaWNpZW50bHkgcmFpc2UgbnVtIHRvIHBvd2VyIGFuZCBkbyBtb2R1bGFyIGRpdmlzaW9uLlxuICogVW5zYWZlIGluIHNvbWUgY29udGV4dHM6IHVzZXMgbGFkZGVyLCBzbyBjYW4gZXhwb3NlIGJpZ2ludCBiaXRzLlxuICogVE9ETzogcmVtb3ZlLlxuICogQGV4YW1wbGVcbiAqIHBvdygybiwgNm4sIDExbikgLy8gNjRuICUgMTFuID09IDluXG4gKi9cbmZ1bmN0aW9uIHBvdyhudW0sIHBvd2VyLCBtb2R1bG8pIHtcbiAgICByZXR1cm4gRnBQb3coRmllbGQobW9kdWxvKSwgbnVtLCBwb3dlcik7XG59XG4vKiogRG9lcyBgeF4oMl5wb3dlcilgIG1vZCBwLiBgcG93MigzMCwgNClgID09IGAzMF4oMl40KWAgKi9cbmZ1bmN0aW9uIHBvdzIoeCwgcG93ZXIsIG1vZHVsbykge1xuICAgIGxldCByZXMgPSB4O1xuICAgIHdoaWxlIChwb3dlci0tID4gXzBuKSB7XG4gICAgICAgIHJlcyAqPSByZXM7XG4gICAgICAgIHJlcyAlPSBtb2R1bG87XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG4vKipcbiAqIEludmVyc2VzIG51bWJlciBvdmVyIG1vZHVsby5cbiAqIEltcGxlbWVudGVkIHVzaW5nIFtFdWNsaWRlYW4gR0NEXShodHRwczovL2JyaWxsaWFudC5vcmcvd2lraS9leHRlbmRlZC1ldWNsaWRlYW4tYWxnb3JpdGhtLykuXG4gKi9cbmZ1bmN0aW9uIGludmVydChudW1iZXIsIG1vZHVsbykge1xuICAgIGlmIChudW1iZXIgPT09IF8wbilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZlcnQ6IGV4cGVjdGVkIG5vbi16ZXJvIG51bWJlcicpO1xuICAgIGlmIChtb2R1bG8gPD0gXzBuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmVydDogZXhwZWN0ZWQgcG9zaXRpdmUgbW9kdWx1cywgZ290ICcgKyBtb2R1bG8pO1xuICAgIC8vIEZlcm1hdCdzIGxpdHRsZSB0aGVvcmVtIFwiQ1QtbGlrZVwiIHZlcnNpb24gaW52KG4pID0gbl4obS0yKSBtb2QgbSBpcyAzMHggc2xvd2VyLlxuICAgIGxldCBhID0gbW9kKG51bWJlciwgbW9kdWxvKTtcbiAgICBsZXQgYiA9IG1vZHVsbztcbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBsZXQgeCA9IF8wbiwgeSA9IF8xbiwgdSA9IF8xbiwgdiA9IF8wbjtcbiAgICB3aGlsZSAoYSAhPT0gXzBuKSB7XG4gICAgICAgIC8vIEpJVCBhcHBsaWVzIG9wdGltaXphdGlvbiBpZiB0aG9zZSB0d28gbGluZXMgZm9sbG93IGVhY2ggb3RoZXJcbiAgICAgICAgY29uc3QgcSA9IGIgLyBhO1xuICAgICAgICBjb25zdCByID0gYiAlIGE7XG4gICAgICAgIGNvbnN0IG0gPSB4IC0gdSAqIHE7XG4gICAgICAgIGNvbnN0IG4gPSB5IC0gdiAqIHE7XG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICBiID0gYSwgYSA9IHIsIHggPSB1LCB5ID0gdiwgdSA9IG0sIHYgPSBuO1xuICAgIH1cbiAgICBjb25zdCBnY2QgPSBiO1xuICAgIGlmIChnY2QgIT09IF8xbilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZlcnQ6IGRvZXMgbm90IGV4aXN0Jyk7XG4gICAgcmV0dXJuIG1vZCh4LCBtb2R1bG8pO1xufVxuLy8gTm90IGFsbCByb290cyBhcmUgcG9zc2libGUhIEV4YW1wbGUgd2hpY2ggd2lsbCB0aHJvdzpcbi8vIGNvbnN0IE5VTSA9XG4vLyBuID0gNzIwNTc1OTQwMzc5Mjc4MTZuO1xuLy8gRnAgPSBGaWVsZChCaWdJbnQoJzB4MWEwMTExZWEzOTdmZTY5YTRiMWJhN2I2NDM0YmFjZDc2NDc3NGI4NGYzODUxMmJmNjczMGQyYTBmNmIwZjYyNDFlYWJmZmZlYjE1M2ZmZmZiOWZlZmZmZmZmZmZhYWFiJykpO1xuZnVuY3Rpb24gc3FydDNtb2Q0KEZwLCBuKSB7XG4gICAgY29uc3QgcDFkaXY0ID0gKEZwLk9SREVSICsgXzFuKSAvIF80bjtcbiAgICBjb25zdCByb290ID0gRnAucG93KG4sIHAxZGl2NCk7XG4gICAgLy8gVGhyb3cgaWYgcm9vdF4yICE9IG5cbiAgICBpZiAoIUZwLmVxbChGcC5zcXIocm9vdCksIG4pKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIHNxdWFyZSByb290Jyk7XG4gICAgcmV0dXJuIHJvb3Q7XG59XG5mdW5jdGlvbiBzcXJ0NW1vZDgoRnAsIG4pIHtcbiAgICBjb25zdCBwNWRpdjggPSAoRnAuT1JERVIgLSBfNW4pIC8gXzhuO1xuICAgIGNvbnN0IG4yID0gRnAubXVsKG4sIF8ybik7XG4gICAgY29uc3QgdiA9IEZwLnBvdyhuMiwgcDVkaXY4KTtcbiAgICBjb25zdCBudiA9IEZwLm11bChuLCB2KTtcbiAgICBjb25zdCBpID0gRnAubXVsKEZwLm11bChudiwgXzJuKSwgdik7XG4gICAgY29uc3Qgcm9vdCA9IEZwLm11bChudiwgRnAuc3ViKGksIEZwLk9ORSkpO1xuICAgIGlmICghRnAuZXFsKEZwLnNxcihyb290KSwgbikpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgc3F1YXJlIHJvb3QnKTtcbiAgICByZXR1cm4gcm9vdDtcbn1cbi8vIFRPRE86IENvbW1lbnRlZC1vdXQgZm9yIG5vdy4gUHJvdmlkZSB0ZXN0IHZlY3RvcnMuXG4vLyBUb25lbGxpIGlzIHRvbyBzbG93IGZvciBleHRlbnNpb24gZmllbGRzIEZwMi5cbi8vIFRoYXQgbWVhbnMgd2UgY2FuJ3QgdXNlIHNxcnQgKGMxLCBjMi4uLikgZXZlbiBmb3IgaW5pdGlhbGl6YXRpb24gY29uc3RhbnRzLlxuLy8gaWYgKFAgJSBfMTZuID09PSBfOW4pIHJldHVybiBzcXJ0OW1vZDE2O1xuLy8gLy8gcHJldHRpZXItaWdub3JlXG4vLyBmdW5jdGlvbiBzcXJ0OW1vZDE2PFQ+KEZwOiBJRmllbGQ8VD4sIG46IFQsIHA3ZGl2MTY/OiBiaWdpbnQpIHtcbi8vICAgaWYgKHA3ZGl2MTYgPT09IHVuZGVmaW5lZCkgcDdkaXYxNiA9IChGcC5PUkRFUiArIEJpZ0ludCg3KSkgLyBfMTZuO1xuLy8gICBjb25zdCBjMSA9IEZwLnNxcnQoRnAubmVnKEZwLk9ORSkpOyAvLyAgMS4gYzEgPSBzcXJ0KC0xKSBpbiBGLCBpLmUuLCAoYzFeMikgPT0gLTEgaW4gRlxuLy8gICBjb25zdCBjMiA9IEZwLnNxcnQoYzEpOyAgICAgICAgICAgICAvLyAgMi4gYzIgPSBzcXJ0KGMxKSBpbiBGLCBpLmUuLCAoYzJeMikgPT0gYzEgaW4gRlxuLy8gICBjb25zdCBjMyA9IEZwLnNxcnQoRnAubmVnKGMxKSk7ICAgICAvLyAgMy4gYzMgPSBzcXJ0KC1jMSkgaW4gRiwgaS5lLiwgKGMzXjIpID09IC1jMSBpbiBGXG4vLyAgIGNvbnN0IGM0ID0gcDdkaXYxNjsgICAgICAgICAgICAgICAgIC8vICA0LiBjNCA9IChxICsgNykgLyAxNiAgICAgICAgIyBJbnRlZ2VyIGFyaXRobWV0aWNcbi8vICAgbGV0IHR2MSA9IEZwLnBvdyhuLCBjNCk7ICAgICAgICAgICAgLy8gIDEuIHR2MSA9IHheYzRcbi8vICAgbGV0IHR2MiA9IEZwLm11bChjMSwgdHYxKTsgICAgICAgICAgLy8gIDIuIHR2MiA9IGMxICogdHYxXG4vLyAgIGNvbnN0IHR2MyA9IEZwLm11bChjMiwgdHYxKTsgICAgICAgIC8vICAzLiB0djMgPSBjMiAqIHR2MVxuLy8gICBsZXQgdHY0ID0gRnAubXVsKGMzLCB0djEpOyAgICAgICAgICAvLyAgNC4gdHY0ID0gYzMgKiB0djFcbi8vICAgY29uc3QgZTEgPSBGcC5lcWwoRnAuc3FyKHR2MiksIG4pOyAgLy8gIDUuICBlMSA9ICh0djJeMikgPT0geFxuLy8gICBjb25zdCBlMiA9IEZwLmVxbChGcC5zcXIodHYzKSwgbik7ICAvLyAgNi4gIGUyID0gKHR2M14yKSA9PSB4XG4vLyAgIHR2MSA9IEZwLmNtb3YodHYxLCB0djIsIGUxKTsgLy8gIDcuIHR2MSA9IENNT1YodHYxLCB0djIsIGUxKSAgIyBTZWxlY3QgdHYyIGlmICh0djJeMikgPT0geFxuLy8gICB0djIgPSBGcC5jbW92KHR2NCwgdHYzLCBlMik7IC8vICA4LiB0djIgPSBDTU9WKHR2NCwgdHYzLCBlMikgICMgU2VsZWN0IHR2MyBpZiAodHYzXjIpID09IHhcbi8vICAgY29uc3QgZTMgPSBGcC5lcWwoRnAuc3FyKHR2MiksIG4pOyAgLy8gIDkuICBlMyA9ICh0djJeMikgPT0geFxuLy8gICByZXR1cm4gRnAuY21vdih0djEsIHR2MiwgZTMpOyAvLyAxMC4gIHogPSBDTU9WKHR2MSwgdHYyLCBlMykgIyBTZWxlY3QgdGhlIHNxcnQgZnJvbSB0djEgYW5kIHR2MlxuLy8gfVxuLyoqXG4gKiBUb25lbGxpLVNoYW5rcyBzcXVhcmUgcm9vdCBzZWFyY2ggYWxnb3JpdGhtLlxuICogMS4gaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAxMi82ODUucGRmIChwYWdlIDEyKVxuICogMi4gU3F1YXJlIFJvb3RzIGZyb20gMTsgMjQsIDUxLCAxMCB0byBEYW4gU2hhbmtzXG4gKiBAcGFyYW0gUCBmaWVsZCBvcmRlclxuICogQHJldHVybnMgZnVuY3Rpb24gdGhhdCB0YWtlcyBmaWVsZCBGcCAoY3JlYXRlZCBmcm9tIFApIGFuZCBudW1iZXIgblxuICovXG5mdW5jdGlvbiB0b25lbGxpU2hhbmtzKFApIHtcbiAgICAvLyBJbml0aWFsaXphdGlvbiAocHJlY29tcHV0YXRpb24pLlxuICAgIGlmIChQIDwgQmlnSW50KDMpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NxcnQgaXMgbm90IGRlZmluZWQgZm9yIHNtYWxsIGZpZWxkJyk7XG4gICAgLy8gRmFjdG9yIFAgLSAxID0gUSAqIDJeUywgd2hlcmUgUSBpcyBvZGRcbiAgICBsZXQgUSA9IFAgLSBfMW47XG4gICAgbGV0IFMgPSAwO1xuICAgIHdoaWxlIChRICUgXzJuID09PSBfMG4pIHtcbiAgICAgICAgUSAvPSBfMm47XG4gICAgICAgIFMrKztcbiAgICB9XG4gICAgLy8gRmluZCB0aGUgZmlyc3QgcXVhZHJhdGljIG5vbi1yZXNpZHVlIFogPj0gMlxuICAgIGxldCBaID0gXzJuO1xuICAgIGNvbnN0IF9GcCA9IEZpZWxkKFApO1xuICAgIHdoaWxlIChGcExlZ2VuZHJlKF9GcCwgWikgPT09IDEpIHtcbiAgICAgICAgLy8gQmFzaWMgcHJpbWFsaXR5IHRlc3QgZm9yIFAuIEFmdGVyIHggaXRlcmF0aW9ucywgY2hhbmNlIG9mXG4gICAgICAgIC8vIG5vdCBmaW5kaW5nIHF1YWRyYXRpYyBub24tcmVzaWR1ZSBpcyAyXngsIHNvIDJeMTAwMC5cbiAgICAgICAgaWYgKForKyA+IDEwMDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIHNxdWFyZSByb290OiBwcm9iYWJseSBub24tcHJpbWUgUCcpO1xuICAgIH1cbiAgICAvLyBGYXN0LXBhdGg7IHVzdWFsbHkgZG9uZSBiZWZvcmUgWiwgYnV0IHdlIGRvIFwicHJpbWFsaXR5IHRlc3RcIi5cbiAgICBpZiAoUyA9PT0gMSlcbiAgICAgICAgcmV0dXJuIHNxcnQzbW9kNDtcbiAgICAvLyBTbG93LXBhdGhcbiAgICAvLyBUT0RPOiB0ZXN0IG9uIEZwMiBhbmQgb3RoZXJzXG4gICAgbGV0IGNjID0gX0ZwLnBvdyhaLCBRKTsgLy8gYyA9IHpeUVxuICAgIGNvbnN0IFExZGl2MiA9IChRICsgXzFuKSAvIF8ybjtcbiAgICByZXR1cm4gZnVuY3Rpb24gdG9uZWxsaVNsb3coRnAsIG4pIHtcbiAgICAgICAgaWYgKEZwLmlzMChuKSlcbiAgICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICAvLyBDaGVjayBpZiBuIGlzIGEgcXVhZHJhdGljIHJlc2lkdWUgdXNpbmcgTGVnZW5kcmUgc3ltYm9sXG4gICAgICAgIGlmIChGcExlZ2VuZHJlKEZwLCBuKSAhPT0gMSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgc3F1YXJlIHJvb3QnKTtcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSB2YXJpYWJsZXMgZm9yIHRoZSBtYWluIGxvb3BcbiAgICAgICAgbGV0IE0gPSBTO1xuICAgICAgICBsZXQgYyA9IEZwLm11bChGcC5PTkUsIGNjKTsgLy8gYyA9IHpeUSwgbW92ZSBjYyBmcm9tIGZpZWxkIF9GcCBpbnRvIGZpZWxkIEZwXG4gICAgICAgIGxldCB0ID0gRnAucG93KG4sIFEpOyAvLyB0ID0gbl5RLCBmaXJzdCBndWVzcyBhdCB0aGUgZnVkZ2UgZmFjdG9yXG4gICAgICAgIGxldCBSID0gRnAucG93KG4sIFExZGl2Mik7IC8vIFIgPSBuXigoUSsxKS8yKSwgZmlyc3QgZ3Vlc3MgYXQgdGhlIHNxdWFyZSByb290XG4gICAgICAgIC8vIE1haW4gbG9vcFxuICAgICAgICAvLyB3aGlsZSB0ICE9IDFcbiAgICAgICAgd2hpbGUgKCFGcC5lcWwodCwgRnAuT05FKSkge1xuICAgICAgICAgICAgaWYgKEZwLmlzMCh0KSlcbiAgICAgICAgICAgICAgICByZXR1cm4gRnAuWkVSTzsgLy8gaWYgdD0wIHJldHVybiBSPTBcbiAgICAgICAgICAgIGxldCBpID0gMTtcbiAgICAgICAgICAgIC8vIEZpbmQgdGhlIHNtYWxsZXN0IGkgPj0gMSBzdWNoIHRoYXQgdF4oMl5pKSDiiaEgMSAobW9kIFApXG4gICAgICAgICAgICBsZXQgdF90bXAgPSBGcC5zcXIodCk7IC8vIHReKDJeMSlcbiAgICAgICAgICAgIHdoaWxlICghRnAuZXFsKHRfdG1wLCBGcC5PTkUpKSB7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIHRfdG1wID0gRnAuc3FyKHRfdG1wKTsgLy8gdF4oMl4yKS4uLlxuICAgICAgICAgICAgICAgIGlmIChpID09PSBNKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIHNxdWFyZSByb290Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIGV4cG9uZW50IGZvciBiOiAyXihNIC0gaSAtIDEpXG4gICAgICAgICAgICBjb25zdCBleHBvbmVudCA9IF8xbiA8PCBCaWdJbnQoTSAtIGkgLSAxKTsgLy8gYmlnaW50IGlzIGltcG9ydGFudFxuICAgICAgICAgICAgY29uc3QgYiA9IEZwLnBvdyhjLCBleHBvbmVudCk7IC8vIGIgPSAyXihNIC0gaSAtIDEpXG4gICAgICAgICAgICAvLyBVcGRhdGUgdmFyaWFibGVzXG4gICAgICAgICAgICBNID0gaTtcbiAgICAgICAgICAgIGMgPSBGcC5zcXIoYik7IC8vIGMgPSBiXjJcbiAgICAgICAgICAgIHQgPSBGcC5tdWwodCwgYyk7IC8vIHQgPSAodCAqIGJeMilcbiAgICAgICAgICAgIFIgPSBGcC5tdWwoUiwgYik7IC8vIFIgPSBSKmJcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUjtcbiAgICB9O1xufVxuLyoqXG4gKiBTcXVhcmUgcm9vdCBmb3IgYSBmaW5pdGUgZmllbGQuIFdpbGwgdHJ5IG9wdGltaXplZCB2ZXJzaW9ucyBmaXJzdDpcbiAqXG4gKiAxLiBQIOKJoSAzIChtb2QgNClcbiAqIDIuIFAg4omhIDUgKG1vZCA4KVxuICogMy4gVG9uZWxsaS1TaGFua3MgYWxnb3JpdGhtXG4gKlxuICogRGlmZmVyZW50IGFsZ29yaXRobXMgY2FuIGdpdmUgZGlmZmVyZW50IHJvb3RzLCBpdCBpcyB1cCB0byB1c2VyIHRvIGRlY2lkZSB3aGljaCBvbmUgdGhleSB3YW50LlxuICogRm9yIGV4YW1wbGUgdGhlcmUgaXMgRnBTcXJ0T2RkL0ZwU3FydEV2ZW4gdG8gY2hvaWNlIHJvb3QgYmFzZWQgb24gb2RkbmVzcyAodXNlZCBmb3IgaGFzaC10by1jdXJ2ZSkuXG4gKi9cbmZ1bmN0aW9uIEZwU3FydChQKSB7XG4gICAgLy8gUCDiiaEgMyAobW9kIDQpID0+IOKImm4gPSBuXigoUCsxKS80KVxuICAgIGlmIChQICUgXzRuID09PSBfM24pXG4gICAgICAgIHJldHVybiBzcXJ0M21vZDQ7XG4gICAgLy8gUCDiiaEgNSAobW9kIDgpID0+IEF0a2luIGFsZ29yaXRobSwgcGFnZSAxMCBvZiBodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDEyLzY4NS5wZGZcbiAgICBpZiAoUCAlIF84biA9PT0gXzVuKVxuICAgICAgICByZXR1cm4gc3FydDVtb2Q4O1xuICAgIC8vIFAg4omhIDkgKG1vZCAxNikgbm90IGltcGxlbWVudGVkLCBzZWUgYWJvdmVcbiAgICAvLyBUb25lbGxpLVNoYW5rcyBhbGdvcml0aG1cbiAgICByZXR1cm4gdG9uZWxsaVNoYW5rcyhQKTtcbn1cbi8vIExpdHRsZS1lbmRpYW4gY2hlY2sgZm9yIGZpcnN0IExFIGJpdCAobGFzdCBCRSBiaXQpO1xuY29uc3QgaXNOZWdhdGl2ZUxFID0gKG51bSwgbW9kdWxvKSA9PiAobW9kKG51bSwgbW9kdWxvKSAmIF8xbikgPT09IF8xbjtcbmV4cG9ydHMuaXNOZWdhdGl2ZUxFID0gaXNOZWdhdGl2ZUxFO1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBGSUVMRF9GSUVMRFMgPSBbXG4gICAgJ2NyZWF0ZScsICdpc1ZhbGlkJywgJ2lzMCcsICduZWcnLCAnaW52JywgJ3NxcnQnLCAnc3FyJyxcbiAgICAnZXFsJywgJ2FkZCcsICdzdWInLCAnbXVsJywgJ3BvdycsICdkaXYnLFxuICAgICdhZGROJywgJ3N1Yk4nLCAnbXVsTicsICdzcXJOJ1xuXTtcbmZ1bmN0aW9uIHZhbGlkYXRlRmllbGQoZmllbGQpIHtcbiAgICBjb25zdCBpbml0aWFsID0ge1xuICAgICAgICBPUkRFUjogJ2JpZ2ludCcsXG4gICAgICAgIE1BU0s6ICdiaWdpbnQnLFxuICAgICAgICBCWVRFUzogJ2lzU2FmZUludGVnZXInLFxuICAgICAgICBCSVRTOiAnaXNTYWZlSW50ZWdlcicsXG4gICAgfTtcbiAgICBjb25zdCBvcHRzID0gRklFTERfRklFTERTLnJlZHVjZSgobWFwLCB2YWwpID0+IHtcbiAgICAgICAgbWFwW3ZhbF0gPSAnZnVuY3Rpb24nO1xuICAgICAgICByZXR1cm4gbWFwO1xuICAgIH0sIGluaXRpYWwpO1xuICAgIHJldHVybiAoMCwgdXRpbHNfdHNfMS52YWxpZGF0ZU9iamVjdCkoZmllbGQsIG9wdHMpO1xufVxuLy8gR2VuZXJpYyBmaWVsZCBmdW5jdGlvbnNcbi8qKlxuICogU2FtZSBhcyBgcG93YCBidXQgZm9yIEZwOiBub24tY29uc3RhbnQtdGltZS5cbiAqIFVuc2FmZSBpbiBzb21lIGNvbnRleHRzOiB1c2VzIGxhZGRlciwgc28gY2FuIGV4cG9zZSBiaWdpbnQgYml0cy5cbiAqL1xuZnVuY3Rpb24gRnBQb3coRnAsIG51bSwgcG93ZXIpIHtcbiAgICBpZiAocG93ZXIgPCBfMG4pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBleHBvbmVudCwgbmVnYXRpdmVzIHVuc3VwcG9ydGVkJyk7XG4gICAgaWYgKHBvd2VyID09PSBfMG4pXG4gICAgICAgIHJldHVybiBGcC5PTkU7XG4gICAgaWYgKHBvd2VyID09PSBfMW4pXG4gICAgICAgIHJldHVybiBudW07XG4gICAgbGV0IHAgPSBGcC5PTkU7XG4gICAgbGV0IGQgPSBudW07XG4gICAgd2hpbGUgKHBvd2VyID4gXzBuKSB7XG4gICAgICAgIGlmIChwb3dlciAmIF8xbilcbiAgICAgICAgICAgIHAgPSBGcC5tdWwocCwgZCk7XG4gICAgICAgIGQgPSBGcC5zcXIoZCk7XG4gICAgICAgIHBvd2VyID4+PSBfMW47XG4gICAgfVxuICAgIHJldHVybiBwO1xufVxuLyoqXG4gKiBFZmZpY2llbnRseSBpbnZlcnQgYW4gYXJyYXkgb2YgRmllbGQgZWxlbWVudHMuXG4gKiBFeGNlcHRpb24tZnJlZS4gV2lsbCByZXR1cm4gYHVuZGVmaW5lZGAgZm9yIDAgZWxlbWVudHMuXG4gKiBAcGFyYW0gcGFzc1plcm8gbWFwIDAgdG8gMCAoaW5zdGVhZCBvZiB1bmRlZmluZWQpXG4gKi9cbmZ1bmN0aW9uIEZwSW52ZXJ0QmF0Y2goRnAsIG51bXMsIHBhc3NaZXJvID0gZmFsc2UpIHtcbiAgICBjb25zdCBpbnZlcnRlZCA9IG5ldyBBcnJheShudW1zLmxlbmd0aCkuZmlsbChwYXNzWmVybyA/IEZwLlpFUk8gOiB1bmRlZmluZWQpO1xuICAgIC8vIFdhbGsgZnJvbSBmaXJzdCB0byBsYXN0LCBtdWx0aXBseSB0aGVtIGJ5IGVhY2ggb3RoZXIgTU9EIHBcbiAgICBjb25zdCBtdWx0aXBsaWVkQWNjID0gbnVtcy5yZWR1Y2UoKGFjYywgbnVtLCBpKSA9PiB7XG4gICAgICAgIGlmIChGcC5pczAobnVtKSlcbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIGludmVydGVkW2ldID0gYWNjO1xuICAgICAgICByZXR1cm4gRnAubXVsKGFjYywgbnVtKTtcbiAgICB9LCBGcC5PTkUpO1xuICAgIC8vIEludmVydCBsYXN0IGVsZW1lbnRcbiAgICBjb25zdCBpbnZlcnRlZEFjYyA9IEZwLmludihtdWx0aXBsaWVkQWNjKTtcbiAgICAvLyBXYWxrIGZyb20gbGFzdCB0byBmaXJzdCwgbXVsdGlwbHkgdGhlbSBieSBpbnZlcnRlZCBlYWNoIG90aGVyIE1PRCBwXG4gICAgbnVtcy5yZWR1Y2VSaWdodCgoYWNjLCBudW0sIGkpID0+IHtcbiAgICAgICAgaWYgKEZwLmlzMChudW0pKVxuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgaW52ZXJ0ZWRbaV0gPSBGcC5tdWwoYWNjLCBpbnZlcnRlZFtpXSk7XG4gICAgICAgIHJldHVybiBGcC5tdWwoYWNjLCBudW0pO1xuICAgIH0sIGludmVydGVkQWNjKTtcbiAgICByZXR1cm4gaW52ZXJ0ZWQ7XG59XG4vLyBUT0RPOiByZW1vdmVcbmZ1bmN0aW9uIEZwRGl2KEZwLCBsaHMsIHJocykge1xuICAgIHJldHVybiBGcC5tdWwobGhzLCB0eXBlb2YgcmhzID09PSAnYmlnaW50JyA/IGludmVydChyaHMsIEZwLk9SREVSKSA6IEZwLmludihyaHMpKTtcbn1cbi8qKlxuICogTGVnZW5kcmUgc3ltYm9sLlxuICogTGVnZW5kcmUgY29uc3RhbnQgaXMgdXNlZCB0byBjYWxjdWxhdGUgTGVnZW5kcmUgc3ltYm9sIChhIHwgcClcbiAqIHdoaWNoIGRlbm90ZXMgdGhlIHZhbHVlIG9mIGFeKChwLTEpLzIpIChtb2QgcCkuXG4gKlxuICogKiAoYSB8IHApIOKJoSAxICAgIGlmIGEgaXMgYSBzcXVhcmUgKG1vZCBwKSwgcXVhZHJhdGljIHJlc2lkdWVcbiAqICogKGEgfCBwKSDiiaEgLTEgICBpZiBhIGlzIG5vdCBhIHNxdWFyZSAobW9kIHApLCBxdWFkcmF0aWMgbm9uIHJlc2lkdWVcbiAqICogKGEgfCBwKSDiiaEgMCAgICBpZiBhIOKJoSAwIChtb2QgcClcbiAqL1xuZnVuY3Rpb24gRnBMZWdlbmRyZShGcCwgbikge1xuICAgIC8vIFdlIGNhbiB1c2UgM3JkIGFyZ3VtZW50IGFzIG9wdGlvbmFsIGNhY2hlIG9mIHRoaXMgdmFsdWVcbiAgICAvLyBidXQgc2VlbXMgdW5uZWVkZWQgZm9yIG5vdy4gVGhlIG9wZXJhdGlvbiBpcyB2ZXJ5IGZhc3QuXG4gICAgY29uc3QgcDFtb2QyID0gKEZwLk9SREVSIC0gXzFuKSAvIF8ybjtcbiAgICBjb25zdCBwb3dlcmVkID0gRnAucG93KG4sIHAxbW9kMik7XG4gICAgY29uc3QgeWVzID0gRnAuZXFsKHBvd2VyZWQsIEZwLk9ORSk7XG4gICAgY29uc3QgemVybyA9IEZwLmVxbChwb3dlcmVkLCBGcC5aRVJPKTtcbiAgICBjb25zdCBubyA9IEZwLmVxbChwb3dlcmVkLCBGcC5uZWcoRnAuT05FKSk7XG4gICAgaWYgKCF5ZXMgJiYgIXplcm8gJiYgIW5vKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgTGVnZW5kcmUgc3ltYm9sIHJlc3VsdCcpO1xuICAgIHJldHVybiB5ZXMgPyAxIDogemVybyA/IDAgOiAtMTtcbn1cbi8vIFRoaXMgZnVuY3Rpb24gcmV0dXJucyBUcnVlIHdoZW5ldmVyIHRoZSB2YWx1ZSB4IGlzIGEgc3F1YXJlIGluIHRoZSBmaWVsZCBGLlxuZnVuY3Rpb24gRnBJc1NxdWFyZShGcCwgbikge1xuICAgIGNvbnN0IGwgPSBGcExlZ2VuZHJlKEZwLCBuKTtcbiAgICByZXR1cm4gbCA9PT0gMTtcbn1cbi8vIENVUlZFLm4gbGVuZ3Roc1xuZnVuY3Rpb24gbkxlbmd0aChuLCBuQml0TGVuZ3RoKSB7XG4gICAgLy8gQml0IHNpemUsIGJ5dGUgc2l6ZSBvZiBDVVJWRS5uXG4gICAgaWYgKG5CaXRMZW5ndGggIT09IHVuZGVmaW5lZClcbiAgICAgICAgKDAsIHV0aWxzXzEuYW51bWJlcikobkJpdExlbmd0aCk7XG4gICAgY29uc3QgX25CaXRMZW5ndGggPSBuQml0TGVuZ3RoICE9PSB1bmRlZmluZWQgPyBuQml0TGVuZ3RoIDogbi50b1N0cmluZygyKS5sZW5ndGg7XG4gICAgY29uc3QgbkJ5dGVMZW5ndGggPSBNYXRoLmNlaWwoX25CaXRMZW5ndGggLyA4KTtcbiAgICByZXR1cm4geyBuQml0TGVuZ3RoOiBfbkJpdExlbmd0aCwgbkJ5dGVMZW5ndGggfTtcbn1cbi8qKlxuICogSW5pdGlhbGl6ZXMgYSBmaW5pdGUgZmllbGQgb3ZlciBwcmltZS5cbiAqIE1ham9yIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbnM6XG4gKiAqIGEpIGRlbm9ybWFsaXplZCBvcGVyYXRpb25zIGxpa2UgbXVsTiBpbnN0ZWFkIG9mIG11bFxuICogKiBiKSBzYW1lIG9iamVjdCBzaGFwZTogbmV2ZXIgYWRkIG9yIHJlbW92ZSBrZXlzXG4gKiAqIGMpIE9iamVjdC5mcmVlemVcbiAqIEZyYWdpbGU6IGFsd2F5cyBydW4gYSBiZW5jaG1hcmsgb24gYSBjaGFuZ2UuXG4gKiBTZWN1cml0eSBub3RlOiBvcGVyYXRpb25zIGRvbid0IGNoZWNrICdpc1ZhbGlkJyBmb3IgYWxsIGVsZW1lbnRzIGZvciBwZXJmb3JtYW5jZSByZWFzb25zLFxuICogaXQgaXMgY2FsbGVyIHJlc3BvbnNpYmlsaXR5IHRvIGNoZWNrIHRoaXMuXG4gKiBUaGlzIGlzIGxvdy1sZXZlbCBjb2RlLCBwbGVhc2UgbWFrZSBzdXJlIHlvdSBrbm93IHdoYXQgeW91J3JlIGRvaW5nLlxuICogQHBhcmFtIE9SREVSIHByaW1lIHBvc2l0aXZlIGJpZ2ludFxuICogQHBhcmFtIGJpdExlbiBob3cgbWFueSBiaXRzIHRoZSBmaWVsZCBjb25zdW1lc1xuICogQHBhcmFtIGlzTEUgKGRlZjogZmFsc2UpIGlmIGVuY29kaW5nIC8gZGVjb2Rpbmcgc2hvdWxkIGJlIGluIGxpdHRsZS1lbmRpYW5cbiAqIEBwYXJhbSByZWRlZiBvcHRpb25hbCBmYXN0ZXIgcmVkZWZpbml0aW9ucyBvZiBzcXJ0IGFuZCBvdGhlciBtZXRob2RzXG4gKi9cbmZ1bmN0aW9uIEZpZWxkKE9SREVSLCBiaXRMZW4sIGlzTEUgPSBmYWxzZSwgcmVkZWYgPSB7fSkge1xuICAgIGlmIChPUkRFUiA8PSBfMG4pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBmaWVsZDogZXhwZWN0ZWQgT1JERVIgPiAwLCBnb3QgJyArIE9SREVSKTtcbiAgICBjb25zdCB7IG5CaXRMZW5ndGg6IEJJVFMsIG5CeXRlTGVuZ3RoOiBCWVRFUyB9ID0gbkxlbmd0aChPUkRFUiwgYml0TGVuKTtcbiAgICBpZiAoQllURVMgPiAyMDQ4KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgZmllbGQ6IGV4cGVjdGVkIE9SREVSIG9mIDw9IDIwNDggYnl0ZXMnKTtcbiAgICBsZXQgc3FydFA7IC8vIGNhY2hlZCBzcXJ0UFxuICAgIGNvbnN0IGYgPSBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgT1JERVIsXG4gICAgICAgIGlzTEUsXG4gICAgICAgIEJJVFMsXG4gICAgICAgIEJZVEVTLFxuICAgICAgICBNQVNLOiAoMCwgdXRpbHNfdHNfMS5iaXRNYXNrKShCSVRTKSxcbiAgICAgICAgWkVSTzogXzBuLFxuICAgICAgICBPTkU6IF8xbixcbiAgICAgICAgY3JlYXRlOiAobnVtKSA9PiBtb2QobnVtLCBPUkRFUiksXG4gICAgICAgIGlzVmFsaWQ6IChudW0pID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbnVtICE9PSAnYmlnaW50JylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgZmllbGQgZWxlbWVudDogZXhwZWN0ZWQgYmlnaW50LCBnb3QgJyArIHR5cGVvZiBudW0pO1xuICAgICAgICAgICAgcmV0dXJuIF8wbiA8PSBudW0gJiYgbnVtIDwgT1JERVI7IC8vIDAgaXMgdmFsaWQgZWxlbWVudCwgYnV0IGl0J3Mgbm90IGludmVydGlibGVcbiAgICAgICAgfSxcbiAgICAgICAgaXMwOiAobnVtKSA9PiBudW0gPT09IF8wbixcbiAgICAgICAgaXNPZGQ6IChudW0pID0+IChudW0gJiBfMW4pID09PSBfMW4sXG4gICAgICAgIG5lZzogKG51bSkgPT4gbW9kKC1udW0sIE9SREVSKSxcbiAgICAgICAgZXFsOiAobGhzLCByaHMpID0+IGxocyA9PT0gcmhzLFxuICAgICAgICBzcXI6IChudW0pID0+IG1vZChudW0gKiBudW0sIE9SREVSKSxcbiAgICAgICAgYWRkOiAobGhzLCByaHMpID0+IG1vZChsaHMgKyByaHMsIE9SREVSKSxcbiAgICAgICAgc3ViOiAobGhzLCByaHMpID0+IG1vZChsaHMgLSByaHMsIE9SREVSKSxcbiAgICAgICAgbXVsOiAobGhzLCByaHMpID0+IG1vZChsaHMgKiByaHMsIE9SREVSKSxcbiAgICAgICAgcG93OiAobnVtLCBwb3dlcikgPT4gRnBQb3coZiwgbnVtLCBwb3dlciksXG4gICAgICAgIGRpdjogKGxocywgcmhzKSA9PiBtb2QobGhzICogaW52ZXJ0KHJocywgT1JERVIpLCBPUkRFUiksXG4gICAgICAgIC8vIFNhbWUgYXMgYWJvdmUsIGJ1dCBkb2Vzbid0IG5vcm1hbGl6ZVxuICAgICAgICBzcXJOOiAobnVtKSA9PiBudW0gKiBudW0sXG4gICAgICAgIGFkZE46IChsaHMsIHJocykgPT4gbGhzICsgcmhzLFxuICAgICAgICBzdWJOOiAobGhzLCByaHMpID0+IGxocyAtIHJocyxcbiAgICAgICAgbXVsTjogKGxocywgcmhzKSA9PiBsaHMgKiByaHMsXG4gICAgICAgIGludjogKG51bSkgPT4gaW52ZXJ0KG51bSwgT1JERVIpLFxuICAgICAgICBzcXJ0OiByZWRlZi5zcXJ0IHx8XG4gICAgICAgICAgICAoKG4pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXNxcnRQKVxuICAgICAgICAgICAgICAgICAgICBzcXJ0UCA9IEZwU3FydChPUkRFUik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNxcnRQKGYsIG4pO1xuICAgICAgICAgICAgfSksXG4gICAgICAgIHRvQnl0ZXM6IChudW0pID0+IChpc0xFID8gKDAsIHV0aWxzX3RzXzEubnVtYmVyVG9CeXRlc0xFKShudW0sIEJZVEVTKSA6ICgwLCB1dGlsc190c18xLm51bWJlclRvQnl0ZXNCRSkobnVtLCBCWVRFUykpLFxuICAgICAgICBmcm9tQnl0ZXM6IChieXRlcykgPT4ge1xuICAgICAgICAgICAgaWYgKGJ5dGVzLmxlbmd0aCAhPT0gQllURVMpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGaWVsZC5mcm9tQnl0ZXM6IGV4cGVjdGVkICcgKyBCWVRFUyArICcgYnl0ZXMsIGdvdCAnICsgYnl0ZXMubGVuZ3RoKTtcbiAgICAgICAgICAgIHJldHVybiBpc0xFID8gKDAsIHV0aWxzX3RzXzEuYnl0ZXNUb051bWJlckxFKShieXRlcykgOiAoMCwgdXRpbHNfdHNfMS5ieXRlc1RvTnVtYmVyQkUpKGJ5dGVzKTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gVE9ETzogd2UgZG9uJ3QgbmVlZCBpdCBoZXJlLCBtb3ZlIG91dCB0byBzZXBhcmF0ZSBmblxuICAgICAgICBpbnZlcnRCYXRjaDogKGxzdCkgPT4gRnBJbnZlcnRCYXRjaChmLCBsc3QpLFxuICAgICAgICAvLyBXZSBjYW4ndCBtb3ZlIHRoaXMgb3V0IGJlY2F1c2UgRnA2LCBGcDEyIGltcGxlbWVudCBpdFxuICAgICAgICAvLyBhbmQgaXQncyB1bmNsZWFyIHdoYXQgdG8gcmV0dXJuIGluIHRoZXJlLlxuICAgICAgICBjbW92OiAoYSwgYiwgYykgPT4gKGMgPyBiIDogYSksXG4gICAgfSk7XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoZik7XG59XG5mdW5jdGlvbiBGcFNxcnRPZGQoRnAsIGVsbSkge1xuICAgIGlmICghRnAuaXNPZGQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZpZWxkIGRvZXNuJ3QgaGF2ZSBpc09kZFwiKTtcbiAgICBjb25zdCByb290ID0gRnAuc3FydChlbG0pO1xuICAgIHJldHVybiBGcC5pc09kZChyb290KSA/IHJvb3QgOiBGcC5uZWcocm9vdCk7XG59XG5mdW5jdGlvbiBGcFNxcnRFdmVuKEZwLCBlbG0pIHtcbiAgICBpZiAoIUZwLmlzT2RkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGaWVsZCBkb2Vzbid0IGhhdmUgaXNPZGRcIik7XG4gICAgY29uc3Qgcm9vdCA9IEZwLnNxcnQoZWxtKTtcbiAgICByZXR1cm4gRnAuaXNPZGQocm9vdCkgPyBGcC5uZWcocm9vdCkgOiByb290O1xufVxuLyoqXG4gKiBcIkNvbnN0YW50LXRpbWVcIiBwcml2YXRlIGtleSBnZW5lcmF0aW9uIHV0aWxpdHkuXG4gKiBTYW1lIGFzIG1hcEtleVRvRmllbGQsIGJ1dCBhY2NlcHRzIGxlc3MgYnl0ZXMgKDQwIGluc3RlYWQgb2YgNDggZm9yIDMyLWJ5dGUgZmllbGQpLlxuICogV2hpY2ggbWFrZXMgaXQgc2xpZ2h0bHkgbW9yZSBiaWFzZWQsIGxlc3Mgc2VjdXJlLlxuICogQGRlcHJlY2F0ZWQgdXNlIGBtYXBLZXlUb0ZpZWxkYCBpbnN0ZWFkXG4gKi9cbmZ1bmN0aW9uIGhhc2hUb1ByaXZhdGVTY2FsYXIoaGFzaCwgZ3JvdXBPcmRlciwgaXNMRSA9IGZhbHNlKSB7XG4gICAgaGFzaCA9ICgwLCB1dGlsc190c18xLmVuc3VyZUJ5dGVzKSgncHJpdmF0ZUhhc2gnLCBoYXNoKTtcbiAgICBjb25zdCBoYXNoTGVuID0gaGFzaC5sZW5ndGg7XG4gICAgY29uc3QgbWluTGVuID0gbkxlbmd0aChncm91cE9yZGVyKS5uQnl0ZUxlbmd0aCArIDg7XG4gICAgaWYgKG1pbkxlbiA8IDI0IHx8IGhhc2hMZW4gPCBtaW5MZW4gfHwgaGFzaExlbiA+IDEwMjQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGFzaFRvUHJpdmF0ZVNjYWxhcjogZXhwZWN0ZWQgJyArIG1pbkxlbiArICctMTAyNCBieXRlcyBvZiBpbnB1dCwgZ290ICcgKyBoYXNoTGVuKTtcbiAgICBjb25zdCBudW0gPSBpc0xFID8gKDAsIHV0aWxzX3RzXzEuYnl0ZXNUb051bWJlckxFKShoYXNoKSA6ICgwLCB1dGlsc190c18xLmJ5dGVzVG9OdW1iZXJCRSkoaGFzaCk7XG4gICAgcmV0dXJuIG1vZChudW0sIGdyb3VwT3JkZXIgLSBfMW4pICsgXzFuO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRvdGFsIG51bWJlciBvZiBieXRlcyBjb25zdW1lZCBieSB0aGUgZmllbGQgZWxlbWVudC5cbiAqIEZvciBleGFtcGxlLCAzMiBieXRlcyBmb3IgdXN1YWwgMjU2LWJpdCB3ZWllcnN0cmFzcyBjdXJ2ZS5cbiAqIEBwYXJhbSBmaWVsZE9yZGVyIG51bWJlciBvZiBmaWVsZCBlbGVtZW50cywgdXN1YWxseSBDVVJWRS5uXG4gKiBAcmV0dXJucyBieXRlIGxlbmd0aCBvZiBmaWVsZFxuICovXG5mdW5jdGlvbiBnZXRGaWVsZEJ5dGVzTGVuZ3RoKGZpZWxkT3JkZXIpIHtcbiAgICBpZiAodHlwZW9mIGZpZWxkT3JkZXIgIT09ICdiaWdpbnQnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZpZWxkIG9yZGVyIG11c3QgYmUgYmlnaW50Jyk7XG4gICAgY29uc3QgYml0TGVuZ3RoID0gZmllbGRPcmRlci50b1N0cmluZygyKS5sZW5ndGg7XG4gICAgcmV0dXJuIE1hdGguY2VpbChiaXRMZW5ndGggLyA4KTtcbn1cbi8qKlxuICogUmV0dXJucyBtaW5pbWFsIGFtb3VudCBvZiBieXRlcyB0aGF0IGNhbiBiZSBzYWZlbHkgcmVkdWNlZFxuICogYnkgZmllbGQgb3JkZXIuXG4gKiBTaG91bGQgYmUgMl4tMTI4IGZvciAxMjgtYml0IGN1cnZlIHN1Y2ggYXMgUDI1Ni5cbiAqIEBwYXJhbSBmaWVsZE9yZGVyIG51bWJlciBvZiBmaWVsZCBlbGVtZW50cywgdXN1YWxseSBDVVJWRS5uXG4gKiBAcmV0dXJucyBieXRlIGxlbmd0aCBvZiB0YXJnZXQgaGFzaFxuICovXG5mdW5jdGlvbiBnZXRNaW5IYXNoTGVuZ3RoKGZpZWxkT3JkZXIpIHtcbiAgICBjb25zdCBsZW5ndGggPSBnZXRGaWVsZEJ5dGVzTGVuZ3RoKGZpZWxkT3JkZXIpO1xuICAgIHJldHVybiBsZW5ndGggKyBNYXRoLmNlaWwobGVuZ3RoIC8gMik7XG59XG4vKipcbiAqIFwiQ29uc3RhbnQtdGltZVwiIHByaXZhdGUga2V5IGdlbmVyYXRpb24gdXRpbGl0eS5cbiAqIENhbiB0YWtlIChuICsgbi8yKSBvciBtb3JlIGJ5dGVzIG9mIHVuaWZvcm0gaW5wdXQgZS5nLiBmcm9tIENTUFJORyBvciBLREZcbiAqIGFuZCBjb252ZXJ0IHRoZW0gaW50byBwcml2YXRlIHNjYWxhciwgd2l0aCB0aGUgbW9kdWxvIGJpYXMgYmVpbmcgbmVnbGlnaWJsZS5cbiAqIE5lZWRzIGF0IGxlYXN0IDQ4IGJ5dGVzIG9mIGlucHV0IGZvciAzMi1ieXRlIHByaXZhdGUga2V5LlxuICogaHR0cHM6Ly9yZXNlYXJjaC5rdWRlbHNraXNlY3VyaXR5LmNvbS8yMDIwLzA3LzI4L3RoZS1kZWZpbml0aXZlLWd1aWRlLXRvLW1vZHVsby1iaWFzLWFuZC1ob3ctdG8tYXZvaWQtaXQvXG4gKiBGSVBTIDE4Ni01LCBBLjIgaHR0cHM6Ly9jc3JjLm5pc3QuZ292L3B1YmxpY2F0aW9ucy9kZXRhaWwvZmlwcy8xODYvNS9maW5hbFxuICogUkZDIDkzODAsIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tNVxuICogQHBhcmFtIGhhc2ggaGFzaCBvdXRwdXQgZnJvbSBTSEEzIG9yIGEgc2ltaWxhciBmdW5jdGlvblxuICogQHBhcmFtIGdyb3VwT3JkZXIgc2l6ZSBvZiBzdWJncm91cCAtIChlLmcuIHNlY3AyNTZrMS5DVVJWRS5uKVxuICogQHBhcmFtIGlzTEUgaW50ZXJwcmV0IGhhc2ggYnl0ZXMgYXMgTEUgbnVtXG4gKiBAcmV0dXJucyB2YWxpZCBwcml2YXRlIHNjYWxhclxuICovXG5mdW5jdGlvbiBtYXBIYXNoVG9GaWVsZChrZXksIGZpZWxkT3JkZXIsIGlzTEUgPSBmYWxzZSkge1xuICAgIGNvbnN0IGxlbiA9IGtleS5sZW5ndGg7XG4gICAgY29uc3QgZmllbGRMZW4gPSBnZXRGaWVsZEJ5dGVzTGVuZ3RoKGZpZWxkT3JkZXIpO1xuICAgIGNvbnN0IG1pbkxlbiA9IGdldE1pbkhhc2hMZW5ndGgoZmllbGRPcmRlcik7XG4gICAgLy8gTm8gc21hbGwgbnVtYmVyczogbmVlZCB0byB1bmRlcnN0YW5kIGJpYXMgc3RvcnkuIE5vIGh1Z2UgbnVtYmVyczogZWFzaWVyIHRvIGRldGVjdCBKUyB0aW1pbmdzLlxuICAgIGlmIChsZW4gPCAxNiB8fCBsZW4gPCBtaW5MZW4gfHwgbGVuID4gMTAyNClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBlY3RlZCAnICsgbWluTGVuICsgJy0xMDI0IGJ5dGVzIG9mIGlucHV0LCBnb3QgJyArIGxlbik7XG4gICAgY29uc3QgbnVtID0gaXNMRSA/ICgwLCB1dGlsc190c18xLmJ5dGVzVG9OdW1iZXJMRSkoa2V5KSA6ICgwLCB1dGlsc190c18xLmJ5dGVzVG9OdW1iZXJCRSkoa2V5KTtcbiAgICAvLyBgbW9kKHgsIDExKWAgY2FuIHNvbWV0aW1lcyBwcm9kdWNlIDAuIGBtb2QoeCwgMTApICsgMWAgaXMgdGhlIHNhbWUsIGJ1dCBubyAwXG4gICAgY29uc3QgcmVkdWNlZCA9IG1vZChudW0sIGZpZWxkT3JkZXIgLSBfMW4pICsgXzFuO1xuICAgIHJldHVybiBpc0xFID8gKDAsIHV0aWxzX3RzXzEubnVtYmVyVG9CeXRlc0xFKShyZWR1Y2VkLCBmaWVsZExlbikgOiAoMCwgdXRpbHNfdHNfMS5udW1iZXJUb0J5dGVzQkUpKHJlZHVjZWQsIGZpZWxkTGVuKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZHVsYXIuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiaXNOZWdhdGl2ZUxFIiwibW9kIiwicG93IiwicG93MiIsImludmVydCIsInRvbmVsbGlTaGFua3MiLCJGcFNxcnQiLCJ2YWxpZGF0ZUZpZWxkIiwiRnBQb3ciLCJGcEludmVydEJhdGNoIiwiRnBEaXYiLCJGcExlZ2VuZHJlIiwiRnBJc1NxdWFyZSIsIm5MZW5ndGgiLCJGaWVsZCIsIkZwU3FydE9kZCIsIkZwU3FydEV2ZW4iLCJoYXNoVG9Qcml2YXRlU2NhbGFyIiwiZ2V0RmllbGRCeXRlc0xlbmd0aCIsImdldE1pbkhhc2hMZW5ndGgiLCJtYXBIYXNoVG9GaWVsZCIsInV0aWxzXzEiLCJyZXF1aXJlIiwidXRpbHNfdHNfMSIsIl8wbiIsIkJpZ0ludCIsIl8xbiIsIl8ybiIsIl8zbiIsIl80biIsIl81biIsIl84biIsImEiLCJiIiwicmVzdWx0IiwibnVtIiwicG93ZXIiLCJtb2R1bG8iLCJ4IiwicmVzIiwibnVtYmVyIiwiRXJyb3IiLCJ5IiwidSIsInYiLCJxIiwiciIsIm0iLCJuIiwiZ2NkIiwic3FydDNtb2Q0IiwiRnAiLCJwMWRpdjQiLCJPUkRFUiIsInJvb3QiLCJlcWwiLCJzcXIiLCJzcXJ0NW1vZDgiLCJwNWRpdjgiLCJuMiIsIm11bCIsIm52IiwiaSIsInN1YiIsIk9ORSIsIlAiLCJRIiwiUyIsIloiLCJfRnAiLCJjYyIsIlExZGl2MiIsInRvbmVsbGlTbG93IiwiaXMwIiwiTSIsImMiLCJ0IiwiUiIsIlpFUk8iLCJ0X3RtcCIsImV4cG9uZW50IiwiRklFTERfRklFTERTIiwiZmllbGQiLCJpbml0aWFsIiwiTUFTSyIsIkJZVEVTIiwiQklUUyIsIm9wdHMiLCJyZWR1Y2UiLCJtYXAiLCJ2YWwiLCJ2YWxpZGF0ZU9iamVjdCIsInAiLCJkIiwibnVtcyIsInBhc3NaZXJvIiwiaW52ZXJ0ZWQiLCJBcnJheSIsImxlbmd0aCIsImZpbGwiLCJ1bmRlZmluZWQiLCJtdWx0aXBsaWVkQWNjIiwiYWNjIiwiaW52ZXJ0ZWRBY2MiLCJpbnYiLCJyZWR1Y2VSaWdodCIsImxocyIsInJocyIsInAxbW9kMiIsInBvd2VyZWQiLCJ5ZXMiLCJ6ZXJvIiwibm8iLCJuZWciLCJsIiwibkJpdExlbmd0aCIsImFudW1iZXIiLCJfbkJpdExlbmd0aCIsInRvU3RyaW5nIiwibkJ5dGVMZW5ndGgiLCJNYXRoIiwiY2VpbCIsImJpdExlbiIsImlzTEUiLCJyZWRlZiIsInNxcnRQIiwiZiIsImZyZWV6ZSIsImJpdE1hc2siLCJjcmVhdGUiLCJpc1ZhbGlkIiwiaXNPZGQiLCJhZGQiLCJkaXYiLCJzcXJOIiwiYWRkTiIsInN1Yk4iLCJtdWxOIiwic3FydCIsInRvQnl0ZXMiLCJudW1iZXJUb0J5dGVzTEUiLCJudW1iZXJUb0J5dGVzQkUiLCJmcm9tQnl0ZXMiLCJieXRlcyIsImJ5dGVzVG9OdW1iZXJMRSIsImJ5dGVzVG9OdW1iZXJCRSIsImludmVydEJhdGNoIiwibHN0IiwiY21vdiIsImVsbSIsImhhc2giLCJncm91cE9yZGVyIiwiZW5zdXJlQnl0ZXMiLCJoYXNoTGVuIiwibWluTGVuIiwiZmllbGRPcmRlciIsImJpdExlbmd0aCIsImtleSIsImxlbiIsImZpZWxkTGVuIiwicmVkdWNlZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@noble/curves/abstract/modular.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@noble/curves/abstract/utils.js":
/*!******************************************************!*\
  !*** ./node_modules/@noble/curves/abstract/utils.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/**\n * Hex, bytes and number utilities.\n * @module\n */ /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.notImplemented = exports.bitMask = void 0;\nexports.isBytes = isBytes;\nexports.abytes = abytes;\nexports.abool = abool;\nexports.numberToHexUnpadded = numberToHexUnpadded;\nexports.hexToNumber = hexToNumber;\nexports.bytesToHex = bytesToHex;\nexports.hexToBytes = hexToBytes;\nexports.bytesToNumberBE = bytesToNumberBE;\nexports.bytesToNumberLE = bytesToNumberLE;\nexports.numberToBytesBE = numberToBytesBE;\nexports.numberToBytesLE = numberToBytesLE;\nexports.numberToVarBytesBE = numberToVarBytesBE;\nexports.ensureBytes = ensureBytes;\nexports.concatBytes = concatBytes;\nexports.equalBytes = equalBytes;\nexports.utf8ToBytes = utf8ToBytes;\nexports.inRange = inRange;\nexports.aInRange = aInRange;\nexports.bitLen = bitLen;\nexports.bitGet = bitGet;\nexports.bitSet = bitSet;\nexports.createHmacDrbg = createHmacDrbg;\nexports.validateObject = validateObject;\nexports.memoized = memoized;\n// 100 lines of code in the file are duplicated from noble-hashes (utils).\n// This is OK: `abstract` directory does not use noble-hashes.\n// User may opt-in into using different hashing library. This way, noble-hashes\n// won't be included into their bundle.\nconst _0n = /* @__PURE__ */ BigInt(0);\nconst _1n = /* @__PURE__ */ BigInt(1);\nfunction isBytes(a) {\n    return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === \"Uint8Array\";\n}\nfunction abytes(item) {\n    if (!isBytes(item)) throw new Error(\"Uint8Array expected\");\n}\nfunction abool(title, value) {\n    if (typeof value !== \"boolean\") throw new Error(title + \" boolean expected, got \" + value);\n}\n// Used in weierstrass, der\nfunction numberToHexUnpadded(num) {\n    const hex = num.toString(16);\n    return hex.length & 1 ? \"0\" + hex : hex;\n}\nfunction hexToNumber(hex) {\n    if (typeof hex !== \"string\") throw new Error(\"hex string expected, got \" + typeof hex);\n    return hex === \"\" ? _0n : BigInt(\"0x\" + hex); // Big Endian\n}\n// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex\nconst hasHexBuiltin = // @ts-ignore\ntypeof Uint8Array.from([]).toHex === \"function\" && typeof Uint8Array.fromHex === \"function\";\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({\n    length: 256\n}, (_, i)=>i.toString(16).padStart(2, \"0\"));\n/**\n * Convert byte array to hex string. Uses built-in function, when available.\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */ function bytesToHex(bytes) {\n    abytes(bytes);\n    // @ts-ignore\n    if (hasHexBuiltin) return bytes.toHex();\n    // pre-caching improves the speed 6x\n    let hex = \"\";\n    for(let i = 0; i < bytes.length; i++){\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = {\n    _0: 48,\n    _9: 57,\n    A: 65,\n    F: 70,\n    a: 97,\n    f: 102\n};\nfunction asciiToBase16(ch) {\n    if (ch >= asciis._0 && ch <= asciis._9) return ch - asciis._0; // '2' => 50-48\n    if (ch >= asciis.A && ch <= asciis.F) return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n    if (ch >= asciis.a && ch <= asciis.f) return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n    return;\n}\n/**\n * Convert hex string to byte array. Uses built-in function, when available.\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */ function hexToBytes(hex) {\n    if (typeof hex !== \"string\") throw new Error(\"hex string expected, got \" + typeof hex);\n    // @ts-ignore\n    if (hasHexBuiltin) return Uint8Array.fromHex(hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2) throw new Error(\"hex string expected, got unpadded hex of length \" + hl);\n    const array = new Uint8Array(al);\n    for(let ai = 0, hi = 0; ai < al; ai++, hi += 2){\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n    }\n    return array;\n}\n// BE: Big Endian, LE: Little Endian\nfunction bytesToNumberBE(bytes) {\n    return hexToNumber(bytesToHex(bytes));\n}\nfunction bytesToNumberLE(bytes) {\n    abytes(bytes);\n    return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));\n}\nfunction numberToBytesBE(n, len) {\n    return hexToBytes(n.toString(16).padStart(len * 2, \"0\"));\n}\nfunction numberToBytesLE(n, len) {\n    return numberToBytesBE(n, len).reverse();\n}\n// Unpadded, rarely used\nfunction numberToVarBytesBE(n) {\n    return hexToBytes(numberToHexUnpadded(n));\n}\n/**\n * Takes hex string or Uint8Array, converts to Uint8Array.\n * Validates output length.\n * Will throw error for other types.\n * @param title descriptive title for an error e.g. 'private key'\n * @param hex hex string or Uint8Array\n * @param expectedLength optional, will compare to result array's length\n * @returns\n */ function ensureBytes(title, hex, expectedLength) {\n    let res;\n    if (typeof hex === \"string\") {\n        try {\n            res = hexToBytes(hex);\n        } catch (e) {\n            throw new Error(title + \" must be hex string or Uint8Array, cause: \" + e);\n        }\n    } else if (isBytes(hex)) {\n        // Uint8Array.from() instead of hash.slice() because node.js Buffer\n        // is instance of Uint8Array, and its slice() creates **mutable** copy\n        res = Uint8Array.from(hex);\n    } else {\n        throw new Error(title + \" must be hex string or Uint8Array\");\n    }\n    const len = res.length;\n    if (typeof expectedLength === \"number\" && len !== expectedLength) throw new Error(title + \" of length \" + expectedLength + \" expected, got \" + len);\n    return res;\n}\n/**\n * Copies several Uint8Arrays into one.\n */ function concatBytes(...arrays) {\n    let sum = 0;\n    for(let i = 0; i < arrays.length; i++){\n        const a = arrays[i];\n        abytes(a);\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for(let i = 0, pad = 0; i < arrays.length; i++){\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\n// Compares 2 u8a-s in kinda constant time\nfunction equalBytes(a, b) {\n    if (a.length !== b.length) return false;\n    let diff = 0;\n    for(let i = 0; i < a.length; i++)diff |= a[i] ^ b[i];\n    return diff === 0;\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */ function utf8ToBytes(str) {\n    if (typeof str !== \"string\") throw new Error(\"string expected\");\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n// Is positive bigint\nconst isPosBig = (n)=>typeof n === \"bigint\" && _0n <= n;\nfunction inRange(n, min, max) {\n    return isPosBig(n) && isPosBig(min) && isPosBig(max) && min <= n && n < max;\n}\n/**\n * Asserts min <= n < max. NOTE: It's < max and not <= max.\n * @example\n * aInRange('x', x, 1n, 256n); // would assume x is in (1n..255n)\n */ function aInRange(title, n, min, max) {\n    // Why min <= n < max and not a (min < n < max) OR b (min <= n <= max)?\n    // consider P=256n, min=0n, max=P\n    // - a for min=0 would require -1:          `inRange('x', x, -1n, P)`\n    // - b would commonly require subtraction:  `inRange('x', x, 0n, P - 1n)`\n    // - our way is the cleanest:               `inRange('x', x, 0n, P)\n    if (!inRange(n, min, max)) throw new Error(\"expected valid \" + title + \": \" + min + \" <= n < \" + max + \", got \" + n);\n}\n// Bit operations\n/**\n * Calculates amount of bits in a bigint.\n * Same as `n.toString(2).length`\n * TODO: merge with nLength in modular\n */ function bitLen(n) {\n    let len;\n    for(len = 0; n > _0n; n >>= _1n, len += 1);\n    return len;\n}\n/**\n * Gets single bit at position.\n * NOTE: first bit position is 0 (same as arrays)\n * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`\n */ function bitGet(n, pos) {\n    return n >> BigInt(pos) & _1n;\n}\n/**\n * Sets single bit at position.\n */ function bitSet(n, pos, value) {\n    return n | (value ? _1n : _0n) << BigInt(pos);\n}\n/**\n * Calculate mask for N bits. Not using ** operator with bigints because of old engines.\n * Same as BigInt(`0b${Array(i).fill('1').join('')}`)\n */ const bitMask = (n)=>(_1n << BigInt(n)) - _1n;\nexports.bitMask = bitMask;\n// DRBG\nconst u8n = (len)=>new Uint8Array(len); // creates Uint8Array\nconst u8fr = (arr)=>Uint8Array.from(arr); // another shortcut\n/**\n * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n * @returns function that will call DRBG until 2nd arg returns something meaningful\n * @example\n *   const drbg = createHmacDRBG<Key>(32, 32, hmac);\n *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined\n */ function createHmacDrbg(hashLen, qByteLen, hmacFn) {\n    if (typeof hashLen !== \"number\" || hashLen < 2) throw new Error(\"hashLen must be a number\");\n    if (typeof qByteLen !== \"number\" || qByteLen < 2) throw new Error(\"qByteLen must be a number\");\n    if (typeof hmacFn !== \"function\") throw new Error(\"hmacFn must be a function\");\n    // Step B, Step C: set hashLen to 8*ceil(hlen/8)\n    let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n    let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same\n    let i = 0; // Iterations counter, will throw when over 1000\n    const reset = ()=>{\n        v.fill(1);\n        k.fill(0);\n        i = 0;\n    };\n    const h = (...b)=>hmacFn(k, v, ...b); // hmac(k)(v, ...values)\n    const reseed = (seed = u8n(0))=>{\n        // HMAC-DRBG reseed() function. Steps D-G\n        k = h(u8fr([\n            0x00\n        ]), seed); // k = hmac(k || v || 0x00 || seed)\n        v = h(); // v = hmac(k || v)\n        if (seed.length === 0) return;\n        k = h(u8fr([\n            0x01\n        ]), seed); // k = hmac(k || v || 0x01 || seed)\n        v = h(); // v = hmac(k || v)\n    };\n    const gen = ()=>{\n        // HMAC-DRBG generate() function\n        if (i++ >= 1000) throw new Error(\"drbg: tried 1000 values\");\n        let len = 0;\n        const out = [];\n        while(len < qByteLen){\n            v = h();\n            const sl = v.slice();\n            out.push(sl);\n            len += v.length;\n        }\n        return concatBytes(...out);\n    };\n    const genUntil = (seed, pred)=>{\n        reset();\n        reseed(seed); // Steps D-G\n        let res = undefined; // Step H: grind until k is in [1..n-1]\n        while(!(res = pred(gen())))reseed();\n        reset();\n        return res;\n    };\n    return genUntil;\n}\n// Validating curves and fields\nconst validatorFns = {\n    bigint: (val)=>typeof val === \"bigint\",\n    function: (val)=>typeof val === \"function\",\n    boolean: (val)=>typeof val === \"boolean\",\n    string: (val)=>typeof val === \"string\",\n    stringOrUint8Array: (val)=>typeof val === \"string\" || isBytes(val),\n    isSafeInteger: (val)=>Number.isSafeInteger(val),\n    array: (val)=>Array.isArray(val),\n    field: (val, object)=>object.Fp.isValid(val),\n    hash: (val)=>typeof val === \"function\" && Number.isSafeInteger(val.outputLen)\n};\n// type Record<K extends string | number | symbol, T> = { [P in K]: T; }\nfunction validateObject(object, validators, optValidators = {}) {\n    const checkField = (fieldName, type, isOptional)=>{\n        const checkVal = validatorFns[type];\n        if (typeof checkVal !== \"function\") throw new Error(\"invalid validator function\");\n        const val = object[fieldName];\n        if (isOptional && val === undefined) return;\n        if (!checkVal(val, object)) {\n            throw new Error(\"param \" + String(fieldName) + \" is invalid. Expected \" + type + \", got \" + val);\n        }\n    };\n    for (const [fieldName, type] of Object.entries(validators))checkField(fieldName, type, false);\n    for (const [fieldName, type] of Object.entries(optValidators))checkField(fieldName, type, true);\n    return object;\n}\n// validate type tests\n// const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };\n// const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!\n// // Should fail type-check\n// const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });\n// const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });\n// const z3 = validateObject(o, { test: 'boolean', z: 'bug' });\n// const z4 = validateObject(o, { a: 'boolean', z: 'bug' });\n/**\n * throws not implemented error\n */ const notImplemented = ()=>{\n    throw new Error(\"not implemented\");\n};\nexports.notImplemented = notImplemented;\n/**\n * Memoizes (caches) computation result.\n * Uses WeakMap: the value is going auto-cleaned by GC after last reference is removed.\n */ function memoized(fn) {\n    const map = new WeakMap();\n    return (arg, ...args)=>{\n        const val = map.get(arg);\n        if (val !== undefined) return val;\n        const computed = fn(arg, ...args);\n        map.set(arg, computed);\n        return computed;\n    };\n} //# sourceMappingURL=utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9hYnN0cmFjdC91dGlscy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiOzs7Q0FHQyxHQUNELG9FQUFvRSxHQUNwRUEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELHNCQUFzQixHQUFHQSxlQUFlLEdBQUcsS0FBSztBQUNoREEsZUFBZSxHQUFHSTtBQUNsQkosY0FBYyxHQUFHSztBQUNqQkwsYUFBYSxHQUFHTTtBQUNoQk4sMkJBQTJCLEdBQUdPO0FBQzlCUCxtQkFBbUIsR0FBR1E7QUFDdEJSLGtCQUFrQixHQUFHUztBQUNyQlQsa0JBQWtCLEdBQUdVO0FBQ3JCVix1QkFBdUIsR0FBR1c7QUFDMUJYLHVCQUF1QixHQUFHWTtBQUMxQlosdUJBQXVCLEdBQUdhO0FBQzFCYix1QkFBdUIsR0FBR2M7QUFDMUJkLDBCQUEwQixHQUFHZTtBQUM3QmYsbUJBQW1CLEdBQUdnQjtBQUN0QmhCLG1CQUFtQixHQUFHaUI7QUFDdEJqQixrQkFBa0IsR0FBR2tCO0FBQ3JCbEIsbUJBQW1CLEdBQUdtQjtBQUN0Qm5CLGVBQWUsR0FBR29CO0FBQ2xCcEIsZ0JBQWdCLEdBQUdxQjtBQUNuQnJCLGNBQWMsR0FBR3NCO0FBQ2pCdEIsY0FBYyxHQUFHdUI7QUFDakJ2QixjQUFjLEdBQUd3QjtBQUNqQnhCLHNCQUFzQixHQUFHeUI7QUFDekJ6QixzQkFBc0IsR0FBRzBCO0FBQ3pCMUIsZ0JBQWdCLEdBQUcyQjtBQUNuQiwwRUFBMEU7QUFDMUUsOERBQThEO0FBQzlELCtFQUErRTtBQUMvRSx1Q0FBdUM7QUFDdkMsTUFBTUMsTUFBTSxhQUFhLEdBQUdDLE9BQU87QUFDbkMsTUFBTUMsTUFBTSxhQUFhLEdBQUdELE9BQU87QUFDbkMsU0FBU3pCLFFBQVEyQixDQUFDO0lBQ2QsT0FBT0EsYUFBYUMsY0FBZUMsWUFBWUMsTUFBTSxDQUFDSCxNQUFNQSxFQUFFSSxXQUFXLENBQUNDLElBQUksS0FBSztBQUN2RjtBQUNBLFNBQVMvQixPQUFPZ0MsSUFBSTtJQUNoQixJQUFJLENBQUNqQyxRQUFRaUMsT0FDVCxNQUFNLElBQUlDLE1BQU07QUFDeEI7QUFDQSxTQUFTaEMsTUFBTWlDLEtBQUssRUFBRXRDLEtBQUs7SUFDdkIsSUFBSSxPQUFPQSxVQUFVLFdBQ2pCLE1BQU0sSUFBSXFDLE1BQU1DLFFBQVEsNEJBQTRCdEM7QUFDNUQ7QUFDQSwyQkFBMkI7QUFDM0IsU0FBU00sb0JBQW9CaUMsR0FBRztJQUM1QixNQUFNQyxNQUFNRCxJQUFJRSxRQUFRLENBQUM7SUFDekIsT0FBT0QsSUFBSUUsTUFBTSxHQUFHLElBQUksTUFBTUYsTUFBTUE7QUFDeEM7QUFDQSxTQUFTakMsWUFBWWlDLEdBQUc7SUFDcEIsSUFBSSxPQUFPQSxRQUFRLFVBQ2YsTUFBTSxJQUFJSCxNQUFNLDhCQUE4QixPQUFPRztJQUN6RCxPQUFPQSxRQUFRLEtBQUtiLE1BQU1DLE9BQU8sT0FBT1ksTUFBTSxhQUFhO0FBQy9EO0FBQ0EseUZBQXlGO0FBQ3pGLE1BQU1HLGdCQUNOLGFBQWE7QUFDYixPQUFPWixXQUFXYSxJQUFJLENBQUMsRUFBRSxFQUFFQyxLQUFLLEtBQUssY0FBYyxPQUFPZCxXQUFXZSxPQUFPLEtBQUs7QUFDakYsd0RBQXdEO0FBQ3hELE1BQU1DLFFBQVEsYUFBYSxHQUFHQyxNQUFNSixJQUFJLENBQUM7SUFBRUYsUUFBUTtBQUFJLEdBQUcsQ0FBQ08sR0FBR0MsSUFBTUEsRUFBRVQsUUFBUSxDQUFDLElBQUlVLFFBQVEsQ0FBQyxHQUFHO0FBQy9GOzs7Q0FHQyxHQUNELFNBQVMzQyxXQUFXNEMsS0FBSztJQUNyQmhELE9BQU9nRDtJQUNQLGFBQWE7SUFDYixJQUFJVCxlQUNBLE9BQU9TLE1BQU1QLEtBQUs7SUFDdEIsb0NBQW9DO0lBQ3BDLElBQUlMLE1BQU07SUFDVixJQUFLLElBQUlVLElBQUksR0FBR0EsSUFBSUUsTUFBTVYsTUFBTSxFQUFFUSxJQUFLO1FBQ25DVixPQUFPTyxLQUFLLENBQUNLLEtBQUssQ0FBQ0YsRUFBRSxDQUFDO0lBQzFCO0lBQ0EsT0FBT1Y7QUFDWDtBQUNBLGlFQUFpRTtBQUNqRSxNQUFNYSxTQUFTO0lBQUVDLElBQUk7SUFBSUMsSUFBSTtJQUFJQyxHQUFHO0lBQUlDLEdBQUc7SUFBSTNCLEdBQUc7SUFBSTRCLEdBQUc7QUFBSTtBQUM3RCxTQUFTQyxjQUFjQyxFQUFFO0lBQ3JCLElBQUlBLE1BQU1QLE9BQU9DLEVBQUUsSUFBSU0sTUFBTVAsT0FBT0UsRUFBRSxFQUNsQyxPQUFPSyxLQUFLUCxPQUFPQyxFQUFFLEVBQUUsZUFBZTtJQUMxQyxJQUFJTSxNQUFNUCxPQUFPRyxDQUFDLElBQUlJLE1BQU1QLE9BQU9JLENBQUMsRUFDaEMsT0FBT0csS0FBTVAsQ0FBQUEsT0FBT0csQ0FBQyxHQUFHLEVBQUMsR0FBSSxvQkFBb0I7SUFDckQsSUFBSUksTUFBTVAsT0FBT3ZCLENBQUMsSUFBSThCLE1BQU1QLE9BQU9LLENBQUMsRUFDaEMsT0FBT0UsS0FBTVAsQ0FBQUEsT0FBT3ZCLENBQUMsR0FBRyxFQUFDLEdBQUksb0JBQW9CO0lBQ3JEO0FBQ0o7QUFDQTs7O0NBR0MsR0FDRCxTQUFTckIsV0FBVytCLEdBQUc7SUFDbkIsSUFBSSxPQUFPQSxRQUFRLFVBQ2YsTUFBTSxJQUFJSCxNQUFNLDhCQUE4QixPQUFPRztJQUN6RCxhQUFhO0lBQ2IsSUFBSUcsZUFDQSxPQUFPWixXQUFXZSxPQUFPLENBQUNOO0lBQzlCLE1BQU1xQixLQUFLckIsSUFBSUUsTUFBTTtJQUNyQixNQUFNb0IsS0FBS0QsS0FBSztJQUNoQixJQUFJQSxLQUFLLEdBQ0wsTUFBTSxJQUFJeEIsTUFBTSxxREFBcUR3QjtJQUN6RSxNQUFNRSxRQUFRLElBQUloQyxXQUFXK0I7SUFDN0IsSUFBSyxJQUFJRSxLQUFLLEdBQUdDLEtBQUssR0FBR0QsS0FBS0YsSUFBSUUsTUFBTUMsTUFBTSxFQUFHO1FBQzdDLE1BQU1DLEtBQUtQLGNBQWNuQixJQUFJMkIsVUFBVSxDQUFDRjtRQUN4QyxNQUFNRyxLQUFLVCxjQUFjbkIsSUFBSTJCLFVBQVUsQ0FBQ0YsS0FBSztRQUM3QyxJQUFJQyxPQUFPRyxhQUFhRCxPQUFPQyxXQUFXO1lBQ3RDLE1BQU1DLE9BQU85QixHQUFHLENBQUN5QixHQUFHLEdBQUd6QixHQUFHLENBQUN5QixLQUFLLEVBQUU7WUFDbEMsTUFBTSxJQUFJNUIsTUFBTSxpREFBaURpQyxPQUFPLGdCQUFnQkw7UUFDNUY7UUFDQUYsS0FBSyxDQUFDQyxHQUFHLEdBQUdFLEtBQUssS0FBS0UsSUFBSSwrREFBK0Q7SUFDN0Y7SUFDQSxPQUFPTDtBQUNYO0FBQ0Esb0NBQW9DO0FBQ3BDLFNBQVNyRCxnQkFBZ0IwQyxLQUFLO0lBQzFCLE9BQU83QyxZQUFZQyxXQUFXNEM7QUFDbEM7QUFDQSxTQUFTekMsZ0JBQWdCeUMsS0FBSztJQUMxQmhELE9BQU9nRDtJQUNQLE9BQU83QyxZQUFZQyxXQUFXdUIsV0FBV2EsSUFBSSxDQUFDUSxPQUFPbUIsT0FBTztBQUNoRTtBQUNBLFNBQVMzRCxnQkFBZ0I0RCxDQUFDLEVBQUVDLEdBQUc7SUFDM0IsT0FBT2hFLFdBQVcrRCxFQUFFL0IsUUFBUSxDQUFDLElBQUlVLFFBQVEsQ0FBQ3NCLE1BQU0sR0FBRztBQUN2RDtBQUNBLFNBQVM1RCxnQkFBZ0IyRCxDQUFDLEVBQUVDLEdBQUc7SUFDM0IsT0FBTzdELGdCQUFnQjRELEdBQUdDLEtBQUtGLE9BQU87QUFDMUM7QUFDQSx3QkFBd0I7QUFDeEIsU0FBU3pELG1CQUFtQjBELENBQUM7SUFDekIsT0FBTy9ELFdBQVdILG9CQUFvQmtFO0FBQzFDO0FBQ0E7Ozs7Ozs7O0NBUUMsR0FDRCxTQUFTekQsWUFBWXVCLEtBQUssRUFBRUUsR0FBRyxFQUFFa0MsY0FBYztJQUMzQyxJQUFJQztJQUNKLElBQUksT0FBT25DLFFBQVEsVUFBVTtRQUN6QixJQUFJO1lBQ0FtQyxNQUFNbEUsV0FBVytCO1FBQ3JCLEVBQ0EsT0FBT29DLEdBQUc7WUFDTixNQUFNLElBQUl2QyxNQUFNQyxRQUFRLCtDQUErQ3NDO1FBQzNFO0lBQ0osT0FDSyxJQUFJekUsUUFBUXFDLE1BQU07UUFDbkIsbUVBQW1FO1FBQ25FLHNFQUFzRTtRQUN0RW1DLE1BQU01QyxXQUFXYSxJQUFJLENBQUNKO0lBQzFCLE9BQ0s7UUFDRCxNQUFNLElBQUlILE1BQU1DLFFBQVE7SUFDNUI7SUFDQSxNQUFNbUMsTUFBTUUsSUFBSWpDLE1BQU07SUFDdEIsSUFBSSxPQUFPZ0MsbUJBQW1CLFlBQVlELFFBQVFDLGdCQUM5QyxNQUFNLElBQUlyQyxNQUFNQyxRQUFRLGdCQUFnQm9DLGlCQUFpQixvQkFBb0JEO0lBQ2pGLE9BQU9FO0FBQ1g7QUFDQTs7Q0FFQyxHQUNELFNBQVMzRCxZQUFZLEdBQUc2RCxNQUFNO0lBQzFCLElBQUlDLE1BQU07SUFDVixJQUFLLElBQUk1QixJQUFJLEdBQUdBLElBQUkyQixPQUFPbkMsTUFBTSxFQUFFUSxJQUFLO1FBQ3BDLE1BQU1wQixJQUFJK0MsTUFBTSxDQUFDM0IsRUFBRTtRQUNuQjlDLE9BQU8wQjtRQUNQZ0QsT0FBT2hELEVBQUVZLE1BQU07SUFDbkI7SUFDQSxNQUFNaUMsTUFBTSxJQUFJNUMsV0FBVytDO0lBQzNCLElBQUssSUFBSTVCLElBQUksR0FBRzZCLE1BQU0sR0FBRzdCLElBQUkyQixPQUFPbkMsTUFBTSxFQUFFUSxJQUFLO1FBQzdDLE1BQU1wQixJQUFJK0MsTUFBTSxDQUFDM0IsRUFBRTtRQUNuQnlCLElBQUlLLEdBQUcsQ0FBQ2xELEdBQUdpRDtRQUNYQSxPQUFPakQsRUFBRVksTUFBTTtJQUNuQjtJQUNBLE9BQU9pQztBQUNYO0FBQ0EsMENBQTBDO0FBQzFDLFNBQVMxRCxXQUFXYSxDQUFDLEVBQUVtRCxDQUFDO0lBQ3BCLElBQUluRCxFQUFFWSxNQUFNLEtBQUt1QyxFQUFFdkMsTUFBTSxFQUNyQixPQUFPO0lBQ1gsSUFBSXdDLE9BQU87SUFDWCxJQUFLLElBQUloQyxJQUFJLEdBQUdBLElBQUlwQixFQUFFWSxNQUFNLEVBQUVRLElBQzFCZ0MsUUFBUXBELENBQUMsQ0FBQ29CLEVBQUUsR0FBRytCLENBQUMsQ0FBQy9CLEVBQUU7SUFDdkIsT0FBT2dDLFNBQVM7QUFDcEI7QUFDQTs7Q0FFQyxHQUNELFNBQVNoRSxZQUFZaUUsR0FBRztJQUNwQixJQUFJLE9BQU9BLFFBQVEsVUFDZixNQUFNLElBQUk5QyxNQUFNO0lBQ3BCLE9BQU8sSUFBSU4sV0FBVyxJQUFJcUQsY0FBY0MsTUFBTSxDQUFDRixPQUFPLDRCQUE0QjtBQUN0RjtBQUNBLHFCQUFxQjtBQUNyQixNQUFNRyxXQUFXLENBQUNkLElBQU0sT0FBT0EsTUFBTSxZQUFZN0MsT0FBTzZDO0FBQ3hELFNBQVNyRCxRQUFRcUQsQ0FBQyxFQUFFZSxHQUFHLEVBQUVDLEdBQUc7SUFDeEIsT0FBT0YsU0FBU2QsTUFBTWMsU0FBU0MsUUFBUUQsU0FBU0UsUUFBUUQsT0FBT2YsS0FBS0EsSUFBSWdCO0FBQzVFO0FBQ0E7Ozs7Q0FJQyxHQUNELFNBQVNwRSxTQUFTa0IsS0FBSyxFQUFFa0MsQ0FBQyxFQUFFZSxHQUFHLEVBQUVDLEdBQUc7SUFDaEMsdUVBQXVFO0lBQ3ZFLGlDQUFpQztJQUNqQyxxRUFBcUU7SUFDckUseUVBQXlFO0lBQ3pFLG1FQUFtRTtJQUNuRSxJQUFJLENBQUNyRSxRQUFRcUQsR0FBR2UsS0FBS0MsTUFDakIsTUFBTSxJQUFJbkQsTUFBTSxvQkFBb0JDLFFBQVEsT0FBT2lELE1BQU0sYUFBYUMsTUFBTSxXQUFXaEI7QUFDL0Y7QUFDQSxpQkFBaUI7QUFDakI7Ozs7Q0FJQyxHQUNELFNBQVNuRCxPQUFPbUQsQ0FBQztJQUNiLElBQUlDO0lBQ0osSUFBS0EsTUFBTSxHQUFHRCxJQUFJN0MsS0FBSzZDLE1BQU0zQyxLQUFLNEMsT0FBTztJQUV6QyxPQUFPQTtBQUNYO0FBQ0E7Ozs7Q0FJQyxHQUNELFNBQVNuRCxPQUFPa0QsQ0FBQyxFQUFFaUIsR0FBRztJQUNsQixPQUFPLEtBQU03RCxPQUFPNkQsT0FBUTVEO0FBQ2hDO0FBQ0E7O0NBRUMsR0FDRCxTQUFTTixPQUFPaUQsQ0FBQyxFQUFFaUIsR0FBRyxFQUFFekYsS0FBSztJQUN6QixPQUFPd0UsSUFBSyxDQUFDeEUsUUFBUTZCLE1BQU1GLEdBQUUsS0FBTUMsT0FBTzZEO0FBQzlDO0FBQ0E7OztDQUdDLEdBQ0QsTUFBTXZGLFVBQVUsQ0FBQ3NFLElBQU0sQ0FBQzNDLE9BQU9ELE9BQU80QyxFQUFDLElBQUszQztBQUM1QzlCLGVBQWUsR0FBR0c7QUFDbEIsT0FBTztBQUNQLE1BQU13RixNQUFNLENBQUNqQixNQUFRLElBQUkxQyxXQUFXMEMsTUFBTSxxQkFBcUI7QUFDL0QsTUFBTWtCLE9BQU8sQ0FBQ0MsTUFBUTdELFdBQVdhLElBQUksQ0FBQ2dELE1BQU0sbUJBQW1CO0FBQy9EOzs7Ozs7Q0FNQyxHQUNELFNBQVNwRSxlQUFlcUUsT0FBTyxFQUFFQyxRQUFRLEVBQUVDLE1BQU07SUFDN0MsSUFBSSxPQUFPRixZQUFZLFlBQVlBLFVBQVUsR0FDekMsTUFBTSxJQUFJeEQsTUFBTTtJQUNwQixJQUFJLE9BQU95RCxhQUFhLFlBQVlBLFdBQVcsR0FDM0MsTUFBTSxJQUFJekQsTUFBTTtJQUNwQixJQUFJLE9BQU8wRCxXQUFXLFlBQ2xCLE1BQU0sSUFBSTFELE1BQU07SUFDcEIsZ0RBQWdEO0lBQ2hELElBQUkyRCxJQUFJTixJQUFJRyxVQUFVLHFFQUFxRTtJQUMzRixJQUFJSSxJQUFJUCxJQUFJRyxVQUFVLHFFQUFxRTtJQUMzRixJQUFJM0MsSUFBSSxHQUFHLGdEQUFnRDtJQUMzRCxNQUFNZ0QsUUFBUTtRQUNWRixFQUFFRyxJQUFJLENBQUM7UUFDUEYsRUFBRUUsSUFBSSxDQUFDO1FBQ1BqRCxJQUFJO0lBQ1I7SUFDQSxNQUFNa0QsSUFBSSxDQUFDLEdBQUduQixJQUFNYyxPQUFPRSxHQUFHRCxNQUFNZixJQUFJLHdCQUF3QjtJQUNoRSxNQUFNb0IsU0FBUyxDQUFDQyxPQUFPWixJQUFJLEVBQUU7UUFDekIseUNBQXlDO1FBQ3pDTyxJQUFJRyxFQUFFVCxLQUFLO1lBQUM7U0FBSyxHQUFHVyxPQUFPLG1DQUFtQztRQUM5RE4sSUFBSUksS0FBSyxtQkFBbUI7UUFDNUIsSUFBSUUsS0FBSzVELE1BQU0sS0FBSyxHQUNoQjtRQUNKdUQsSUFBSUcsRUFBRVQsS0FBSztZQUFDO1NBQUssR0FBR1csT0FBTyxtQ0FBbUM7UUFDOUROLElBQUlJLEtBQUssbUJBQW1CO0lBQ2hDO0lBQ0EsTUFBTUcsTUFBTTtRQUNSLGdDQUFnQztRQUNoQyxJQUFJckQsT0FBTyxNQUNQLE1BQU0sSUFBSWIsTUFBTTtRQUNwQixJQUFJb0MsTUFBTTtRQUNWLE1BQU0rQixNQUFNLEVBQUU7UUFDZCxNQUFPL0IsTUFBTXFCLFNBQVU7WUFDbkJFLElBQUlJO1lBQ0osTUFBTUssS0FBS1QsRUFBRVUsS0FBSztZQUNsQkYsSUFBSUcsSUFBSSxDQUFDRjtZQUNUaEMsT0FBT3VCLEVBQUV0RCxNQUFNO1FBQ25CO1FBQ0EsT0FBTzFCLGVBQWV3RjtJQUMxQjtJQUNBLE1BQU1JLFdBQVcsQ0FBQ04sTUFBTU87UUFDcEJYO1FBQ0FHLE9BQU9DLE9BQU8sWUFBWTtRQUMxQixJQUFJM0IsTUFBTU4sV0FBVyx1Q0FBdUM7UUFDNUQsTUFBTyxDQUFFTSxDQUFBQSxNQUFNa0MsS0FBS04sTUFBSyxFQUNyQkY7UUFDSkg7UUFDQSxPQUFPdkI7SUFDWDtJQUNBLE9BQU9pQztBQUNYO0FBQ0EsK0JBQStCO0FBQy9CLE1BQU1FLGVBQWU7SUFDakJDLFFBQVEsQ0FBQ0MsTUFBUSxPQUFPQSxRQUFRO0lBQ2hDQyxVQUFVLENBQUNELE1BQVEsT0FBT0EsUUFBUTtJQUNsQ0UsU0FBUyxDQUFDRixNQUFRLE9BQU9BLFFBQVE7SUFDakNHLFFBQVEsQ0FBQ0gsTUFBUSxPQUFPQSxRQUFRO0lBQ2hDSSxvQkFBb0IsQ0FBQ0osTUFBUSxPQUFPQSxRQUFRLFlBQVk3RyxRQUFRNkc7SUFDaEVLLGVBQWUsQ0FBQ0wsTUFBUU0sT0FBT0QsYUFBYSxDQUFDTDtJQUM3Q2pELE9BQU8sQ0FBQ2lELE1BQVFoRSxNQUFNdUUsT0FBTyxDQUFDUDtJQUM5QlEsT0FBTyxDQUFDUixLQUFLUyxTQUFXQSxPQUFPQyxFQUFFLENBQUNDLE9BQU8sQ0FBQ1g7SUFDMUNZLE1BQU0sQ0FBQ1osTUFBUSxPQUFPQSxRQUFRLGNBQWNNLE9BQU9ELGFBQWEsQ0FBQ0wsSUFBSWEsU0FBUztBQUNsRjtBQUNBLHdFQUF3RTtBQUN4RSxTQUFTcEcsZUFBZWdHLE1BQU0sRUFBRUssVUFBVSxFQUFFQyxnQkFBZ0IsQ0FBQyxDQUFDO0lBQzFELE1BQU1DLGFBQWEsQ0FBQ0MsV0FBV0MsTUFBTUM7UUFDakMsTUFBTUMsV0FBV3RCLFlBQVksQ0FBQ29CLEtBQUs7UUFDbkMsSUFBSSxPQUFPRSxhQUFhLFlBQ3BCLE1BQU0sSUFBSS9GLE1BQU07UUFDcEIsTUFBTTJFLE1BQU1TLE1BQU0sQ0FBQ1EsVUFBVTtRQUM3QixJQUFJRSxjQUFjbkIsUUFBUTNDLFdBQ3RCO1FBQ0osSUFBSSxDQUFDK0QsU0FBU3BCLEtBQUtTLFNBQVM7WUFDeEIsTUFBTSxJQUFJcEYsTUFBTSxXQUFXZ0csT0FBT0osYUFBYSwyQkFBMkJDLE9BQU8sV0FBV2xCO1FBQ2hHO0lBQ0o7SUFDQSxLQUFLLE1BQU0sQ0FBQ2lCLFdBQVdDLEtBQUssSUFBSXJJLE9BQU95SSxPQUFPLENBQUNSLFlBQzNDRSxXQUFXQyxXQUFXQyxNQUFNO0lBQ2hDLEtBQUssTUFBTSxDQUFDRCxXQUFXQyxLQUFLLElBQUlySSxPQUFPeUksT0FBTyxDQUFDUCxlQUMzQ0MsV0FBV0MsV0FBV0MsTUFBTTtJQUNoQyxPQUFPVDtBQUNYO0FBQ0Esc0JBQXNCO0FBQ3RCLHVFQUF1RTtBQUN2RSxnRkFBZ0Y7QUFDaEYsNEJBQTRCO0FBQzVCLDJEQUEyRDtBQUMzRCxxRUFBcUU7QUFDckUsK0RBQStEO0FBQy9ELDREQUE0RDtBQUM1RDs7Q0FFQyxHQUNELE1BQU14SCxpQkFBaUI7SUFDbkIsTUFBTSxJQUFJb0MsTUFBTTtBQUNwQjtBQUNBdEMsc0JBQXNCLEdBQUdFO0FBQ3pCOzs7Q0FHQyxHQUNELFNBQVN5QixTQUFTNkcsRUFBRTtJQUNoQixNQUFNQyxNQUFNLElBQUlDO0lBQ2hCLE9BQU8sQ0FBQ0MsS0FBSyxHQUFHQztRQUNaLE1BQU0zQixNQUFNd0IsSUFBSUksR0FBRyxDQUFDRjtRQUNwQixJQUFJMUIsUUFBUTNDLFdBQ1IsT0FBTzJDO1FBQ1gsTUFBTTZCLFdBQVdOLEdBQUdHLFFBQVFDO1FBQzVCSCxJQUFJeEQsR0FBRyxDQUFDMEQsS0FBS0c7UUFDYixPQUFPQTtJQUNYO0FBQ0osRUFDQSxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mYXJjYXN0ZXJzdGF0cy8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2Fic3RyYWN0L3V0aWxzLmpzP2M3ZDIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEhleCwgYnl0ZXMgYW5kIG51bWJlciB1dGlsaXRpZXMuXG4gKiBAbW9kdWxlXG4gKi9cbi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMubm90SW1wbGVtZW50ZWQgPSBleHBvcnRzLmJpdE1hc2sgPSB2b2lkIDA7XG5leHBvcnRzLmlzQnl0ZXMgPSBpc0J5dGVzO1xuZXhwb3J0cy5hYnl0ZXMgPSBhYnl0ZXM7XG5leHBvcnRzLmFib29sID0gYWJvb2w7XG5leHBvcnRzLm51bWJlclRvSGV4VW5wYWRkZWQgPSBudW1iZXJUb0hleFVucGFkZGVkO1xuZXhwb3J0cy5oZXhUb051bWJlciA9IGhleFRvTnVtYmVyO1xuZXhwb3J0cy5ieXRlc1RvSGV4ID0gYnl0ZXNUb0hleDtcbmV4cG9ydHMuaGV4VG9CeXRlcyA9IGhleFRvQnl0ZXM7XG5leHBvcnRzLmJ5dGVzVG9OdW1iZXJCRSA9IGJ5dGVzVG9OdW1iZXJCRTtcbmV4cG9ydHMuYnl0ZXNUb051bWJlckxFID0gYnl0ZXNUb051bWJlckxFO1xuZXhwb3J0cy5udW1iZXJUb0J5dGVzQkUgPSBudW1iZXJUb0J5dGVzQkU7XG5leHBvcnRzLm51bWJlclRvQnl0ZXNMRSA9IG51bWJlclRvQnl0ZXNMRTtcbmV4cG9ydHMubnVtYmVyVG9WYXJCeXRlc0JFID0gbnVtYmVyVG9WYXJCeXRlc0JFO1xuZXhwb3J0cy5lbnN1cmVCeXRlcyA9IGVuc3VyZUJ5dGVzO1xuZXhwb3J0cy5jb25jYXRCeXRlcyA9IGNvbmNhdEJ5dGVzO1xuZXhwb3J0cy5lcXVhbEJ5dGVzID0gZXF1YWxCeXRlcztcbmV4cG9ydHMudXRmOFRvQnl0ZXMgPSB1dGY4VG9CeXRlcztcbmV4cG9ydHMuaW5SYW5nZSA9IGluUmFuZ2U7XG5leHBvcnRzLmFJblJhbmdlID0gYUluUmFuZ2U7XG5leHBvcnRzLmJpdExlbiA9IGJpdExlbjtcbmV4cG9ydHMuYml0R2V0ID0gYml0R2V0O1xuZXhwb3J0cy5iaXRTZXQgPSBiaXRTZXQ7XG5leHBvcnRzLmNyZWF0ZUhtYWNEcmJnID0gY3JlYXRlSG1hY0RyYmc7XG5leHBvcnRzLnZhbGlkYXRlT2JqZWN0ID0gdmFsaWRhdGVPYmplY3Q7XG5leHBvcnRzLm1lbW9pemVkID0gbWVtb2l6ZWQ7XG4vLyAxMDAgbGluZXMgb2YgY29kZSBpbiB0aGUgZmlsZSBhcmUgZHVwbGljYXRlZCBmcm9tIG5vYmxlLWhhc2hlcyAodXRpbHMpLlxuLy8gVGhpcyBpcyBPSzogYGFic3RyYWN0YCBkaXJlY3RvcnkgZG9lcyBub3QgdXNlIG5vYmxlLWhhc2hlcy5cbi8vIFVzZXIgbWF5IG9wdC1pbiBpbnRvIHVzaW5nIGRpZmZlcmVudCBoYXNoaW5nIGxpYnJhcnkuIFRoaXMgd2F5LCBub2JsZS1oYXNoZXNcbi8vIHdvbid0IGJlIGluY2x1ZGVkIGludG8gdGhlaXIgYnVuZGxlLlxuY29uc3QgXzBuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgwKTtcbmNvbnN0IF8xbiA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMSk7XG5mdW5jdGlvbiBpc0J5dGVzKGEpIHtcbiAgICByZXR1cm4gYSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgfHwgKEFycmF5QnVmZmVyLmlzVmlldyhhKSAmJiBhLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdVaW50OEFycmF5Jyk7XG59XG5mdW5jdGlvbiBhYnl0ZXMoaXRlbSkge1xuICAgIGlmICghaXNCeXRlcyhpdGVtKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGV4cGVjdGVkJyk7XG59XG5mdW5jdGlvbiBhYm9vbCh0aXRsZSwgdmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnYm9vbGVhbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcih0aXRsZSArICcgYm9vbGVhbiBleHBlY3RlZCwgZ290ICcgKyB2YWx1ZSk7XG59XG4vLyBVc2VkIGluIHdlaWVyc3RyYXNzLCBkZXJcbmZ1bmN0aW9uIG51bWJlclRvSGV4VW5wYWRkZWQobnVtKSB7XG4gICAgY29uc3QgaGV4ID0gbnVtLnRvU3RyaW5nKDE2KTtcbiAgICByZXR1cm4gaGV4Lmxlbmd0aCAmIDEgPyAnMCcgKyBoZXggOiBoZXg7XG59XG5mdW5jdGlvbiBoZXhUb051bWJlcihoZXgpIHtcbiAgICBpZiAodHlwZW9mIGhleCAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290ICcgKyB0eXBlb2YgaGV4KTtcbiAgICByZXR1cm4gaGV4ID09PSAnJyA/IF8wbiA6IEJpZ0ludCgnMHgnICsgaGV4KTsgLy8gQmlnIEVuZGlhblxufVxuLy8gQnVpbHQtaW4gaGV4IGNvbnZlcnNpb24gaHR0cHM6Ly9jYW5pdXNlLmNvbS9tZG4tamF2YXNjcmlwdF9idWlsdGluc191aW50OGFycmF5X2Zyb21oZXhcbmNvbnN0IGhhc0hleEJ1aWx0aW4gPSBcbi8vIEB0cy1pZ25vcmVcbnR5cGVvZiBVaW50OEFycmF5LmZyb20oW10pLnRvSGV4ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBVaW50OEFycmF5LmZyb21IZXggPT09ICdmdW5jdGlvbic7XG4vLyBBcnJheSB3aGVyZSBpbmRleCAweGYwICgyNDApIGlzIG1hcHBlZCB0byBzdHJpbmcgJ2YwJ1xuY29uc3QgaGV4ZXMgPSAvKiBAX19QVVJFX18gKi8gQXJyYXkuZnJvbSh7IGxlbmd0aDogMjU2IH0sIChfLCBpKSA9PiBpLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpKTtcbi8qKlxuICogQ29udmVydCBieXRlIGFycmF5IHRvIGhleCBzdHJpbmcuIFVzZXMgYnVpbHQtaW4gZnVuY3Rpb24sIHdoZW4gYXZhaWxhYmxlLlxuICogQGV4YW1wbGUgYnl0ZXNUb0hleChVaW50OEFycmF5LmZyb20oWzB4Y2EsIDB4ZmUsIDB4MDEsIDB4MjNdKSkgLy8gJ2NhZmUwMTIzJ1xuICovXG5mdW5jdGlvbiBieXRlc1RvSGV4KGJ5dGVzKSB7XG4gICAgYWJ5dGVzKGJ5dGVzKTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgaWYgKGhhc0hleEJ1aWx0aW4pXG4gICAgICAgIHJldHVybiBieXRlcy50b0hleCgpO1xuICAgIC8vIHByZS1jYWNoaW5nIGltcHJvdmVzIHRoZSBzcGVlZCA2eFxuICAgIGxldCBoZXggPSAnJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGhleCArPSBoZXhlc1tieXRlc1tpXV07XG4gICAgfVxuICAgIHJldHVybiBoZXg7XG59XG4vLyBXZSB1c2Ugb3B0aW1pemVkIHRlY2huaXF1ZSB0byBjb252ZXJ0IGhleCBzdHJpbmcgdG8gYnl0ZSBhcnJheVxuY29uc3QgYXNjaWlzID0geyBfMDogNDgsIF85OiA1NywgQTogNjUsIEY6IDcwLCBhOiA5NywgZjogMTAyIH07XG5mdW5jdGlvbiBhc2NpaVRvQmFzZTE2KGNoKSB7XG4gICAgaWYgKGNoID49IGFzY2lpcy5fMCAmJiBjaCA8PSBhc2NpaXMuXzkpXG4gICAgICAgIHJldHVybiBjaCAtIGFzY2lpcy5fMDsgLy8gJzInID0+IDUwLTQ4XG4gICAgaWYgKGNoID49IGFzY2lpcy5BICYmIGNoIDw9IGFzY2lpcy5GKVxuICAgICAgICByZXR1cm4gY2ggLSAoYXNjaWlzLkEgLSAxMCk7IC8vICdCJyA9PiA2Ni0oNjUtMTApXG4gICAgaWYgKGNoID49IGFzY2lpcy5hICYmIGNoIDw9IGFzY2lpcy5mKVxuICAgICAgICByZXR1cm4gY2ggLSAoYXNjaWlzLmEgLSAxMCk7IC8vICdiJyA9PiA5OC0oOTctMTApXG4gICAgcmV0dXJuO1xufVxuLyoqXG4gKiBDb252ZXJ0IGhleCBzdHJpbmcgdG8gYnl0ZSBhcnJheS4gVXNlcyBidWlsdC1pbiBmdW5jdGlvbiwgd2hlbiBhdmFpbGFibGUuXG4gKiBAZXhhbXBsZSBoZXhUb0J5dGVzKCdjYWZlMDEyMycpIC8vIFVpbnQ4QXJyYXkuZnJvbShbMHhjYSwgMHhmZSwgMHgwMSwgMHgyM10pXG4gKi9cbmZ1bmN0aW9uIGhleFRvQnl0ZXMoaGV4KSB7XG4gICAgaWYgKHR5cGVvZiBoZXggIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCAnICsgdHlwZW9mIGhleCk7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGlmIChoYXNIZXhCdWlsdGluKVxuICAgICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tSGV4KGhleCk7XG4gICAgY29uc3QgaGwgPSBoZXgubGVuZ3RoO1xuICAgIGNvbnN0IGFsID0gaGwgLyAyO1xuICAgIGlmIChobCAlIDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290IHVucGFkZGVkIGhleCBvZiBsZW5ndGggJyArIGhsKTtcbiAgICBjb25zdCBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFsKTtcbiAgICBmb3IgKGxldCBhaSA9IDAsIGhpID0gMDsgYWkgPCBhbDsgYWkrKywgaGkgKz0gMikge1xuICAgICAgICBjb25zdCBuMSA9IGFzY2lpVG9CYXNlMTYoaGV4LmNoYXJDb2RlQXQoaGkpKTtcbiAgICAgICAgY29uc3QgbjIgPSBhc2NpaVRvQmFzZTE2KGhleC5jaGFyQ29kZUF0KGhpICsgMSkpO1xuICAgICAgICBpZiAobjEgPT09IHVuZGVmaW5lZCB8fCBuMiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBjaGFyID0gaGV4W2hpXSArIGhleFtoaSArIDFdO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3Qgbm9uLWhleCBjaGFyYWN0ZXIgXCInICsgY2hhciArICdcIiBhdCBpbmRleCAnICsgaGkpO1xuICAgICAgICB9XG4gICAgICAgIGFycmF5W2FpXSA9IG4xICogMTYgKyBuMjsgLy8gbXVsdGlwbHkgZmlyc3Qgb2N0ZXQsIGUuZy4gJ2EzJyA9PiAxMCoxNiszID0+IDE2MCArIDMgPT4gMTYzXG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbn1cbi8vIEJFOiBCaWcgRW5kaWFuLCBMRTogTGl0dGxlIEVuZGlhblxuZnVuY3Rpb24gYnl0ZXNUb051bWJlckJFKGJ5dGVzKSB7XG4gICAgcmV0dXJuIGhleFRvTnVtYmVyKGJ5dGVzVG9IZXgoYnl0ZXMpKTtcbn1cbmZ1bmN0aW9uIGJ5dGVzVG9OdW1iZXJMRShieXRlcykge1xuICAgIGFieXRlcyhieXRlcyk7XG4gICAgcmV0dXJuIGhleFRvTnVtYmVyKGJ5dGVzVG9IZXgoVWludDhBcnJheS5mcm9tKGJ5dGVzKS5yZXZlcnNlKCkpKTtcbn1cbmZ1bmN0aW9uIG51bWJlclRvQnl0ZXNCRShuLCBsZW4pIHtcbiAgICByZXR1cm4gaGV4VG9CeXRlcyhuLnRvU3RyaW5nKDE2KS5wYWRTdGFydChsZW4gKiAyLCAnMCcpKTtcbn1cbmZ1bmN0aW9uIG51bWJlclRvQnl0ZXNMRShuLCBsZW4pIHtcbiAgICByZXR1cm4gbnVtYmVyVG9CeXRlc0JFKG4sIGxlbikucmV2ZXJzZSgpO1xufVxuLy8gVW5wYWRkZWQsIHJhcmVseSB1c2VkXG5mdW5jdGlvbiBudW1iZXJUb1ZhckJ5dGVzQkUobikge1xuICAgIHJldHVybiBoZXhUb0J5dGVzKG51bWJlclRvSGV4VW5wYWRkZWQobikpO1xufVxuLyoqXG4gKiBUYWtlcyBoZXggc3RyaW5nIG9yIFVpbnQ4QXJyYXksIGNvbnZlcnRzIHRvIFVpbnQ4QXJyYXkuXG4gKiBWYWxpZGF0ZXMgb3V0cHV0IGxlbmd0aC5cbiAqIFdpbGwgdGhyb3cgZXJyb3IgZm9yIG90aGVyIHR5cGVzLlxuICogQHBhcmFtIHRpdGxlIGRlc2NyaXB0aXZlIHRpdGxlIGZvciBhbiBlcnJvciBlLmcuICdwcml2YXRlIGtleSdcbiAqIEBwYXJhbSBoZXggaGV4IHN0cmluZyBvciBVaW50OEFycmF5XG4gKiBAcGFyYW0gZXhwZWN0ZWRMZW5ndGggb3B0aW9uYWwsIHdpbGwgY29tcGFyZSB0byByZXN1bHQgYXJyYXkncyBsZW5ndGhcbiAqIEByZXR1cm5zXG4gKi9cbmZ1bmN0aW9uIGVuc3VyZUJ5dGVzKHRpdGxlLCBoZXgsIGV4cGVjdGVkTGVuZ3RoKSB7XG4gICAgbGV0IHJlcztcbiAgICBpZiAodHlwZW9mIGhleCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlcyA9IGhleFRvQnl0ZXMoaGV4KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHRpdGxlICsgJyBtdXN0IGJlIGhleCBzdHJpbmcgb3IgVWludDhBcnJheSwgY2F1c2U6ICcgKyBlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChpc0J5dGVzKGhleCkpIHtcbiAgICAgICAgLy8gVWludDhBcnJheS5mcm9tKCkgaW5zdGVhZCBvZiBoYXNoLnNsaWNlKCkgYmVjYXVzZSBub2RlLmpzIEJ1ZmZlclxuICAgICAgICAvLyBpcyBpbnN0YW5jZSBvZiBVaW50OEFycmF5LCBhbmQgaXRzIHNsaWNlKCkgY3JlYXRlcyAqKm11dGFibGUqKiBjb3B5XG4gICAgICAgIHJlcyA9IFVpbnQ4QXJyYXkuZnJvbShoZXgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHRpdGxlICsgJyBtdXN0IGJlIGhleCBzdHJpbmcgb3IgVWludDhBcnJheScpO1xuICAgIH1cbiAgICBjb25zdCBsZW4gPSByZXMubGVuZ3RoO1xuICAgIGlmICh0eXBlb2YgZXhwZWN0ZWRMZW5ndGggPT09ICdudW1iZXInICYmIGxlbiAhPT0gZXhwZWN0ZWRMZW5ndGgpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcih0aXRsZSArICcgb2YgbGVuZ3RoICcgKyBleHBlY3RlZExlbmd0aCArICcgZXhwZWN0ZWQsIGdvdCAnICsgbGVuKTtcbiAgICByZXR1cm4gcmVzO1xufVxuLyoqXG4gKiBDb3BpZXMgc2V2ZXJhbCBVaW50OEFycmF5cyBpbnRvIG9uZS5cbiAqL1xuZnVuY3Rpb24gY29uY2F0Qnl0ZXMoLi4uYXJyYXlzKSB7XG4gICAgbGV0IHN1bSA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYSA9IGFycmF5c1tpXTtcbiAgICAgICAgYWJ5dGVzKGEpO1xuICAgICAgICBzdW0gKz0gYS5sZW5ndGg7XG4gICAgfVxuICAgIGNvbnN0IHJlcyA9IG5ldyBVaW50OEFycmF5KHN1bSk7XG4gICAgZm9yIChsZXQgaSA9IDAsIHBhZCA9IDA7IGkgPCBhcnJheXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYSA9IGFycmF5c1tpXTtcbiAgICAgICAgcmVzLnNldChhLCBwYWQpO1xuICAgICAgICBwYWQgKz0gYS5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG4vLyBDb21wYXJlcyAyIHU4YS1zIGluIGtpbmRhIGNvbnN0YW50IHRpbWVcbmZ1bmN0aW9uIGVxdWFsQnl0ZXMoYSwgYikge1xuICAgIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgZGlmZiA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKVxuICAgICAgICBkaWZmIHw9IGFbaV0gXiBiW2ldO1xuICAgIHJldHVybiBkaWZmID09PSAwO1xufVxuLyoqXG4gKiBAZXhhbXBsZSB1dGY4VG9CeXRlcygnYWJjJykgLy8gbmV3IFVpbnQ4QXJyYXkoWzk3LCA5OCwgOTldKVxuICovXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyhzdHIpIHtcbiAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc3RyaW5nIGV4cGVjdGVkJyk7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShzdHIpKTsgLy8gaHR0cHM6Ly9idWd6aWwubGEvMTY4MTgwOVxufVxuLy8gSXMgcG9zaXRpdmUgYmlnaW50XG5jb25zdCBpc1Bvc0JpZyA9IChuKSA9PiB0eXBlb2YgbiA9PT0gJ2JpZ2ludCcgJiYgXzBuIDw9IG47XG5mdW5jdGlvbiBpblJhbmdlKG4sIG1pbiwgbWF4KSB7XG4gICAgcmV0dXJuIGlzUG9zQmlnKG4pICYmIGlzUG9zQmlnKG1pbikgJiYgaXNQb3NCaWcobWF4KSAmJiBtaW4gPD0gbiAmJiBuIDwgbWF4O1xufVxuLyoqXG4gKiBBc3NlcnRzIG1pbiA8PSBuIDwgbWF4LiBOT1RFOiBJdCdzIDwgbWF4IGFuZCBub3QgPD0gbWF4LlxuICogQGV4YW1wbGVcbiAqIGFJblJhbmdlKCd4JywgeCwgMW4sIDI1Nm4pOyAvLyB3b3VsZCBhc3N1bWUgeCBpcyBpbiAoMW4uLjI1NW4pXG4gKi9cbmZ1bmN0aW9uIGFJblJhbmdlKHRpdGxlLCBuLCBtaW4sIG1heCkge1xuICAgIC8vIFdoeSBtaW4gPD0gbiA8IG1heCBhbmQgbm90IGEgKG1pbiA8IG4gPCBtYXgpIE9SIGIgKG1pbiA8PSBuIDw9IG1heCk/XG4gICAgLy8gY29uc2lkZXIgUD0yNTZuLCBtaW49MG4sIG1heD1QXG4gICAgLy8gLSBhIGZvciBtaW49MCB3b3VsZCByZXF1aXJlIC0xOiAgICAgICAgICBgaW5SYW5nZSgneCcsIHgsIC0xbiwgUClgXG4gICAgLy8gLSBiIHdvdWxkIGNvbW1vbmx5IHJlcXVpcmUgc3VidHJhY3Rpb246ICBgaW5SYW5nZSgneCcsIHgsIDBuLCBQIC0gMW4pYFxuICAgIC8vIC0gb3VyIHdheSBpcyB0aGUgY2xlYW5lc3Q6ICAgICAgICAgICAgICAgYGluUmFuZ2UoJ3gnLCB4LCAwbiwgUClcbiAgICBpZiAoIWluUmFuZ2UobiwgbWluLCBtYXgpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGVjdGVkIHZhbGlkICcgKyB0aXRsZSArICc6ICcgKyBtaW4gKyAnIDw9IG4gPCAnICsgbWF4ICsgJywgZ290ICcgKyBuKTtcbn1cbi8vIEJpdCBvcGVyYXRpb25zXG4vKipcbiAqIENhbGN1bGF0ZXMgYW1vdW50IG9mIGJpdHMgaW4gYSBiaWdpbnQuXG4gKiBTYW1lIGFzIGBuLnRvU3RyaW5nKDIpLmxlbmd0aGBcbiAqIFRPRE86IG1lcmdlIHdpdGggbkxlbmd0aCBpbiBtb2R1bGFyXG4gKi9cbmZ1bmN0aW9uIGJpdExlbihuKSB7XG4gICAgbGV0IGxlbjtcbiAgICBmb3IgKGxlbiA9IDA7IG4gPiBfMG47IG4gPj49IF8xbiwgbGVuICs9IDEpXG4gICAgICAgIDtcbiAgICByZXR1cm4gbGVuO1xufVxuLyoqXG4gKiBHZXRzIHNpbmdsZSBiaXQgYXQgcG9zaXRpb24uXG4gKiBOT1RFOiBmaXJzdCBiaXQgcG9zaXRpb24gaXMgMCAoc2FtZSBhcyBhcnJheXMpXG4gKiBTYW1lIGFzIGAhIStBcnJheS5mcm9tKG4udG9TdHJpbmcoMikpLnJldmVyc2UoKVtwb3NdYFxuICovXG5mdW5jdGlvbiBiaXRHZXQobiwgcG9zKSB7XG4gICAgcmV0dXJuIChuID4+IEJpZ0ludChwb3MpKSAmIF8xbjtcbn1cbi8qKlxuICogU2V0cyBzaW5nbGUgYml0IGF0IHBvc2l0aW9uLlxuICovXG5mdW5jdGlvbiBiaXRTZXQobiwgcG9zLCB2YWx1ZSkge1xuICAgIHJldHVybiBuIHwgKCh2YWx1ZSA/IF8xbiA6IF8wbikgPDwgQmlnSW50KHBvcykpO1xufVxuLyoqXG4gKiBDYWxjdWxhdGUgbWFzayBmb3IgTiBiaXRzLiBOb3QgdXNpbmcgKiogb3BlcmF0b3Igd2l0aCBiaWdpbnRzIGJlY2F1c2Ugb2Ygb2xkIGVuZ2luZXMuXG4gKiBTYW1lIGFzIEJpZ0ludChgMGIke0FycmF5KGkpLmZpbGwoJzEnKS5qb2luKCcnKX1gKVxuICovXG5jb25zdCBiaXRNYXNrID0gKG4pID0+IChfMW4gPDwgQmlnSW50KG4pKSAtIF8xbjtcbmV4cG9ydHMuYml0TWFzayA9IGJpdE1hc2s7XG4vLyBEUkJHXG5jb25zdCB1OG4gPSAobGVuKSA9PiBuZXcgVWludDhBcnJheShsZW4pOyAvLyBjcmVhdGVzIFVpbnQ4QXJyYXlcbmNvbnN0IHU4ZnIgPSAoYXJyKSA9PiBVaW50OEFycmF5LmZyb20oYXJyKTsgLy8gYW5vdGhlciBzaG9ydGN1dFxuLyoqXG4gKiBNaW5pbWFsIEhNQUMtRFJCRyBmcm9tIE5JU1QgODAwLTkwIGZvciBSRkM2OTc5IHNpZ3MuXG4gKiBAcmV0dXJucyBmdW5jdGlvbiB0aGF0IHdpbGwgY2FsbCBEUkJHIHVudGlsIDJuZCBhcmcgcmV0dXJucyBzb21ldGhpbmcgbWVhbmluZ2Z1bFxuICogQGV4YW1wbGVcbiAqICAgY29uc3QgZHJiZyA9IGNyZWF0ZUhtYWNEUkJHPEtleT4oMzIsIDMyLCBobWFjKTtcbiAqICAgZHJiZyhzZWVkLCBieXRlc1RvS2V5KTsgLy8gYnl0ZXNUb0tleSBtdXN0IHJldHVybiBLZXkgb3IgdW5kZWZpbmVkXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUhtYWNEcmJnKGhhc2hMZW4sIHFCeXRlTGVuLCBobWFjRm4pIHtcbiAgICBpZiAodHlwZW9mIGhhc2hMZW4gIT09ICdudW1iZXInIHx8IGhhc2hMZW4gPCAyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hhc2hMZW4gbXVzdCBiZSBhIG51bWJlcicpO1xuICAgIGlmICh0eXBlb2YgcUJ5dGVMZW4gIT09ICdudW1iZXInIHx8IHFCeXRlTGVuIDwgMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdxQnl0ZUxlbiBtdXN0IGJlIGEgbnVtYmVyJyk7XG4gICAgaWYgKHR5cGVvZiBobWFjRm4gIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaG1hY0ZuIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgIC8vIFN0ZXAgQiwgU3RlcCBDOiBzZXQgaGFzaExlbiB0byA4KmNlaWwoaGxlbi84KVxuICAgIGxldCB2ID0gdThuKGhhc2hMZW4pOyAvLyBNaW5pbWFsIG5vbi1mdWxsLXNwZWMgSE1BQy1EUkJHIGZyb20gTklTVCA4MDAtOTAgZm9yIFJGQzY5Nzkgc2lncy5cbiAgICBsZXQgayA9IHU4bihoYXNoTGVuKTsgLy8gU3RlcHMgQiBhbmQgQyBvZiBSRkM2OTc5IDMuMjogc2V0IGhhc2hMZW4sIGluIG91ciBjYXNlIGFsd2F5cyBzYW1lXG4gICAgbGV0IGkgPSAwOyAvLyBJdGVyYXRpb25zIGNvdW50ZXIsIHdpbGwgdGhyb3cgd2hlbiBvdmVyIDEwMDBcbiAgICBjb25zdCByZXNldCA9ICgpID0+IHtcbiAgICAgICAgdi5maWxsKDEpO1xuICAgICAgICBrLmZpbGwoMCk7XG4gICAgICAgIGkgPSAwO1xuICAgIH07XG4gICAgY29uc3QgaCA9ICguLi5iKSA9PiBobWFjRm4oaywgdiwgLi4uYik7IC8vIGhtYWMoaykodiwgLi4udmFsdWVzKVxuICAgIGNvbnN0IHJlc2VlZCA9IChzZWVkID0gdThuKDApKSA9PiB7XG4gICAgICAgIC8vIEhNQUMtRFJCRyByZXNlZWQoKSBmdW5jdGlvbi4gU3RlcHMgRC1HXG4gICAgICAgIGsgPSBoKHU4ZnIoWzB4MDBdKSwgc2VlZCk7IC8vIGsgPSBobWFjKGsgfHwgdiB8fCAweDAwIHx8IHNlZWQpXG4gICAgICAgIHYgPSBoKCk7IC8vIHYgPSBobWFjKGsgfHwgdilcbiAgICAgICAgaWYgKHNlZWQubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBrID0gaCh1OGZyKFsweDAxXSksIHNlZWQpOyAvLyBrID0gaG1hYyhrIHx8IHYgfHwgMHgwMSB8fCBzZWVkKVxuICAgICAgICB2ID0gaCgpOyAvLyB2ID0gaG1hYyhrIHx8IHYpXG4gICAgfTtcbiAgICBjb25zdCBnZW4gPSAoKSA9PiB7XG4gICAgICAgIC8vIEhNQUMtRFJCRyBnZW5lcmF0ZSgpIGZ1bmN0aW9uXG4gICAgICAgIGlmIChpKysgPj0gMTAwMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZHJiZzogdHJpZWQgMTAwMCB2YWx1ZXMnKTtcbiAgICAgICAgbGV0IGxlbiA9IDA7XG4gICAgICAgIGNvbnN0IG91dCA9IFtdO1xuICAgICAgICB3aGlsZSAobGVuIDwgcUJ5dGVMZW4pIHtcbiAgICAgICAgICAgIHYgPSBoKCk7XG4gICAgICAgICAgICBjb25zdCBzbCA9IHYuc2xpY2UoKTtcbiAgICAgICAgICAgIG91dC5wdXNoKHNsKTtcbiAgICAgICAgICAgIGxlbiArPSB2Lmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29uY2F0Qnl0ZXMoLi4ub3V0KTtcbiAgICB9O1xuICAgIGNvbnN0IGdlblVudGlsID0gKHNlZWQsIHByZWQpID0+IHtcbiAgICAgICAgcmVzZXQoKTtcbiAgICAgICAgcmVzZWVkKHNlZWQpOyAvLyBTdGVwcyBELUdcbiAgICAgICAgbGV0IHJlcyA9IHVuZGVmaW5lZDsgLy8gU3RlcCBIOiBncmluZCB1bnRpbCBrIGlzIGluIFsxLi5uLTFdXG4gICAgICAgIHdoaWxlICghKHJlcyA9IHByZWQoZ2VuKCkpKSlcbiAgICAgICAgICAgIHJlc2VlZCgpO1xuICAgICAgICByZXNldCgpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG4gICAgcmV0dXJuIGdlblVudGlsO1xufVxuLy8gVmFsaWRhdGluZyBjdXJ2ZXMgYW5kIGZpZWxkc1xuY29uc3QgdmFsaWRhdG9yRm5zID0ge1xuICAgIGJpZ2ludDogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ2JpZ2ludCcsXG4gICAgZnVuY3Rpb246ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicsXG4gICAgYm9vbGVhbjogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ2Jvb2xlYW4nLFxuICAgIHN0cmluZzogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycsXG4gICAgc3RyaW5nT3JVaW50OEFycmF5OiAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnc3RyaW5nJyB8fCBpc0J5dGVzKHZhbCksXG4gICAgaXNTYWZlSW50ZWdlcjogKHZhbCkgPT4gTnVtYmVyLmlzU2FmZUludGVnZXIodmFsKSxcbiAgICBhcnJheTogKHZhbCkgPT4gQXJyYXkuaXNBcnJheSh2YWwpLFxuICAgIGZpZWxkOiAodmFsLCBvYmplY3QpID0+IG9iamVjdC5GcC5pc1ZhbGlkKHZhbCksXG4gICAgaGFzaDogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJyAmJiBOdW1iZXIuaXNTYWZlSW50ZWdlcih2YWwub3V0cHV0TGVuKSxcbn07XG4vLyB0eXBlIFJlY29yZDxLIGV4dGVuZHMgc3RyaW5nIHwgbnVtYmVyIHwgc3ltYm9sLCBUPiA9IHsgW1AgaW4gS106IFQ7IH1cbmZ1bmN0aW9uIHZhbGlkYXRlT2JqZWN0KG9iamVjdCwgdmFsaWRhdG9ycywgb3B0VmFsaWRhdG9ycyA9IHt9KSB7XG4gICAgY29uc3QgY2hlY2tGaWVsZCA9IChmaWVsZE5hbWUsIHR5cGUsIGlzT3B0aW9uYWwpID0+IHtcbiAgICAgICAgY29uc3QgY2hlY2tWYWwgPSB2YWxpZGF0b3JGbnNbdHlwZV07XG4gICAgICAgIGlmICh0eXBlb2YgY2hlY2tWYWwgIT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgdmFsaWRhdG9yIGZ1bmN0aW9uJyk7XG4gICAgICAgIGNvbnN0IHZhbCA9IG9iamVjdFtmaWVsZE5hbWVdO1xuICAgICAgICBpZiAoaXNPcHRpb25hbCAmJiB2YWwgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKCFjaGVja1ZhbCh2YWwsIG9iamVjdCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncGFyYW0gJyArIFN0cmluZyhmaWVsZE5hbWUpICsgJyBpcyBpbnZhbGlkLiBFeHBlY3RlZCAnICsgdHlwZSArICcsIGdvdCAnICsgdmFsKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgZm9yIChjb25zdCBbZmllbGROYW1lLCB0eXBlXSBvZiBPYmplY3QuZW50cmllcyh2YWxpZGF0b3JzKSlcbiAgICAgICAgY2hlY2tGaWVsZChmaWVsZE5hbWUsIHR5cGUsIGZhbHNlKTtcbiAgICBmb3IgKGNvbnN0IFtmaWVsZE5hbWUsIHR5cGVdIG9mIE9iamVjdC5lbnRyaWVzKG9wdFZhbGlkYXRvcnMpKVxuICAgICAgICBjaGVja0ZpZWxkKGZpZWxkTmFtZSwgdHlwZSwgdHJ1ZSk7XG4gICAgcmV0dXJuIG9iamVjdDtcbn1cbi8vIHZhbGlkYXRlIHR5cGUgdGVzdHNcbi8vIGNvbnN0IG86IHsgYTogbnVtYmVyOyBiOiBudW1iZXI7IGM6IG51bWJlciB9ID0geyBhOiAxLCBiOiA1LCBjOiA2IH07XG4vLyBjb25zdCB6MCA9IHZhbGlkYXRlT2JqZWN0KG8sIHsgYTogJ2lzU2FmZUludGVnZXInIH0sIHsgYzogJ2JpZ2ludCcgfSk7IC8vIE9rIVxuLy8gLy8gU2hvdWxkIGZhaWwgdHlwZS1jaGVja1xuLy8gY29uc3QgejEgPSB2YWxpZGF0ZU9iamVjdChvLCB7IGE6ICd0bXAnIH0sIHsgYzogJ3p6JyB9KTtcbi8vIGNvbnN0IHoyID0gdmFsaWRhdGVPYmplY3QobywgeyBhOiAnaXNTYWZlSW50ZWdlcicgfSwgeyBjOiAnenonIH0pO1xuLy8gY29uc3QgejMgPSB2YWxpZGF0ZU9iamVjdChvLCB7IHRlc3Q6ICdib29sZWFuJywgejogJ2J1ZycgfSk7XG4vLyBjb25zdCB6NCA9IHZhbGlkYXRlT2JqZWN0KG8sIHsgYTogJ2Jvb2xlYW4nLCB6OiAnYnVnJyB9KTtcbi8qKlxuICogdGhyb3dzIG5vdCBpbXBsZW1lbnRlZCBlcnJvclxuICovXG5jb25zdCBub3RJbXBsZW1lbnRlZCA9ICgpID0+IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ25vdCBpbXBsZW1lbnRlZCcpO1xufTtcbmV4cG9ydHMubm90SW1wbGVtZW50ZWQgPSBub3RJbXBsZW1lbnRlZDtcbi8qKlxuICogTWVtb2l6ZXMgKGNhY2hlcykgY29tcHV0YXRpb24gcmVzdWx0LlxuICogVXNlcyBXZWFrTWFwOiB0aGUgdmFsdWUgaXMgZ29pbmcgYXV0by1jbGVhbmVkIGJ5IEdDIGFmdGVyIGxhc3QgcmVmZXJlbmNlIGlzIHJlbW92ZWQuXG4gKi9cbmZ1bmN0aW9uIG1lbW9pemVkKGZuKSB7XG4gICAgY29uc3QgbWFwID0gbmV3IFdlYWtNYXAoKTtcbiAgICByZXR1cm4gKGFyZywgLi4uYXJncykgPT4ge1xuICAgICAgICBjb25zdCB2YWwgPSBtYXAuZ2V0KGFyZyk7XG4gICAgICAgIGlmICh2YWwgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIGNvbnN0IGNvbXB1dGVkID0gZm4oYXJnLCAuLi5hcmdzKTtcbiAgICAgICAgbWFwLnNldChhcmcsIGNvbXB1dGVkKTtcbiAgICAgICAgcmV0dXJuIGNvbXB1dGVkO1xuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJub3RJbXBsZW1lbnRlZCIsImJpdE1hc2siLCJpc0J5dGVzIiwiYWJ5dGVzIiwiYWJvb2wiLCJudW1iZXJUb0hleFVucGFkZGVkIiwiaGV4VG9OdW1iZXIiLCJieXRlc1RvSGV4IiwiaGV4VG9CeXRlcyIsImJ5dGVzVG9OdW1iZXJCRSIsImJ5dGVzVG9OdW1iZXJMRSIsIm51bWJlclRvQnl0ZXNCRSIsIm51bWJlclRvQnl0ZXNMRSIsIm51bWJlclRvVmFyQnl0ZXNCRSIsImVuc3VyZUJ5dGVzIiwiY29uY2F0Qnl0ZXMiLCJlcXVhbEJ5dGVzIiwidXRmOFRvQnl0ZXMiLCJpblJhbmdlIiwiYUluUmFuZ2UiLCJiaXRMZW4iLCJiaXRHZXQiLCJiaXRTZXQiLCJjcmVhdGVIbWFjRHJiZyIsInZhbGlkYXRlT2JqZWN0IiwibWVtb2l6ZWQiLCJfMG4iLCJCaWdJbnQiLCJfMW4iLCJhIiwiVWludDhBcnJheSIsIkFycmF5QnVmZmVyIiwiaXNWaWV3IiwiY29uc3RydWN0b3IiLCJuYW1lIiwiaXRlbSIsIkVycm9yIiwidGl0bGUiLCJudW0iLCJoZXgiLCJ0b1N0cmluZyIsImxlbmd0aCIsImhhc0hleEJ1aWx0aW4iLCJmcm9tIiwidG9IZXgiLCJmcm9tSGV4IiwiaGV4ZXMiLCJBcnJheSIsIl8iLCJpIiwicGFkU3RhcnQiLCJieXRlcyIsImFzY2lpcyIsIl8wIiwiXzkiLCJBIiwiRiIsImYiLCJhc2NpaVRvQmFzZTE2IiwiY2giLCJobCIsImFsIiwiYXJyYXkiLCJhaSIsImhpIiwibjEiLCJjaGFyQ29kZUF0IiwibjIiLCJ1bmRlZmluZWQiLCJjaGFyIiwicmV2ZXJzZSIsIm4iLCJsZW4iLCJleHBlY3RlZExlbmd0aCIsInJlcyIsImUiLCJhcnJheXMiLCJzdW0iLCJwYWQiLCJzZXQiLCJiIiwiZGlmZiIsInN0ciIsIlRleHRFbmNvZGVyIiwiZW5jb2RlIiwiaXNQb3NCaWciLCJtaW4iLCJtYXgiLCJwb3MiLCJ1OG4iLCJ1OGZyIiwiYXJyIiwiaGFzaExlbiIsInFCeXRlTGVuIiwiaG1hY0ZuIiwidiIsImsiLCJyZXNldCIsImZpbGwiLCJoIiwicmVzZWVkIiwic2VlZCIsImdlbiIsIm91dCIsInNsIiwic2xpY2UiLCJwdXNoIiwiZ2VuVW50aWwiLCJwcmVkIiwidmFsaWRhdG9yRm5zIiwiYmlnaW50IiwidmFsIiwiZnVuY3Rpb24iLCJib29sZWFuIiwic3RyaW5nIiwic3RyaW5nT3JVaW50OEFycmF5IiwiaXNTYWZlSW50ZWdlciIsIk51bWJlciIsImlzQXJyYXkiLCJmaWVsZCIsIm9iamVjdCIsIkZwIiwiaXNWYWxpZCIsImhhc2giLCJvdXRwdXRMZW4iLCJ2YWxpZGF0b3JzIiwib3B0VmFsaWRhdG9ycyIsImNoZWNrRmllbGQiLCJmaWVsZE5hbWUiLCJ0eXBlIiwiaXNPcHRpb25hbCIsImNoZWNrVmFsIiwiU3RyaW5nIiwiZW50cmllcyIsImZuIiwibWFwIiwiV2Vha01hcCIsImFyZyIsImFyZ3MiLCJnZXQiLCJjb21wdXRlZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@noble/curves/abstract/utils.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@noble/curves/abstract/weierstrass.js":
/*!************************************************************!*\
  !*** ./node_modules/@noble/curves/abstract/weierstrass.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.DER = exports.DERErr = void 0;\nexports.weierstrassPoints = weierstrassPoints;\nexports.weierstrass = weierstrass;\nexports.SWUFpSqrtRatio = SWUFpSqrtRatio;\nexports.mapToCurveSimpleSWU = mapToCurveSimpleSWU;\n/**\n * Short Weierstrass curve methods. The formula is: y¬≤ = x¬≥ + ax + b.\n *\n * ### Parameters\n *\n * To initialize a weierstrass curve, one needs to pass following params:\n *\n * * a: formula param\n * * b: formula param\n * * Fp: finite field of prime characteristic P; may be complex (Fp2). Arithmetics is done in field\n * * n: order of prime subgroup a.k.a total amount of valid curve points\n * * Gx: Base point (x, y) aka generator point. Gx = x coordinate\n * * Gy: ...y coordinate\n * * h: cofactor, usually 1. h*n = curve group order (n is only subgroup order)\n * * lowS: whether to enable (default) or disable \"low-s\" non-malleable signatures\n *\n * ### Design rationale for types\n *\n * * Interaction between classes from different curves should fail:\n *   `k256.Point.BASE.add(p256.Point.BASE)`\n * * For this purpose we want to use `instanceof` operator, which is fast and works during runtime\n * * Different calls of `curve()` would return different classes -\n *   `curve(params) !== curve(params)`: if somebody decided to monkey-patch their curve,\n *   it won't affect others\n *\n * TypeScript can't infer types for classes created inside a function. Classes is one instance\n * of nominative types in TypeScript and interfaces only check for shape, so it's hard to create\n * unique type for every function call.\n *\n * We can use generic types via some param, like curve opts, but that would:\n *     1. Enable interaction between `curve(params)` and `curve(params)` (curves of same params)\n *     which is hard to debug.\n *     2. Params can be generic and we can't enforce them to be constant value:\n *     if somebody creates curve from non-constant params,\n *     it would be allowed to interact with other curves with non-constant params\n *\n * @todo https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-7.html#unique-symbol\n * @module\n */ /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ // prettier-ignore\nconst curve_ts_1 = __webpack_require__(/*! ./curve.js */ \"(rsc)/./node_modules/@noble/curves/abstract/curve.js\");\n// prettier-ignore\nconst modular_ts_1 = __webpack_require__(/*! ./modular.js */ \"(rsc)/./node_modules/@noble/curves/abstract/modular.js\");\n// prettier-ignore\nconst utils_ts_1 = __webpack_require__(/*! ./utils.js */ \"(rsc)/./node_modules/@noble/curves/abstract/utils.js\");\nfunction validateSigVerOpts(opts) {\n    if (opts.lowS !== undefined) (0, utils_ts_1.abool)(\"lowS\", opts.lowS);\n    if (opts.prehash !== undefined) (0, utils_ts_1.abool)(\"prehash\", opts.prehash);\n}\nfunction validatePointOpts(curve) {\n    const opts = (0, curve_ts_1.validateBasic)(curve);\n    (0, utils_ts_1.validateObject)(opts, {\n        a: \"field\",\n        b: \"field\"\n    }, {\n        allowInfinityPoint: \"boolean\",\n        allowedPrivateKeyLengths: \"array\",\n        clearCofactor: \"function\",\n        fromBytes: \"function\",\n        isTorsionFree: \"function\",\n        toBytes: \"function\",\n        wrapPrivateKey: \"boolean\"\n    });\n    const { endo, Fp, a } = opts;\n    if (endo) {\n        if (!Fp.eql(a, Fp.ZERO)) {\n            throw new Error(\"invalid endo: CURVE.a must be 0\");\n        }\n        if (typeof endo !== \"object\" || typeof endo.beta !== \"bigint\" || typeof endo.splitScalar !== \"function\") {\n            throw new Error('invalid endo: expected \"beta\": bigint and \"splitScalar\": function');\n        }\n    }\n    return Object.freeze({\n        ...opts\n    });\n}\nclass DERErr extends Error {\n    constructor(m = \"\"){\n        super(m);\n    }\n}\nexports.DERErr = DERErr;\n/**\n * ASN.1 DER encoding utilities. ASN is very complex & fragile. Format:\n *\n *     [0x30 (SEQUENCE), bytelength, 0x02 (INTEGER), intLength, R, 0x02 (INTEGER), intLength, S]\n *\n * Docs: https://letsencrypt.org/docs/a-warm-welcome-to-asn1-and-der/, https://luca.ntop.org/Teaching/Appunti/asn1.html\n */ exports.DER = {\n    // asn.1 DER encoding utils\n    Err: DERErr,\n    // Basic building block is TLV (Tag-Length-Value)\n    _tlv: {\n        encode: (tag, data)=>{\n            const { Err: E } = exports.DER;\n            if (tag < 0 || tag > 256) throw new E(\"tlv.encode: wrong tag\");\n            if (data.length & 1) throw new E(\"tlv.encode: unpadded data\");\n            const dataLen = data.length / 2;\n            const len = (0, utils_ts_1.numberToHexUnpadded)(dataLen);\n            if (len.length / 2 & 128) throw new E(\"tlv.encode: long form length too big\");\n            // length of length with long form flag\n            const lenLen = dataLen > 127 ? (0, utils_ts_1.numberToHexUnpadded)(len.length / 2 | 128) : \"\";\n            const t = (0, utils_ts_1.numberToHexUnpadded)(tag);\n            return t + lenLen + len + data;\n        },\n        // v - value, l - left bytes (unparsed)\n        decode (tag, data) {\n            const { Err: E } = exports.DER;\n            let pos = 0;\n            if (tag < 0 || tag > 256) throw new E(\"tlv.encode: wrong tag\");\n            if (data.length < 2 || data[pos++] !== tag) throw new E(\"tlv.decode: wrong tlv\");\n            const first = data[pos++];\n            const isLong = !!(first & 128); // First bit of first length byte is flag for short/long form\n            let length = 0;\n            if (!isLong) length = first;\n            else {\n                // Long form: [longFlag(1bit), lengthLength(7bit), length (BE)]\n                const lenLen = first & 127;\n                if (!lenLen) throw new E(\"tlv.decode(long): indefinite length not supported\");\n                if (lenLen > 4) throw new E(\"tlv.decode(long): byte length is too big\"); // this will overflow u32 in js\n                const lengthBytes = data.subarray(pos, pos + lenLen);\n                if (lengthBytes.length !== lenLen) throw new E(\"tlv.decode: length bytes not complete\");\n                if (lengthBytes[0] === 0) throw new E(\"tlv.decode(long): zero leftmost byte\");\n                for (const b of lengthBytes)length = length << 8 | b;\n                pos += lenLen;\n                if (length < 128) throw new E(\"tlv.decode(long): not minimal encoding\");\n            }\n            const v = data.subarray(pos, pos + length);\n            if (v.length !== length) throw new E(\"tlv.decode: wrong value length\");\n            return {\n                v,\n                l: data.subarray(pos + length)\n            };\n        }\n    },\n    // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,\n    // since we always use positive integers here. It must always be empty:\n    // - add zero byte if exists\n    // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)\n    _int: {\n        encode (num) {\n            const { Err: E } = exports.DER;\n            if (num < _0n) throw new E(\"integer: negative integers are not allowed\");\n            let hex = (0, utils_ts_1.numberToHexUnpadded)(num);\n            // Pad with zero byte if negative flag is present\n            if (Number.parseInt(hex[0], 16) & 8) hex = \"00\" + hex;\n            if (hex.length & 1) throw new E(\"unexpected DER parsing assertion: unpadded hex\");\n            return hex;\n        },\n        decode (data) {\n            const { Err: E } = exports.DER;\n            if (data[0] & 128) throw new E(\"invalid signature integer: negative\");\n            if (data[0] === 0x00 && !(data[1] & 128)) throw new E(\"invalid signature integer: unnecessary leading zero\");\n            return (0, utils_ts_1.bytesToNumberBE)(data);\n        }\n    },\n    toSig (hex) {\n        // parse DER signature\n        const { Err: E, _int: int, _tlv: tlv } = exports.DER;\n        const data = (0, utils_ts_1.ensureBytes)(\"signature\", hex);\n        const { v: seqBytes, l: seqLeftBytes } = tlv.decode(0x30, data);\n        if (seqLeftBytes.length) throw new E(\"invalid signature: left bytes after parsing\");\n        const { v: rBytes, l: rLeftBytes } = tlv.decode(0x02, seqBytes);\n        const { v: sBytes, l: sLeftBytes } = tlv.decode(0x02, rLeftBytes);\n        if (sLeftBytes.length) throw new E(\"invalid signature: left bytes after parsing\");\n        return {\n            r: int.decode(rBytes),\n            s: int.decode(sBytes)\n        };\n    },\n    hexFromSig (sig) {\n        const { _tlv: tlv, _int: int } = exports.DER;\n        const rs = tlv.encode(0x02, int.encode(sig.r));\n        const ss = tlv.encode(0x02, int.encode(sig.s));\n        const seq = rs + ss;\n        return tlv.encode(0x30, seq);\n    }\n};\nfunction numToSizedHex(num, size) {\n    return (0, utils_ts_1.bytesToHex)((0, utils_ts_1.numberToBytesBE)(num, size));\n}\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);\nfunction weierstrassPoints(opts) {\n    const CURVE = validatePointOpts(opts);\n    const { Fp } = CURVE; // All curves has same field / group length as for now, but they can differ\n    const Fn = (0, modular_ts_1.Field)(CURVE.n, CURVE.nBitLength);\n    const toBytes = CURVE.toBytes || ((_c, point, _isCompressed)=>{\n        const a = point.toAffine();\n        return (0, utils_ts_1.concatBytes)(Uint8Array.from([\n            0x04\n        ]), Fp.toBytes(a.x), Fp.toBytes(a.y));\n    });\n    const fromBytes = CURVE.fromBytes || ((bytes)=>{\n        // const head = bytes[0];\n        const tail = bytes.subarray(1);\n        // if (head !== 0x04) throw new Error('Only non-compressed encoding is supported');\n        const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n        const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n        return {\n            x,\n            y\n        };\n    });\n    /**\n     * y¬≤ = x¬≥ + ax + b: Short weierstrass curve formula. Takes x, returns y¬≤.\n     * @returns y¬≤\n     */ function weierstrassEquation(x) {\n        const { a, b } = CURVE;\n        const x2 = Fp.sqr(x); // x * x\n        const x3 = Fp.mul(x2, x); // x¬≤ * x\n        return Fp.add(Fp.add(x3, Fp.mul(x, a)), b); // x¬≥ + a * x + b\n    }\n    function isValidXY(x, y) {\n        const left = Fp.sqr(y); // y¬≤\n        const right = weierstrassEquation(x); // x¬≥ + ax + b\n        return Fp.eql(left, right);\n    }\n    // Validate whether the passed curve params are valid.\n    // Test 1: equation y¬≤ = x¬≥ + ax + b should work for generator point.\n    if (!isValidXY(CURVE.Gx, CURVE.Gy)) throw new Error(\"bad curve params: generator point\");\n    // Test 2: discriminant Œî part should be non-zero: 4a¬≥ + 27b¬≤ != 0.\n    // Guarantees curve is genus-1, smooth (non-singular).\n    const _4a3 = Fp.mul(Fp.pow(CURVE.a, _3n), _4n);\n    const _27b2 = Fp.mul(Fp.sqr(CURVE.b), BigInt(27));\n    if (Fp.is0(Fp.add(_4a3, _27b2))) throw new Error(\"bad curve params: a or b\");\n    // Valid group elements reside in range 1..n-1\n    function isWithinCurveOrder(num) {\n        return (0, utils_ts_1.inRange)(num, _1n, CURVE.n);\n    }\n    // Validates if priv key is valid and converts it to bigint.\n    // Supports options allowedPrivateKeyLengths and wrapPrivateKey.\n    function normPrivateKeyToScalar(key) {\n        const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n: N } = CURVE;\n        if (lengths && typeof key !== \"bigint\") {\n            if ((0, utils_ts_1.isBytes)(key)) key = (0, utils_ts_1.bytesToHex)(key);\n            // Normalize to hex string, pad. E.g. P521 would norm 130-132 char hex to 132-char bytes\n            if (typeof key !== \"string\" || !lengths.includes(key.length)) throw new Error(\"invalid private key\");\n            key = key.padStart(nByteLength * 2, \"0\");\n        }\n        let num;\n        try {\n            num = typeof key === \"bigint\" ? key : (0, utils_ts_1.bytesToNumberBE)((0, utils_ts_1.ensureBytes)(\"private key\", key, nByteLength));\n        } catch (error) {\n            throw new Error(\"invalid private key, expected hex or \" + nByteLength + \" bytes, got \" + typeof key);\n        }\n        if (wrapPrivateKey) num = (0, modular_ts_1.mod)(num, N); // disabled by default, enabled for BLS\n        (0, utils_ts_1.aInRange)(\"private key\", num, _1n, N); // num in range [1..N-1]\n        return num;\n    }\n    function aprjpoint(other) {\n        if (!(other instanceof Point)) throw new Error(\"ProjectivePoint expected\");\n    }\n    // Memoized toAffine / validity check. They are heavy. Points are immutable.\n    // Converts Projective point to affine (x, y) coordinates.\n    // Can accept precomputed Z^-1 - for example, from invertBatch.\n    // (X, Y, Z) ‚àã (x=X/Z, y=Y/Z)\n    const toAffineMemo = (0, utils_ts_1.memoized)((p, iz)=>{\n        const { px: x, py: y, pz: z } = p;\n        // Fast-path for normalized points\n        if (Fp.eql(z, Fp.ONE)) return {\n            x,\n            y\n        };\n        const is0 = p.is0();\n        // If invZ was 0, we return zero point. However we still want to execute\n        // all operations, so we replace invZ with a random number, 1.\n        if (iz == null) iz = is0 ? Fp.ONE : Fp.inv(z);\n        const ax = Fp.mul(x, iz);\n        const ay = Fp.mul(y, iz);\n        const zz = Fp.mul(z, iz);\n        if (is0) return {\n            x: Fp.ZERO,\n            y: Fp.ZERO\n        };\n        if (!Fp.eql(zz, Fp.ONE)) throw new Error(\"invZ was invalid\");\n        return {\n            x: ax,\n            y: ay\n        };\n    });\n    // NOTE: on exception this will crash 'cached' and no value will be set.\n    // Otherwise true will be return\n    const assertValidMemo = (0, utils_ts_1.memoized)((p)=>{\n        if (p.is0()) {\n            // (0, 1, 0) aka ZERO is invalid in most contexts.\n            // In BLS, ZERO can be serialized, so we allow it.\n            // (0, 0, 0) is invalid representation of ZERO.\n            if (CURVE.allowInfinityPoint && !Fp.is0(p.py)) return;\n            throw new Error(\"bad point: ZERO\");\n        }\n        // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`\n        const { x, y } = p.toAffine();\n        // Check if x, y are valid field elements\n        if (!Fp.isValid(x) || !Fp.isValid(y)) throw new Error(\"bad point: x or y not FE\");\n        if (!isValidXY(x, y)) throw new Error(\"bad point: equation left != right\");\n        if (!p.isTorsionFree()) throw new Error(\"bad point: not in prime-order subgroup\");\n        return true;\n    });\n    /**\n     * Projective Point works in 3d / projective (homogeneous) coordinates: (X, Y, Z) ‚àã (x=X/Z, y=Y/Z)\n     * Default Point works in 2d / affine coordinates: (x, y)\n     * We're doing calculations in projective, because its operations don't require costly inversion.\n     */ class Point {\n        constructor(px, py, pz){\n            if (px == null || !Fp.isValid(px)) throw new Error(\"x required\");\n            if (py == null || !Fp.isValid(py) || Fp.is0(py)) throw new Error(\"y required\");\n            if (pz == null || !Fp.isValid(pz)) throw new Error(\"z required\");\n            this.px = px;\n            this.py = py;\n            this.pz = pz;\n            Object.freeze(this);\n        }\n        // Does not validate if the point is on-curve.\n        // Use fromHex instead, or call assertValidity() later.\n        static fromAffine(p) {\n            const { x, y } = p || {};\n            if (!p || !Fp.isValid(x) || !Fp.isValid(y)) throw new Error(\"invalid affine point\");\n            if (p instanceof Point) throw new Error(\"projective point not allowed\");\n            const is0 = (i)=>Fp.eql(i, Fp.ZERO);\n            // fromAffine(x:0, y:0) would produce (x:0, y:0, z:1), but we need (x:0, y:1, z:0)\n            if (is0(x) && is0(y)) return Point.ZERO;\n            return new Point(x, y, Fp.ONE);\n        }\n        get x() {\n            return this.toAffine().x;\n        }\n        get y() {\n            return this.toAffine().y;\n        }\n        /**\n         * Takes a bunch of Projective Points but executes only one\n         * inversion on all of them. Inversion is very slow operation,\n         * so this improves performance massively.\n         * Optimization: converts a list of projective points to a list of identical points with Z=1.\n         */ static normalizeZ(points) {\n            const toInv = (0, modular_ts_1.FpInvertBatch)(Fp, points.map((p)=>p.pz));\n            return points.map((p, i)=>p.toAffine(toInv[i])).map(Point.fromAffine);\n        }\n        /**\n         * Converts hash string or Uint8Array to Point.\n         * @param hex short/long ECDSA hex\n         */ static fromHex(hex) {\n            const P = Point.fromAffine(fromBytes((0, utils_ts_1.ensureBytes)(\"pointHex\", hex)));\n            P.assertValidity();\n            return P;\n        }\n        // Multiplies generator point by privateKey.\n        static fromPrivateKey(privateKey) {\n            return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));\n        }\n        // Multiscalar Multiplication\n        static msm(points, scalars) {\n            return (0, curve_ts_1.pippenger)(Point, Fn, points, scalars);\n        }\n        // \"Private method\", don't use it directly\n        _setWindowSize(windowSize) {\n            wnaf.setWindowSize(this, windowSize);\n        }\n        // A point on curve is valid if it conforms to equation.\n        assertValidity() {\n            assertValidMemo(this);\n        }\n        hasEvenY() {\n            const { y } = this.toAffine();\n            if (Fp.isOdd) return !Fp.isOdd(y);\n            throw new Error(\"Field doesn't support isOdd\");\n        }\n        /**\n         * Compare one point to another.\n         */ equals(other) {\n            aprjpoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));\n            const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));\n            return U1 && U2;\n        }\n        /**\n         * Flips point to one corresponding to (x, -y) in Affine coordinates.\n         */ negate() {\n            return new Point(this.px, Fp.neg(this.py), this.pz);\n        }\n        // Renes-Costello-Batina exception-free doubling formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 3\n        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.\n        double() {\n            const { a, b } = CURVE;\n            const b3 = Fp.mul(b, _3n);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            let t0 = Fp.mul(X1, X1); // step 1\n            let t1 = Fp.mul(Y1, Y1);\n            let t2 = Fp.mul(Z1, Z1);\n            let t3 = Fp.mul(X1, Y1);\n            t3 = Fp.add(t3, t3); // step 5\n            Z3 = Fp.mul(X1, Z1);\n            Z3 = Fp.add(Z3, Z3);\n            X3 = Fp.mul(a, Z3);\n            Y3 = Fp.mul(b3, t2);\n            Y3 = Fp.add(X3, Y3); // step 10\n            X3 = Fp.sub(t1, Y3);\n            Y3 = Fp.add(t1, Y3);\n            Y3 = Fp.mul(X3, Y3);\n            X3 = Fp.mul(t3, X3);\n            Z3 = Fp.mul(b3, Z3); // step 15\n            t2 = Fp.mul(a, t2);\n            t3 = Fp.sub(t0, t2);\n            t3 = Fp.mul(a, t3);\n            t3 = Fp.add(t3, Z3);\n            Z3 = Fp.add(t0, t0); // step 20\n            t0 = Fp.add(Z3, t0);\n            t0 = Fp.add(t0, t2);\n            t0 = Fp.mul(t0, t3);\n            Y3 = Fp.add(Y3, t0);\n            t2 = Fp.mul(Y1, Z1); // step 25\n            t2 = Fp.add(t2, t2);\n            t0 = Fp.mul(t2, t3);\n            X3 = Fp.sub(X3, t0);\n            Z3 = Fp.mul(t2, t1);\n            Z3 = Fp.add(Z3, Z3); // step 30\n            Z3 = Fp.add(Z3, Z3);\n            return new Point(X3, Y3, Z3);\n        }\n        // Renes-Costello-Batina exception-free addition formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 1\n        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.\n        add(other) {\n            aprjpoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            const a = CURVE.a;\n            const b3 = Fp.mul(CURVE.b, _3n);\n            let t0 = Fp.mul(X1, X2); // step 1\n            let t1 = Fp.mul(Y1, Y2);\n            let t2 = Fp.mul(Z1, Z2);\n            let t3 = Fp.add(X1, Y1);\n            let t4 = Fp.add(X2, Y2); // step 5\n            t3 = Fp.mul(t3, t4);\n            t4 = Fp.add(t0, t1);\n            t3 = Fp.sub(t3, t4);\n            t4 = Fp.add(X1, Z1);\n            let t5 = Fp.add(X2, Z2); // step 10\n            t4 = Fp.mul(t4, t5);\n            t5 = Fp.add(t0, t2);\n            t4 = Fp.sub(t4, t5);\n            t5 = Fp.add(Y1, Z1);\n            X3 = Fp.add(Y2, Z2); // step 15\n            t5 = Fp.mul(t5, X3);\n            X3 = Fp.add(t1, t2);\n            t5 = Fp.sub(t5, X3);\n            Z3 = Fp.mul(a, t4);\n            X3 = Fp.mul(b3, t2); // step 20\n            Z3 = Fp.add(X3, Z3);\n            X3 = Fp.sub(t1, Z3);\n            Z3 = Fp.add(t1, Z3);\n            Y3 = Fp.mul(X3, Z3);\n            t1 = Fp.add(t0, t0); // step 25\n            t1 = Fp.add(t1, t0);\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.mul(b3, t4);\n            t1 = Fp.add(t1, t2);\n            t2 = Fp.sub(t0, t2); // step 30\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.add(t4, t2);\n            t0 = Fp.mul(t1, t4);\n            Y3 = Fp.add(Y3, t0);\n            t0 = Fp.mul(t5, t4); // step 35\n            X3 = Fp.mul(t3, X3);\n            X3 = Fp.sub(X3, t0);\n            t0 = Fp.mul(t3, t1);\n            Z3 = Fp.mul(t5, Z3);\n            Z3 = Fp.add(Z3, t0); // step 40\n            return new Point(X3, Y3, Z3);\n        }\n        subtract(other) {\n            return this.add(other.negate());\n        }\n        is0() {\n            return this.equals(Point.ZERO);\n        }\n        wNAF(n) {\n            return wnaf.wNAFCached(this, n, Point.normalizeZ);\n        }\n        /**\n         * Non-constant-time multiplication. Uses double-and-add algorithm.\n         * It's faster, but should only be used when you don't care about\n         * an exposed private key e.g. sig verification, which works over *public* keys.\n         */ multiplyUnsafe(sc) {\n            const { endo, n: N } = CURVE;\n            (0, utils_ts_1.aInRange)(\"scalar\", sc, _0n, N);\n            const I = Point.ZERO;\n            if (sc === _0n) return I;\n            if (this.is0() || sc === _1n) return this;\n            // Case a: no endomorphism. Case b: has precomputes.\n            if (!endo || wnaf.hasPrecomputes(this)) return wnaf.wNAFCachedUnsafe(this, sc, Point.normalizeZ);\n            // Case c: endomorphism\n            /** See docs for {@link EndomorphismOpts} */ let { k1neg, k1, k2neg, k2 } = endo.splitScalar(sc);\n            let k1p = I;\n            let k2p = I;\n            let d = this;\n            while(k1 > _0n || k2 > _0n){\n                if (k1 & _1n) k1p = k1p.add(d);\n                if (k2 & _1n) k2p = k2p.add(d);\n                d = d.double();\n                k1 >>= _1n;\n                k2 >>= _1n;\n            }\n            if (k1neg) k1p = k1p.negate();\n            if (k2neg) k2p = k2p.negate();\n            k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n            return k1p.add(k2p);\n        }\n        /**\n         * Constant time multiplication.\n         * Uses wNAF method. Windowed method may be 10% faster,\n         * but takes 2x longer to generate and consumes 2x memory.\n         * Uses precomputes when available.\n         * Uses endomorphism for Koblitz curves.\n         * @param scalar by which the point would be multiplied\n         * @returns New point\n         */ multiply(scalar) {\n            const { endo, n: N } = CURVE;\n            (0, utils_ts_1.aInRange)(\"scalar\", scalar, _1n, N);\n            let point, fake; // Fake point is used to const-time mult\n            /** See docs for {@link EndomorphismOpts} */ if (endo) {\n                const { k1neg, k1, k2neg, k2 } = endo.splitScalar(scalar);\n                let { p: k1p, f: f1p } = this.wNAF(k1);\n                let { p: k2p, f: f2p } = this.wNAF(k2);\n                k1p = wnaf.constTimeNegate(k1neg, k1p);\n                k2p = wnaf.constTimeNegate(k2neg, k2p);\n                k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n                point = k1p.add(k2p);\n                fake = f1p.add(f2p);\n            } else {\n                const { p, f } = this.wNAF(scalar);\n                point = p;\n                fake = f;\n            }\n            // Normalize `z` for both points, but return only real one\n            return Point.normalizeZ([\n                point,\n                fake\n            ])[0];\n        }\n        /**\n         * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.\n         * Not using Strauss-Shamir trick: precomputation tables are faster.\n         * The trick could be useful if both P and Q are not G (not in our case).\n         * @returns non-zero affine point\n         */ multiplyAndAddUnsafe(Q, a, b) {\n            const G = Point.BASE; // No Strauss-Shamir trick: we have 10% faster G precomputes\n            const mul = (P, a // Select faster multiply() method\n            )=>a === _0n || a === _1n || !P.equals(G) ? P.multiplyUnsafe(a) : P.multiply(a);\n            const sum = mul(this, a).add(mul(Q, b));\n            return sum.is0() ? undefined : sum;\n        }\n        // Converts Projective point to affine (x, y) coordinates.\n        // Can accept precomputed Z^-1 - for example, from invertBatch.\n        // (x, y, z) ‚àã (x=x/z, y=y/z)\n        toAffine(iz) {\n            return toAffineMemo(this, iz);\n        }\n        isTorsionFree() {\n            const { h: cofactor, isTorsionFree } = CURVE;\n            if (cofactor === _1n) return true; // No subgroups, always torsion-free\n            if (isTorsionFree) return isTorsionFree(Point, this);\n            throw new Error(\"isTorsionFree() has not been declared for the elliptic curve\");\n        }\n        clearCofactor() {\n            const { h: cofactor, clearCofactor } = CURVE;\n            if (cofactor === _1n) return this; // Fast-path\n            if (clearCofactor) return clearCofactor(Point, this);\n            return this.multiplyUnsafe(CURVE.h);\n        }\n        toRawBytes(isCompressed = true) {\n            (0, utils_ts_1.abool)(\"isCompressed\", isCompressed);\n            this.assertValidity();\n            return toBytes(Point, this, isCompressed);\n        }\n        toHex(isCompressed = true) {\n            (0, utils_ts_1.abool)(\"isCompressed\", isCompressed);\n            return (0, utils_ts_1.bytesToHex)(this.toRawBytes(isCompressed));\n        }\n    }\n    // base / generator point\n    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);\n    // zero / infinity / identity point\n    Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO); // 0, 1, 0\n    const { endo, nBitLength } = CURVE;\n    const wnaf = (0, curve_ts_1.wNAF)(Point, endo ? Math.ceil(nBitLength / 2) : nBitLength);\n    return {\n        CURVE,\n        ProjectivePoint: Point,\n        normPrivateKeyToScalar,\n        weierstrassEquation,\n        isWithinCurveOrder\n    };\n}\nfunction validateOpts(curve) {\n    const opts = (0, curve_ts_1.validateBasic)(curve);\n    (0, utils_ts_1.validateObject)(opts, {\n        hash: \"hash\",\n        hmac: \"function\",\n        randomBytes: \"function\"\n    }, {\n        bits2int: \"function\",\n        bits2int_modN: \"function\",\n        lowS: \"boolean\"\n    });\n    return Object.freeze({\n        lowS: true,\n        ...opts\n    });\n}\n/**\n * Creates short weierstrass curve and ECDSA signature methods for it.\n * @example\n * import { Field } from '@noble/curves/abstract/modular';\n * // Before that, define BigInt-s: a, b, p, n, Gx, Gy\n * const curve = weierstrass({ a, b, Fp: Field(p), n, Gx, Gy, h: 1n })\n */ function weierstrass(curveDef) {\n    const CURVE = validateOpts(curveDef);\n    const { Fp, n: CURVE_ORDER, nByteLength, nBitLength } = CURVE;\n    const compressedLen = Fp.BYTES + 1; // e.g. 33 for 32\n    const uncompressedLen = 2 * Fp.BYTES + 1; // e.g. 65 for 32\n    function modN(a) {\n        return (0, modular_ts_1.mod)(a, CURVE_ORDER);\n    }\n    function invN(a) {\n        return (0, modular_ts_1.invert)(a, CURVE_ORDER);\n    }\n    const { ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder } = weierstrassPoints({\n        ...CURVE,\n        toBytes (_c, point, isCompressed) {\n            const a = point.toAffine();\n            const x = Fp.toBytes(a.x);\n            const cat = utils_ts_1.concatBytes;\n            (0, utils_ts_1.abool)(\"isCompressed\", isCompressed);\n            if (isCompressed) {\n                return cat(Uint8Array.from([\n                    point.hasEvenY() ? 0x02 : 0x03\n                ]), x);\n            } else {\n                return cat(Uint8Array.from([\n                    0x04\n                ]), x, Fp.toBytes(a.y));\n            }\n        },\n        fromBytes (bytes) {\n            const len = bytes.length;\n            const head = bytes[0];\n            const tail = bytes.subarray(1);\n            // this.assertValidity() is done inside of fromHex\n            if (len === compressedLen && (head === 0x02 || head === 0x03)) {\n                const x = (0, utils_ts_1.bytesToNumberBE)(tail);\n                if (!(0, utils_ts_1.inRange)(x, _1n, Fp.ORDER)) throw new Error(\"Point is not on curve\");\n                const y2 = weierstrassEquation(x); // y¬≤ = x¬≥ + ax + b\n                let y;\n                try {\n                    y = Fp.sqrt(y2); // y = y¬≤ ^ (p+1)/4\n                } catch (sqrtError) {\n                    const suffix = sqrtError instanceof Error ? \": \" + sqrtError.message : \"\";\n                    throw new Error(\"Point is not on curve\" + suffix);\n                }\n                const isYOdd = (y & _1n) === _1n;\n                // ECDSA\n                const isHeadOdd = (head & 1) === 1;\n                if (isHeadOdd !== isYOdd) y = Fp.neg(y);\n                return {\n                    x,\n                    y\n                };\n            } else if (len === uncompressedLen && head === 0x04) {\n                const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n                const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n                return {\n                    x,\n                    y\n                };\n            } else {\n                const cl = compressedLen;\n                const ul = uncompressedLen;\n                throw new Error(\"invalid Point, expected length of \" + cl + \", or uncompressed \" + ul + \", got \" + len);\n            }\n        }\n    });\n    function isBiggerThanHalfOrder(number) {\n        const HALF = CURVE_ORDER >> _1n;\n        return number > HALF;\n    }\n    function normalizeS(s) {\n        return isBiggerThanHalfOrder(s) ? modN(-s) : s;\n    }\n    // slice bytes num\n    const slcNum = (b, from, to)=>(0, utils_ts_1.bytesToNumberBE)(b.slice(from, to));\n    /**\n     * ECDSA signature with its (r, s) properties. Supports DER & compact representations.\n     */ class Signature {\n        constructor(r, s, recovery){\n            (0, utils_ts_1.aInRange)(\"r\", r, _1n, CURVE_ORDER); // r in [1..N]\n            (0, utils_ts_1.aInRange)(\"s\", s, _1n, CURVE_ORDER); // s in [1..N]\n            this.r = r;\n            this.s = s;\n            if (recovery != null) this.recovery = recovery;\n            Object.freeze(this);\n        }\n        // pair (bytes of r, bytes of s)\n        static fromCompact(hex) {\n            const l = nByteLength;\n            hex = (0, utils_ts_1.ensureBytes)(\"compactSignature\", hex, l * 2);\n            return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));\n        }\n        // DER encoded ECDSA signature\n        // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script\n        static fromDER(hex) {\n            const { r, s } = exports.DER.toSig((0, utils_ts_1.ensureBytes)(\"DER\", hex));\n            return new Signature(r, s);\n        }\n        /**\n         * @todo remove\n         * @deprecated\n         */ assertValidity() {}\n        addRecoveryBit(recovery) {\n            return new Signature(this.r, this.s, recovery);\n        }\n        recoverPublicKey(msgHash) {\n            const { r, s, recovery: rec } = this;\n            const h = bits2int_modN((0, utils_ts_1.ensureBytes)(\"msgHash\", msgHash)); // Truncate hash\n            if (rec == null || ![\n                0,\n                1,\n                2,\n                3\n            ].includes(rec)) throw new Error(\"recovery id invalid\");\n            const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;\n            if (radj >= Fp.ORDER) throw new Error(\"recovery id 2 or 3 invalid\");\n            const prefix = (rec & 1) === 0 ? \"02\" : \"03\";\n            const R = Point.fromHex(prefix + numToSizedHex(radj, Fp.BYTES));\n            const ir = invN(radj); // r^-1\n            const u1 = modN(-h * ir); // -hr^-1\n            const u2 = modN(s * ir); // sr^-1\n            const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2); // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1)\n            if (!Q) throw new Error(\"point at infinify\"); // unsafe is fine: no priv data leaked\n            Q.assertValidity();\n            return Q;\n        }\n        // Signatures should be low-s, to prevent malleability.\n        hasHighS() {\n            return isBiggerThanHalfOrder(this.s);\n        }\n        normalizeS() {\n            return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;\n        }\n        // DER-encoded\n        toDERRawBytes() {\n            return (0, utils_ts_1.hexToBytes)(this.toDERHex());\n        }\n        toDERHex() {\n            return exports.DER.hexFromSig(this);\n        }\n        // padded bytes of r, then padded bytes of s\n        toCompactRawBytes() {\n            return (0, utils_ts_1.hexToBytes)(this.toCompactHex());\n        }\n        toCompactHex() {\n            const l = nByteLength;\n            return numToSizedHex(this.r, l) + numToSizedHex(this.s, l);\n        }\n    }\n    const utils = {\n        isValidPrivateKey (privateKey) {\n            try {\n                normPrivateKeyToScalar(privateKey);\n                return true;\n            } catch (error) {\n                return false;\n            }\n        },\n        normPrivateKeyToScalar: normPrivateKeyToScalar,\n        /**\n         * Produces cryptographically secure private key from random of size\n         * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.\n         */ randomPrivateKey: ()=>{\n            const length = (0, modular_ts_1.getMinHashLength)(CURVE.n);\n            return (0, modular_ts_1.mapHashToField)(CURVE.randomBytes(length), CURVE.n);\n        },\n        /**\n         * Creates precompute table for an arbitrary EC point. Makes point \"cached\".\n         * Allows to massively speed-up `point.multiply(scalar)`.\n         * @returns cached point\n         * @example\n         * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));\n         * fast.multiply(privKey); // much faster ECDH now\n         */ precompute (windowSize = 8, point = Point.BASE) {\n            point._setWindowSize(windowSize);\n            point.multiply(BigInt(3)); // 3 is arbitrary, just need any number here\n            return point;\n        }\n    };\n    /**\n     * Computes public key for a private key. Checks for validity of the private key.\n     * @param privateKey private key\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns Public key, full when isCompressed=false; short when isCompressed=true\n     */ function getPublicKey(privateKey, isCompressed = true) {\n        return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);\n    }\n    /**\n     * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.\n     */ function isProbPub(item) {\n        if (typeof item === \"bigint\") return false;\n        if (item instanceof Point) return true;\n        const arr = (0, utils_ts_1.ensureBytes)(\"key\", item);\n        const len = arr.length;\n        const fpl = Fp.BYTES;\n        const compLen = fpl + 1; // e.g. 33 for 32\n        const uncompLen = 2 * fpl + 1; // e.g. 65 for 32\n        if (CURVE.allowedPrivateKeyLengths || nByteLength === compLen) {\n            return undefined;\n        } else {\n            return len === compLen || len === uncompLen;\n        }\n    }\n    /**\n     * ECDH (Elliptic Curve Diffie Hellman).\n     * Computes shared public key from private key and public key.\n     * Checks: 1) private key validity 2) shared key is on-curve.\n     * Does NOT hash the result.\n     * @param privateA private key\n     * @param publicB different public key\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns shared public key\n     */ function getSharedSecret(privateA, publicB, isCompressed = true) {\n        if (isProbPub(privateA) === true) throw new Error(\"first arg must be private key\");\n        if (isProbPub(publicB) === false) throw new Error(\"second arg must be public key\");\n        const b = Point.fromHex(publicB); // check for being on-curve\n        return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);\n    }\n    // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.\n    // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.\n    // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.\n    // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors\n    const bits2int = CURVE.bits2int || function(bytes) {\n        // Our custom check \"just in case\", for protection against DoS\n        if (bytes.length > 8192) throw new Error(\"input is too large\");\n        // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)\n        // for some cases, since bytes.length * 8 is not actual bitLength.\n        const num = (0, utils_ts_1.bytesToNumberBE)(bytes); // check for == u8 done here\n        const delta = bytes.length * 8 - nBitLength; // truncate to nBitLength leftmost bits\n        return delta > 0 ? num >> BigInt(delta) : num;\n    };\n    const bits2int_modN = CURVE.bits2int_modN || function(bytes) {\n        return modN(bits2int(bytes)); // can't use bytesToNumberBE here\n    };\n    // NOTE: pads output with zero as per spec\n    const ORDER_MASK = (0, utils_ts_1.bitMask)(nBitLength);\n    /**\n     * Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`.\n     */ function int2octets(num) {\n        (0, utils_ts_1.aInRange)(\"num < 2^\" + nBitLength, num, _0n, ORDER_MASK);\n        // works with order, can have different size than numToField!\n        return (0, utils_ts_1.numberToBytesBE)(num, nByteLength);\n    }\n    // Steps A, D of RFC6979 3.2\n    // Creates RFC6979 seed; converts msg/privKey to numbers.\n    // Used only in sign, not in verify.\n    // NOTE: we cannot assume here that msgHash has same amount of bytes as curve order,\n    // this will be invalid at least for P521. Also it can be bigger for P224 + SHA256\n    function prepSig(msgHash, privateKey, opts = defaultSigOpts) {\n        if ([\n            \"recovered\",\n            \"canonical\"\n        ].some((k)=>k in opts)) throw new Error(\"sign() legacy options not supported\");\n        const { hash, randomBytes } = CURVE;\n        let { lowS, prehash, extraEntropy: ent } = opts; // generates low-s sigs by default\n        if (lowS == null) lowS = true; // RFC6979 3.2: we skip step A, because we already provide hash\n        msgHash = (0, utils_ts_1.ensureBytes)(\"msgHash\", msgHash);\n        validateSigVerOpts(opts);\n        if (prehash) msgHash = (0, utils_ts_1.ensureBytes)(\"prehashed msgHash\", hash(msgHash));\n        // We can't later call bits2octets, since nested bits2int is broken for curves\n        // with nBitLength % 8 !== 0. Because of that, we unwrap it here as int2octets call.\n        // const bits2octets = (bits) => int2octets(bits2int_modN(bits))\n        const h1int = bits2int_modN(msgHash);\n        const d = normPrivateKeyToScalar(privateKey); // validate private key, convert to bigint\n        const seedArgs = [\n            int2octets(d),\n            int2octets(h1int)\n        ];\n        // extraEntropy. RFC6979 3.6: additional k' (optional).\n        if (ent != null && ent !== false) {\n            // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')\n            const e = ent === true ? randomBytes(Fp.BYTES) : ent; // generate random bytes OR pass as-is\n            seedArgs.push((0, utils_ts_1.ensureBytes)(\"extraEntropy\", e)); // check for being bytes\n        }\n        const seed = (0, utils_ts_1.concatBytes)(...seedArgs); // Step D of RFC6979 3.2\n        const m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!\n        // Converts signature params into point w r/s, checks result for validity.\n        function k2sig(kBytes) {\n            // RFC 6979 Section 3.2, step 3: k = bits2int(T)\n            const k = bits2int(kBytes); // Cannot use fields methods, since it is group element\n            if (!isWithinCurveOrder(k)) return; // Important: all mod() calls here must be done over N\n            const ik = invN(k); // k^-1 mod n\n            const q = Point.BASE.multiply(k).toAffine(); // q = Gk\n            const r = modN(q.x); // r = q.x mod n\n            if (r === _0n) return;\n            // Can use scalar blinding b^-1(bm + bdr) where b ‚àà [1,q‚àí1] according to\n            // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:\n            // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT\n            const s = modN(ik * modN(m + r * d)); // Not using blinding here\n            if (s === _0n) return;\n            let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n); // recovery bit (2 or 3, when q.x > n)\n            let normS = s;\n            if (lowS && isBiggerThanHalfOrder(s)) {\n                normS = normalizeS(s); // if lowS was passed, ensure s is always\n                recovery ^= 1; // // in the bottom half of N\n            }\n            return new Signature(r, normS, recovery); // use normS, not s\n        }\n        return {\n            seed,\n            k2sig\n        };\n    }\n    const defaultSigOpts = {\n        lowS: CURVE.lowS,\n        prehash: false\n    };\n    const defaultVerOpts = {\n        lowS: CURVE.lowS,\n        prehash: false\n    };\n    /**\n     * Signs message hash with a private key.\n     * ```\n     * sign(m, d, k) where\n     *   (x, y) = G √ó k\n     *   r = x mod n\n     *   s = (m + dr)/k mod n\n     * ```\n     * @param msgHash NOT message. msg needs to be hashed to `msgHash`, or use `prehash`.\n     * @param privKey private key\n     * @param opts lowS for non-malleable sigs. extraEntropy for mixing randomness into k. prehash will hash first arg.\n     * @returns signature with recovery param\n     */ function sign(msgHash, privKey, opts = defaultSigOpts) {\n        const { seed, k2sig } = prepSig(msgHash, privKey, opts); // Steps A, D of RFC6979 3.2.\n        const C = CURVE;\n        const drbg = (0, utils_ts_1.createHmacDrbg)(C.hash.outputLen, C.nByteLength, C.hmac);\n        return drbg(seed, k2sig); // Steps B, C, D, E, F, G\n    }\n    // Enable precomputes. Slows down first publicKey computation by 20ms.\n    Point.BASE._setWindowSize(8);\n    // utils.precompute(8, ProjectivePoint.BASE)\n    /**\n     * Verifies a signature against message hash and public key.\n     * Rejects lowS signatures by default: to override,\n     * specify option `{lowS: false}`. Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:\n     *\n     * ```\n     * verify(r, s, h, P) where\n     *   U1 = hs^-1 mod n\n     *   U2 = rs^-1 mod n\n     *   R = U1‚ãÖG - U2‚ãÖP\n     *   mod(R.x, n) == r\n     * ```\n     */ function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {\n        const sg = signature;\n        msgHash = (0, utils_ts_1.ensureBytes)(\"msgHash\", msgHash);\n        publicKey = (0, utils_ts_1.ensureBytes)(\"publicKey\", publicKey);\n        const { lowS, prehash, format } = opts;\n        // Verify opts, deduce signature format\n        validateSigVerOpts(opts);\n        if (\"strict\" in opts) throw new Error(\"options.strict was renamed to lowS\");\n        if (format !== undefined && format !== \"compact\" && format !== \"der\") throw new Error(\"format must be compact or der\");\n        const isHex = typeof sg === \"string\" || (0, utils_ts_1.isBytes)(sg);\n        const isObj = !isHex && !format && typeof sg === \"object\" && sg !== null && typeof sg.r === \"bigint\" && typeof sg.s === \"bigint\";\n        if (!isHex && !isObj) throw new Error(\"invalid signature, expected Uint8Array, hex string or Signature instance\");\n        let _sig = undefined;\n        let P;\n        try {\n            if (isObj) _sig = new Signature(sg.r, sg.s);\n            if (isHex) {\n                // Signature can be represented in 2 ways: compact (2*nByteLength) & DER (variable-length).\n                // Since DER can also be 2*nByteLength bytes, we check for it first.\n                try {\n                    if (format !== \"compact\") _sig = Signature.fromDER(sg);\n                } catch (derError) {\n                    if (!(derError instanceof exports.DER.Err)) throw derError;\n                }\n                if (!_sig && format !== \"der\") _sig = Signature.fromCompact(sg);\n            }\n            P = Point.fromHex(publicKey);\n        } catch (error) {\n            return false;\n        }\n        if (!_sig) return false;\n        if (lowS && _sig.hasHighS()) return false;\n        if (prehash) msgHash = CURVE.hash(msgHash);\n        const { r, s } = _sig;\n        const h = bits2int_modN(msgHash); // Cannot use fields methods, since it is group element\n        const is = invN(s); // s^-1\n        const u1 = modN(h * is); // u1 = hs^-1 mod n\n        const u2 = modN(r * is); // u2 = rs^-1 mod n\n        const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine(); // R = u1‚ãÖG + u2‚ãÖP\n        if (!R) return false;\n        const v = modN(R.x);\n        return v === r;\n    }\n    return {\n        CURVE,\n        getPublicKey,\n        getSharedSecret,\n        sign,\n        verify,\n        ProjectivePoint: Point,\n        Signature,\n        utils\n    };\n}\n/**\n * Implementation of the Shallue and van de Woestijne method for any weierstrass curve.\n * TODO: check if there is a way to merge this with uvRatio in Edwards; move to modular.\n * b = True and y = sqrt(u / v) if (u / v) is square in F, and\n * b = False and y = sqrt(Z * (u / v)) otherwise.\n * @param Fp\n * @param Z\n * @returns\n */ function SWUFpSqrtRatio(Fp, Z) {\n    // Generic implementation\n    const q = Fp.ORDER;\n    let l = _0n;\n    for(let o = q - _1n; o % _2n === _0n; o /= _2n)l += _1n;\n    const c1 = l; // 1. c1, the largest integer such that 2^c1 divides q - 1.\n    // We need 2n ** c1 and 2n ** (c1-1). We can't use **; but we can use <<.\n    // 2n ** c1 == 2n << (c1-1)\n    const _2n_pow_c1_1 = _2n << c1 - _1n - _1n;\n    const _2n_pow_c1 = _2n_pow_c1_1 * _2n;\n    const c2 = (q - _1n) / _2n_pow_c1; // 2. c2 = (q - 1) / (2^c1)  # Integer arithmetic\n    const c3 = (c2 - _1n) / _2n; // 3. c3 = (c2 - 1) / 2            # Integer arithmetic\n    const c4 = _2n_pow_c1 - _1n; // 4. c4 = 2^c1 - 1                # Integer arithmetic\n    const c5 = _2n_pow_c1_1; // 5. c5 = 2^(c1 - 1)                  # Integer arithmetic\n    const c6 = Fp.pow(Z, c2); // 6. c6 = Z^c2\n    const c7 = Fp.pow(Z, (c2 + _1n) / _2n); // 7. c7 = Z^((c2 + 1) / 2)\n    let sqrtRatio = (u, v)=>{\n        let tv1 = c6; // 1. tv1 = c6\n        let tv2 = Fp.pow(v, c4); // 2. tv2 = v^c4\n        let tv3 = Fp.sqr(tv2); // 3. tv3 = tv2^2\n        tv3 = Fp.mul(tv3, v); // 4. tv3 = tv3 * v\n        let tv5 = Fp.mul(u, tv3); // 5. tv5 = u * tv3\n        tv5 = Fp.pow(tv5, c3); // 6. tv5 = tv5^c3\n        tv5 = Fp.mul(tv5, tv2); // 7. tv5 = tv5 * tv2\n        tv2 = Fp.mul(tv5, v); // 8. tv2 = tv5 * v\n        tv3 = Fp.mul(tv5, u); // 9. tv3 = tv5 * u\n        let tv4 = Fp.mul(tv3, tv2); // 10. tv4 = tv3 * tv2\n        tv5 = Fp.pow(tv4, c5); // 11. tv5 = tv4^c5\n        let isQR = Fp.eql(tv5, Fp.ONE); // 12. isQR = tv5 == 1\n        tv2 = Fp.mul(tv3, c7); // 13. tv2 = tv3 * c7\n        tv5 = Fp.mul(tv4, tv1); // 14. tv5 = tv4 * tv1\n        tv3 = Fp.cmov(tv2, tv3, isQR); // 15. tv3 = CMOV(tv2, tv3, isQR)\n        tv4 = Fp.cmov(tv5, tv4, isQR); // 16. tv4 = CMOV(tv5, tv4, isQR)\n        // 17. for i in (c1, c1 - 1, ..., 2):\n        for(let i = c1; i > _1n; i--){\n            let tv5 = i - _2n; // 18.    tv5 = i - 2\n            tv5 = _2n << tv5 - _1n; // 19.    tv5 = 2^tv5\n            let tvv5 = Fp.pow(tv4, tv5); // 20.    tv5 = tv4^tv5\n            const e1 = Fp.eql(tvv5, Fp.ONE); // 21.    e1 = tv5 == 1\n            tv2 = Fp.mul(tv3, tv1); // 22.    tv2 = tv3 * tv1\n            tv1 = Fp.mul(tv1, tv1); // 23.    tv1 = tv1 * tv1\n            tvv5 = Fp.mul(tv4, tv1); // 24.    tv5 = tv4 * tv1\n            tv3 = Fp.cmov(tv2, tv3, e1); // 25.    tv3 = CMOV(tv2, tv3, e1)\n            tv4 = Fp.cmov(tvv5, tv4, e1); // 26.    tv4 = CMOV(tv5, tv4, e1)\n        }\n        return {\n            isValid: isQR,\n            value: tv3\n        };\n    };\n    if (Fp.ORDER % _4n === _3n) {\n        // sqrt_ratio_3mod4(u, v)\n        const c1 = (Fp.ORDER - _3n) / _4n; // 1. c1 = (q - 3) / 4     # Integer arithmetic\n        const c2 = Fp.sqrt(Fp.neg(Z)); // 2. c2 = sqrt(-Z)\n        sqrtRatio = (u, v)=>{\n            let tv1 = Fp.sqr(v); // 1. tv1 = v^2\n            const tv2 = Fp.mul(u, v); // 2. tv2 = u * v\n            tv1 = Fp.mul(tv1, tv2); // 3. tv1 = tv1 * tv2\n            let y1 = Fp.pow(tv1, c1); // 4. y1 = tv1^c1\n            y1 = Fp.mul(y1, tv2); // 5. y1 = y1 * tv2\n            const y2 = Fp.mul(y1, c2); // 6. y2 = y1 * c2\n            const tv3 = Fp.mul(Fp.sqr(y1), v); // 7. tv3 = y1^2; 8. tv3 = tv3 * v\n            const isQR = Fp.eql(tv3, u); // 9. isQR = tv3 == u\n            let y = Fp.cmov(y2, y1, isQR); // 10. y = CMOV(y2, y1, isQR)\n            return {\n                isValid: isQR,\n                value: y\n            }; // 11. return (isQR, y) isQR ? y : y*c2\n        };\n    }\n    // No curves uses that\n    // if (Fp.ORDER % _8n === _5n) // sqrt_ratio_5mod8\n    return sqrtRatio;\n}\n/**\n * Simplified Shallue-van de Woestijne-Ulas Method\n * https://www.rfc-editor.org/rfc/rfc9380#section-6.6.2\n */ function mapToCurveSimpleSWU(Fp, opts) {\n    (0, modular_ts_1.validateField)(Fp);\n    if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z)) throw new Error(\"mapToCurveSimpleSWU: invalid opts\");\n    const sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);\n    if (!Fp.isOdd) throw new Error(\"Fp.isOdd is not implemented!\");\n    // Input: u, an element of F.\n    // Output: (x, y), a point on E.\n    return (u)=>{\n        // prettier-ignore\n        let tv1, tv2, tv3, tv4, tv5, tv6, x, y;\n        tv1 = Fp.sqr(u); // 1.  tv1 = u^2\n        tv1 = Fp.mul(tv1, opts.Z); // 2.  tv1 = Z * tv1\n        tv2 = Fp.sqr(tv1); // 3.  tv2 = tv1^2\n        tv2 = Fp.add(tv2, tv1); // 4.  tv2 = tv2 + tv1\n        tv3 = Fp.add(tv2, Fp.ONE); // 5.  tv3 = tv2 + 1\n        tv3 = Fp.mul(tv3, opts.B); // 6.  tv3 = B * tv3\n        tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)); // 7.  tv4 = CMOV(Z, -tv2, tv2 != 0)\n        tv4 = Fp.mul(tv4, opts.A); // 8.  tv4 = A * tv4\n        tv2 = Fp.sqr(tv3); // 9.  tv2 = tv3^2\n        tv6 = Fp.sqr(tv4); // 10. tv6 = tv4^2\n        tv5 = Fp.mul(tv6, opts.A); // 11. tv5 = A * tv6\n        tv2 = Fp.add(tv2, tv5); // 12. tv2 = tv2 + tv5\n        tv2 = Fp.mul(tv2, tv3); // 13. tv2 = tv2 * tv3\n        tv6 = Fp.mul(tv6, tv4); // 14. tv6 = tv6 * tv4\n        tv5 = Fp.mul(tv6, opts.B); // 15. tv5 = B * tv6\n        tv2 = Fp.add(tv2, tv5); // 16. tv2 = tv2 + tv5\n        x = Fp.mul(tv1, tv3); // 17.   x = tv1 * tv3\n        const { isValid, value } = sqrtRatio(tv2, tv6); // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)\n        y = Fp.mul(tv1, u); // 19.   y = tv1 * u  -> Z * u^3 * y1\n        y = Fp.mul(y, value); // 20.   y = y * y1\n        x = Fp.cmov(x, tv3, isValid); // 21.   x = CMOV(x, tv3, is_gx1_square)\n        y = Fp.cmov(y, value, isValid); // 22.   y = CMOV(y, y1, is_gx1_square)\n        const e1 = Fp.isOdd(u) === Fp.isOdd(y); // 23.  e1 = sgn0(u) == sgn0(y)\n        y = Fp.cmov(Fp.neg(y), y, e1); // 24.   y = CMOV(-y, y, e1)\n        const tv4_inv = (0, modular_ts_1.FpInvertBatch)(Fp, [\n            tv4\n        ], true)[0];\n        x = Fp.mul(x, tv4_inv); // 25.   x = x / tv4\n        return {\n            x,\n            y\n        };\n    };\n} //# sourceMappingURL=weierstrass.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9hYnN0cmFjdC93ZWllcnN0cmFzcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsV0FBVyxHQUFHQSxjQUFjLEdBQUcsS0FBSztBQUNwQ0EseUJBQXlCLEdBQUdJO0FBQzVCSixtQkFBbUIsR0FBR0s7QUFDdEJMLHNCQUFzQixHQUFHTTtBQUN6Qk4sMkJBQTJCLEdBQUdPO0FBQzlCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQXNDQyxHQUNELG9FQUFvRSxHQUNwRSxrQkFBa0I7QUFDbEIsTUFBTUMsYUFBYUMsbUJBQU9BLENBQUMsd0VBQVk7QUFDdkMsa0JBQWtCO0FBQ2xCLE1BQU1DLGVBQWVELG1CQUFPQSxDQUFDLDRFQUFjO0FBQzNDLGtCQUFrQjtBQUNsQixNQUFNRSxhQUFhRixtQkFBT0EsQ0FBQyx3RUFBWTtBQUN2QyxTQUFTRyxtQkFBbUJDLElBQUk7SUFDNUIsSUFBSUEsS0FBS0MsSUFBSSxLQUFLQyxXQUNkLENBQUMsR0FBR0osV0FBV0ssS0FBSyxFQUFFLFFBQVFILEtBQUtDLElBQUk7SUFDM0MsSUFBSUQsS0FBS0ksT0FBTyxLQUFLRixXQUNqQixDQUFDLEdBQUdKLFdBQVdLLEtBQUssRUFBRSxXQUFXSCxLQUFLSSxPQUFPO0FBQ3JEO0FBQ0EsU0FBU0Msa0JBQWtCQyxLQUFLO0lBQzVCLE1BQU1OLE9BQU8sQ0FBQyxHQUFHTCxXQUFXWSxhQUFhLEVBQUVEO0lBQzFDLElBQUdSLFdBQVdVLGNBQWMsRUFBRVIsTUFBTTtRQUNqQ1MsR0FBRztRQUNIQyxHQUFHO0lBQ1AsR0FBRztRQUNDQyxvQkFBb0I7UUFDcEJDLDBCQUEwQjtRQUMxQkMsZUFBZTtRQUNmQyxXQUFXO1FBQ1hDLGVBQWU7UUFDZkMsU0FBUztRQUNUQyxnQkFBZ0I7SUFDcEI7SUFDQSxNQUFNLEVBQUVDLElBQUksRUFBRUMs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UUFDakdwUSxJQUFJM0UsR0FBR21GLEdBQUcsQ0FBQytPLEtBQUtELElBQUkscUNBQXFDO1FBQ3pEdFAsSUFBSTNFLEdBQUdtRixHQUFHLENBQUNSLEdBQUcxRyxRQUFRLG1CQUFtQjtRQUN6Q3lHLElBQUkxRSxHQUFHd1UsSUFBSSxDQUFDOVAsR0FBRzBQLEtBQUt4TSxVQUFVLHdDQUF3QztRQUN0RWpELElBQUkzRSxHQUFHd1UsSUFBSSxDQUFDN1AsR0FBRzFHLE9BQU8ySixVQUFVLHVDQUF1QztRQUN2RSxNQUFNOE0sS0FBSzFVLEdBQUdtSixLQUFLLENBQUM4SyxPQUFPalUsR0FBR21KLEtBQUssQ0FBQ3hFLElBQUksK0JBQStCO1FBQ3ZFQSxJQUFJM0UsR0FBR3dVLElBQUksQ0FBQ3hVLEdBQUc4SixHQUFHLENBQUNuRixJQUFJQSxHQUFHK1AsS0FBSyw0QkFBNEI7UUFDM0QsTUFBTU0sVUFBVSxDQUFDLEdBQUd0VyxhQUFhd0osYUFBYSxFQUFFbEksSUFBSTtZQUFDc1U7U0FBSSxFQUFFLEtBQUssQ0FBQyxFQUFFO1FBQ25FNVAsSUFBSTFFLEdBQUdtRixHQUFHLENBQUNULEdBQUdzUSxVQUFVLG9CQUFvQjtRQUM1QyxPQUFPO1lBQUV0UTtZQUFHQztRQUFFO0lBQ2xCO0FBQ0osRUFDQSx1Q0FBdUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mYXJjYXN0ZXJzdGF0cy8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2Fic3RyYWN0L3dlaWVyc3RyYXNzLmpzPzEzYjgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkRFUiA9IGV4cG9ydHMuREVSRXJyID0gdm9pZCAwO1xuZXhwb3J0cy53ZWllcnN0cmFzc1BvaW50cyA9IHdlaWVyc3RyYXNzUG9pbnRzO1xuZXhwb3J0cy53ZWllcnN0cmFzcyA9IHdlaWVyc3RyYXNzO1xuZXhwb3J0cy5TV1VGcFNxcnRSYXRpbyA9IFNXVUZwU3FydFJhdGlvO1xuZXhwb3J0cy5tYXBUb0N1cnZlU2ltcGxlU1dVID0gbWFwVG9DdXJ2ZVNpbXBsZVNXVTtcbi8qKlxuICogU2hvcnQgV2VpZXJzdHJhc3MgY3VydmUgbWV0aG9kcy4gVGhlIGZvcm11bGEgaXM6IHnCsiA9IHjCsyArIGF4ICsgYi5cbiAqXG4gKiAjIyMgUGFyYW1ldGVyc1xuICpcbiAqIFRvIGluaXRpYWxpemUgYSB3ZWllcnN0cmFzcyBjdXJ2ZSwgb25lIG5lZWRzIHRvIHBhc3MgZm9sbG93aW5nIHBhcmFtczpcbiAqXG4gKiAqIGE6IGZvcm11bGEgcGFyYW1cbiAqICogYjogZm9ybXVsYSBwYXJhbVxuICogKiBGcDogZmluaXRlIGZpZWxkIG9mIHByaW1lIGNoYXJhY3RlcmlzdGljIFA7IG1heSBiZSBjb21wbGV4IChGcDIpLiBBcml0aG1ldGljcyBpcyBkb25lIGluIGZpZWxkXG4gKiAqIG46IG9yZGVyIG9mIHByaW1lIHN1Ymdyb3VwIGEuay5hIHRvdGFsIGFtb3VudCBvZiB2YWxpZCBjdXJ2ZSBwb2ludHNcbiAqICogR3g6IEJhc2UgcG9pbnQgKHgsIHkpIGFrYSBnZW5lcmF0b3IgcG9pbnQuIEd4ID0geCBjb29yZGluYXRlXG4gKiAqIEd5OiAuLi55IGNvb3JkaW5hdGVcbiAqICogaDogY29mYWN0b3IsIHVzdWFsbHkgMS4gaCpuID0gY3VydmUgZ3JvdXAgb3JkZXIgKG4gaXMgb25seSBzdWJncm91cCBvcmRlcilcbiAqICogbG93Uzogd2hldGhlciB0byBlbmFibGUgKGRlZmF1bHQpIG9yIGRpc2FibGUgXCJsb3ctc1wiIG5vbi1tYWxsZWFibGUgc2lnbmF0dXJlc1xuICpcbiAqICMjIyBEZXNpZ24gcmF0aW9uYWxlIGZvciB0eXBlc1xuICpcbiAqICogSW50ZXJhY3Rpb24gYmV0d2VlbiBjbGFzc2VzIGZyb20gZGlmZmVyZW50IGN1cnZlcyBzaG91bGQgZmFpbDpcbiAqICAgYGsyNTYuUG9pbnQuQkFTRS5hZGQocDI1Ni5Qb2ludC5CQVNFKWBcbiAqICogRm9yIHRoaXMgcHVycG9zZSB3ZSB3YW50IHRvIHVzZSBgaW5zdGFuY2VvZmAgb3BlcmF0b3IsIHdoaWNoIGlzIGZhc3QgYW5kIHdvcmtzIGR1cmluZyBydW50aW1lXG4gKiAqIERpZmZlcmVudCBjYWxscyBvZiBgY3VydmUoKWAgd291bGQgcmV0dXJuIGRpZmZlcmVudCBjbGFzc2VzIC1cbiAqICAgYGN1cnZlKHBhcmFtcykgIT09IGN1cnZlKHBhcmFtcylgOiBpZiBzb21lYm9keSBkZWNpZGVkIHRvIG1vbmtleS1wYXRjaCB0aGVpciBjdXJ2ZSxcbiAqICAgaXQgd29uJ3QgYWZmZWN0IG90aGVyc1xuICpcbiAqIFR5cGVTY3JpcHQgY2FuJ3QgaW5mZXIgdHlwZXMgZm9yIGNsYXNzZXMgY3JlYXRlZCBpbnNpZGUgYSBmdW5jdGlvbi4gQ2xhc3NlcyBpcyBvbmUgaW5zdGFuY2VcbiAqIG9mIG5vbWluYXRpdmUgdHlwZXMgaW4gVHlwZVNjcmlwdCBhbmQgaW50ZXJmYWNlcyBvbmx5IGNoZWNrIGZvciBzaGFwZSwgc28gaXQncyBoYXJkIHRvIGNyZWF0ZVxuICogdW5pcXVlIHR5cGUgZm9yIGV2ZXJ5IGZ1bmN0aW9uIGNhbGwuXG4gKlxuICogV2UgY2FuIHVzZSBnZW5lcmljIHR5cGVzIHZpYSBzb21lIHBhcmFtLCBsaWtlIGN1cnZlIG9wdHMsIGJ1dCB0aGF0IHdvdWxkOlxuICogICAgIDEuIEVuYWJsZSBpbnRlcmFjdGlvbiBiZXR3ZWVuIGBjdXJ2ZShwYXJhbXMpYCBhbmQgYGN1cnZlKHBhcmFtcylgIChjdXJ2ZXMgb2Ygc2FtZSBwYXJhbXMpXG4gKiAgICAgd2hpY2ggaXMgaGFyZCB0byBkZWJ1Zy5cbiAqICAgICAyLiBQYXJhbXMgY2FuIGJlIGdlbmVyaWMgYW5kIHdlIGNhbid0IGVuZm9yY2UgdGhlbSB0byBiZSBjb25zdGFudCB2YWx1ZTpcbiAqICAgICBpZiBzb21lYm9keSBjcmVhdGVzIGN1cnZlIGZyb20gbm9uLWNvbnN0YW50IHBhcmFtcyxcbiAqICAgICBpdCB3b3VsZCBiZSBhbGxvd2VkIHRvIGludGVyYWN0IHdpdGggb3RoZXIgY3VydmVzIHdpdGggbm9uLWNvbnN0YW50IHBhcmFtc1xuICpcbiAqIEB0b2RvIGh0dHBzOi8vd3d3LnR5cGVzY3JpcHRsYW5nLm9yZy9kb2NzL2hhbmRib29rL3JlbGVhc2Utbm90ZXMvdHlwZXNjcmlwdC0yLTcuaHRtbCN1bmlxdWUtc3ltYm9sXG4gKiBAbW9kdWxlXG4gKi9cbi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgY3VydmVfdHNfMSA9IHJlcXVpcmUoXCIuL2N1cnZlLmpzXCIpO1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBtb2R1bGFyX3RzXzEgPSByZXF1aXJlKFwiLi9tb2R1bGFyLmpzXCIpO1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCB1dGlsc190c18xID0gcmVxdWlyZShcIi4vdXRpbHMuanNcIik7XG5mdW5jdGlvbiB2YWxpZGF0ZVNpZ1Zlck9wdHMob3B0cykge1xuICAgIGlmIChvcHRzLmxvd1MgIT09IHVuZGVmaW5lZClcbiAgICAgICAgKDAsIHV0aWxzX3RzXzEuYWJvb2wpKCdsb3dTJywgb3B0cy5sb3dTKTtcbiAgICBpZiAob3B0cy5wcmVoYXNoICE9PSB1bmRlZmluZWQpXG4gICAgICAgICgwLCB1dGlsc190c18xLmFib29sKSgncHJlaGFzaCcsIG9wdHMucHJlaGFzaCk7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZVBvaW50T3B0cyhjdXJ2ZSkge1xuICAgIGNvbnN0IG9wdHMgPSAoMCwgY3VydmVfdHNfMS52YWxpZGF0ZUJhc2ljKShjdXJ2ZSk7XG4gICAgKDAsIHV0aWxzX3RzXzEudmFsaWRhdGVPYmplY3QpKG9wdHMsIHtcbiAgICAgICAgYTogJ2ZpZWxkJyxcbiAgICAgICAgYjogJ2ZpZWxkJyxcbiAgICB9LCB7XG4gICAgICAgIGFsbG93SW5maW5pdHlQb2ludDogJ2Jvb2xlYW4nLFxuICAgICAgICBhbGxvd2VkUHJpdmF0ZUtleUxlbmd0aHM6ICdhcnJheScsXG4gICAgICAgIGNsZWFyQ29mYWN0b3I6ICdmdW5jdGlvbicsXG4gICAgICAgIGZyb21CeXRlczogJ2Z1bmN0aW9uJyxcbiAgICAgICAgaXNUb3JzaW9uRnJlZTogJ2Z1bmN0aW9uJyxcbiAgICAgICAgdG9CeXRlczogJ2Z1bmN0aW9uJyxcbiAgICAgICAgd3JhcFByaXZhdGVLZXk6ICdib29sZWFuJyxcbiAgICB9KTtcbiAgICBjb25zdCB7IGVuZG8sIEZwLCBhIH0gPSBvcHRzO1xuICAgIGlmIChlbmRvKSB7XG4gICAgICAgIGlmICghRnAuZXFsKGEsIEZwLlpFUk8pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgZW5kbzogQ1VSVkUuYSBtdXN0IGJlIDAnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGVuZG8gIT09ICdvYmplY3QnIHx8XG4gICAgICAgICAgICB0eXBlb2YgZW5kby5iZXRhICE9PSAnYmlnaW50JyB8fFxuICAgICAgICAgICAgdHlwZW9mIGVuZG8uc3BsaXRTY2FsYXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBlbmRvOiBleHBlY3RlZCBcImJldGFcIjogYmlnaW50IGFuZCBcInNwbGl0U2NhbGFyXCI6IGZ1bmN0aW9uJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoeyAuLi5vcHRzIH0pO1xufVxuY2xhc3MgREVSRXJyIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG0gPSAnJykge1xuICAgICAgICBzdXBlcihtKTtcbiAgICB9XG59XG5leHBvcnRzLkRFUkVyciA9IERFUkVycjtcbi8qKlxuICogQVNOLjEgREVSIGVuY29kaW5nIHV0aWxpdGllcy4gQVNOIGlzIHZlcnkgY29tcGxleCAmIGZyYWdpbGUuIEZvcm1hdDpcbiAqXG4gKiAgICAgWzB4MzAgKFNFUVVFTkNFKSwgYnl0ZWxlbmd0aCwgMHgwMiAoSU5URUdFUiksIGludExlbmd0aCwgUiwgMHgwMiAoSU5URUdFUiksIGludExlbmd0aCwgU11cbiAqXG4gKiBEb2NzOiBodHRwczovL2xldHNlbmNyeXB0Lm9yZy9kb2NzL2Etd2FybS13ZWxjb21lLXRvLWFzbjEtYW5kLWRlci8sIGh0dHBzOi8vbHVjYS5udG9wLm9yZy9UZWFjaGluZy9BcHB1bnRpL2FzbjEuaHRtbFxuICovXG5leHBvcnRzLkRFUiA9IHtcbiAgICAvLyBhc24uMSBERVIgZW5jb2RpbmcgdXRpbHNcbiAgICBFcnI6IERFUkVycixcbiAgICAvLyBCYXNpYyBidWlsZGluZyBibG9jayBpcyBUTFYgKFRhZy1MZW5ndGgtVmFsdWUpXG4gICAgX3Rsdjoge1xuICAgICAgICBlbmNvZGU6ICh0YWcsIGRhdGEpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgRXJyOiBFIH0gPSBleHBvcnRzLkRFUjtcbiAgICAgICAgICAgIGlmICh0YWcgPCAwIHx8IHRhZyA+IDI1NilcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRSgndGx2LmVuY29kZTogd3JvbmcgdGFnJyk7XG4gICAgICAgICAgICBpZiAoZGF0YS5sZW5ndGggJiAxKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFKCd0bHYuZW5jb2RlOiB1bnBhZGRlZCBkYXRhJyk7XG4gICAgICAgICAgICBjb25zdCBkYXRhTGVuID0gZGF0YS5sZW5ndGggLyAyO1xuICAgICAgICAgICAgY29uc3QgbGVuID0gKDAsIHV0aWxzX3RzXzEubnVtYmVyVG9IZXhVbnBhZGRlZCkoZGF0YUxlbik7XG4gICAgICAgICAgICBpZiAoKGxlbi5sZW5ndGggLyAyKSAmIDEyOClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRSgndGx2LmVuY29kZTogbG9uZyBmb3JtIGxlbmd0aCB0b28gYmlnJyk7XG4gICAgICAgICAgICAvLyBsZW5ndGggb2YgbGVuZ3RoIHdpdGggbG9uZyBmb3JtIGZsYWdcbiAgICAgICAgICAgIGNvbnN0IGxlbkxlbiA9IGRhdGFMZW4gPiAxMjcgPyAoMCwgdXRpbHNfdHNfMS5udW1iZXJUb0hleFVucGFkZGVkKSgobGVuLmxlbmd0aCAvIDIpIHwgMTI4KSA6ICcnO1xuICAgICAgICAgICAgY29uc3QgdCA9ICgwLCB1dGlsc190c18xLm51bWJlclRvSGV4VW5wYWRkZWQpKHRhZyk7XG4gICAgICAgICAgICByZXR1cm4gdCArIGxlbkxlbiArIGxlbiArIGRhdGE7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIHYgLSB2YWx1ZSwgbCAtIGxlZnQgYnl0ZXMgKHVucGFyc2VkKVxuICAgICAgICBkZWNvZGUodGFnLCBkYXRhKSB7XG4gICAgICAgICAgICBjb25zdCB7IEVycjogRSB9ID0gZXhwb3J0cy5ERVI7XG4gICAgICAgICAgICBsZXQgcG9zID0gMDtcbiAgICAgICAgICAgIGlmICh0YWcgPCAwIHx8IHRhZyA+IDI1NilcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRSgndGx2LmVuY29kZTogd3JvbmcgdGFnJyk7XG4gICAgICAgICAgICBpZiAoZGF0YS5sZW5ndGggPCAyIHx8IGRhdGFbcG9zKytdICE9PSB0YWcpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ3Rsdi5kZWNvZGU6IHdyb25nIHRsdicpO1xuICAgICAgICAgICAgY29uc3QgZmlyc3QgPSBkYXRhW3BvcysrXTtcbiAgICAgICAgICAgIGNvbnN0IGlzTG9uZyA9ICEhKGZpcnN0ICYgMTI4KTsgLy8gRmlyc3QgYml0IG9mIGZpcnN0IGxlbmd0aCBieXRlIGlzIGZsYWcgZm9yIHNob3J0L2xvbmcgZm9ybVxuICAgICAgICAgICAgbGV0IGxlbmd0aCA9IDA7XG4gICAgICAgICAgICBpZiAoIWlzTG9uZylcbiAgICAgICAgICAgICAgICBsZW5ndGggPSBmaXJzdDtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIExvbmcgZm9ybTogW2xvbmdGbGFnKDFiaXQpLCBsZW5ndGhMZW5ndGgoN2JpdCksIGxlbmd0aCAoQkUpXVxuICAgICAgICAgICAgICAgIGNvbnN0IGxlbkxlbiA9IGZpcnN0ICYgMTI3O1xuICAgICAgICAgICAgICAgIGlmICghbGVuTGVuKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRSgndGx2LmRlY29kZShsb25nKTogaW5kZWZpbml0ZSBsZW5ndGggbm90IHN1cHBvcnRlZCcpO1xuICAgICAgICAgICAgICAgIGlmIChsZW5MZW4gPiA0KVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRSgndGx2LmRlY29kZShsb25nKTogYnl0ZSBsZW5ndGggaXMgdG9vIGJpZycpOyAvLyB0aGlzIHdpbGwgb3ZlcmZsb3cgdTMyIGluIGpzXG4gICAgICAgICAgICAgICAgY29uc3QgbGVuZ3RoQnl0ZXMgPSBkYXRhLnN1YmFycmF5KHBvcywgcG9zICsgbGVuTGVuKTtcbiAgICAgICAgICAgICAgICBpZiAobGVuZ3RoQnl0ZXMubGVuZ3RoICE9PSBsZW5MZW4pXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFKCd0bHYuZGVjb2RlOiBsZW5ndGggYnl0ZXMgbm90IGNvbXBsZXRlJyk7XG4gICAgICAgICAgICAgICAgaWYgKGxlbmd0aEJ5dGVzWzBdID09PSAwKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRSgndGx2LmRlY29kZShsb25nKTogemVybyBsZWZ0bW9zdCBieXRlJyk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBiIG9mIGxlbmd0aEJ5dGVzKVxuICAgICAgICAgICAgICAgICAgICBsZW5ndGggPSAobGVuZ3RoIDw8IDgpIHwgYjtcbiAgICAgICAgICAgICAgICBwb3MgKz0gbGVuTGVuO1xuICAgICAgICAgICAgICAgIGlmIChsZW5ndGggPCAxMjgpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFKCd0bHYuZGVjb2RlKGxvbmcpOiBub3QgbWluaW1hbCBlbmNvZGluZycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdiA9IGRhdGEuc3ViYXJyYXkocG9zLCBwb3MgKyBsZW5ndGgpO1xuICAgICAgICAgICAgaWYgKHYubGVuZ3RoICE9PSBsZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ3Rsdi5kZWNvZGU6IHdyb25nIHZhbHVlIGxlbmd0aCcpO1xuICAgICAgICAgICAgcmV0dXJuIHsgdiwgbDogZGF0YS5zdWJhcnJheShwb3MgKyBsZW5ndGgpIH07XG4gICAgICAgIH0sXG4gICAgfSxcbiAgICAvLyBodHRwczovL2NyeXB0by5zdGFja2V4Y2hhbmdlLmNvbS9hLzU3NzM0IExlZnRtb3N0IGJpdCBvZiBmaXJzdCBieXRlIGlzICduZWdhdGl2ZScgZmxhZyxcbiAgICAvLyBzaW5jZSB3ZSBhbHdheXMgdXNlIHBvc2l0aXZlIGludGVnZXJzIGhlcmUuIEl0IG11c3QgYWx3YXlzIGJlIGVtcHR5OlxuICAgIC8vIC0gYWRkIHplcm8gYnl0ZSBpZiBleGlzdHNcbiAgICAvLyAtIGlmIG5leHQgYnl0ZSBkb2Vzbid0IGhhdmUgYSBmbGFnLCBsZWFkaW5nIHplcm8gaXMgbm90IGFsbG93ZWQgKG1pbmltYWwgZW5jb2RpbmcpXG4gICAgX2ludDoge1xuICAgICAgICBlbmNvZGUobnVtKSB7XG4gICAgICAgICAgICBjb25zdCB7IEVycjogRSB9ID0gZXhwb3J0cy5ERVI7XG4gICAgICAgICAgICBpZiAobnVtIDwgXzBuKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFKCdpbnRlZ2VyOiBuZWdhdGl2ZSBpbnRlZ2VycyBhcmUgbm90IGFsbG93ZWQnKTtcbiAgICAgICAgICAgIGxldCBoZXggPSAoMCwgdXRpbHNfdHNfMS5udW1iZXJUb0hleFVucGFkZGVkKShudW0pO1xuICAgICAgICAgICAgLy8gUGFkIHdpdGggemVybyBieXRlIGlmIG5lZ2F0aXZlIGZsYWcgaXMgcHJlc2VudFxuICAgICAgICAgICAgaWYgKE51bWJlci5wYXJzZUludChoZXhbMF0sIDE2KSAmIDBiMTAwMClcbiAgICAgICAgICAgICAgICBoZXggPSAnMDAnICsgaGV4O1xuICAgICAgICAgICAgaWYgKGhleC5sZW5ndGggJiAxKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFKCd1bmV4cGVjdGVkIERFUiBwYXJzaW5nIGFzc2VydGlvbjogdW5wYWRkZWQgaGV4Jyk7XG4gICAgICAgICAgICByZXR1cm4gaGV4O1xuICAgICAgICB9LFxuICAgICAgICBkZWNvZGUoZGF0YSkge1xuICAgICAgICAgICAgY29uc3QgeyBFcnI6IEUgfSA9IGV4cG9ydHMuREVSO1xuICAgICAgICAgICAgaWYgKGRhdGFbMF0gJiAxMjgpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ2ludmFsaWQgc2lnbmF0dXJlIGludGVnZXI6IG5lZ2F0aXZlJyk7XG4gICAgICAgICAgICBpZiAoZGF0YVswXSA9PT0gMHgwMCAmJiAhKGRhdGFbMV0gJiAxMjgpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFKCdpbnZhbGlkIHNpZ25hdHVyZSBpbnRlZ2VyOiB1bm5lY2Vzc2FyeSBsZWFkaW5nIHplcm8nKTtcbiAgICAgICAgICAgIHJldHVybiAoMCwgdXRpbHNfdHNfMS5ieXRlc1RvTnVtYmVyQkUpKGRhdGEpO1xuICAgICAgICB9LFxuICAgIH0sXG4gICAgdG9TaWcoaGV4KSB7XG4gICAgICAgIC8vIHBhcnNlIERFUiBzaWduYXR1cmVcbiAgICAgICAgY29uc3QgeyBFcnI6IEUsIF9pbnQ6IGludCwgX3RsdjogdGx2IH0gPSBleHBvcnRzLkRFUjtcbiAgICAgICAgY29uc3QgZGF0YSA9ICgwLCB1dGlsc190c18xLmVuc3VyZUJ5dGVzKSgnc2lnbmF0dXJlJywgaGV4KTtcbiAgICAgICAgY29uc3QgeyB2OiBzZXFCeXRlcywgbDogc2VxTGVmdEJ5dGVzIH0gPSB0bHYuZGVjb2RlKDB4MzAsIGRhdGEpO1xuICAgICAgICBpZiAoc2VxTGVmdEJ5dGVzLmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBFKCdpbnZhbGlkIHNpZ25hdHVyZTogbGVmdCBieXRlcyBhZnRlciBwYXJzaW5nJyk7XG4gICAgICAgIGNvbnN0IHsgdjogckJ5dGVzLCBsOiByTGVmdEJ5dGVzIH0gPSB0bHYuZGVjb2RlKDB4MDIsIHNlcUJ5dGVzKTtcbiAgICAgICAgY29uc3QgeyB2OiBzQnl0ZXMsIGw6IHNMZWZ0Qnl0ZXMgfSA9IHRsdi5kZWNvZGUoMHgwMiwgckxlZnRCeXRlcyk7XG4gICAgICAgIGlmIChzTGVmdEJ5dGVzLmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBFKCdpbnZhbGlkIHNpZ25hdHVyZTogbGVmdCBieXRlcyBhZnRlciBwYXJzaW5nJyk7XG4gICAgICAgIHJldHVybiB7IHI6IGludC5kZWNvZGUockJ5dGVzKSwgczogaW50LmRlY29kZShzQnl0ZXMpIH07XG4gICAgfSxcbiAgICBoZXhGcm9tU2lnKHNpZykge1xuICAgICAgICBjb25zdCB7IF90bHY6IHRsdiwgX2ludDogaW50IH0gPSBleHBvcnRzLkRFUjtcbiAgICAgICAgY29uc3QgcnMgPSB0bHYuZW5jb2RlKDB4MDIsIGludC5lbmNvZGUoc2lnLnIpKTtcbiAgICAgICAgY29uc3Qgc3MgPSB0bHYuZW5jb2RlKDB4MDIsIGludC5lbmNvZGUoc2lnLnMpKTtcbiAgICAgICAgY29uc3Qgc2VxID0gcnMgKyBzcztcbiAgICAgICAgcmV0dXJuIHRsdi5lbmNvZGUoMHgzMCwgc2VxKTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIG51bVRvU2l6ZWRIZXgobnVtLCBzaXplKSB7XG4gICAgcmV0dXJuICgwLCB1dGlsc190c18xLmJ5dGVzVG9IZXgpKCgwLCB1dGlsc190c18xLm51bWJlclRvQnl0ZXNCRSkobnVtLCBzaXplKSk7XG59XG4vLyBCZSBmcmllbmRseSB0byBiYWQgRUNNQVNjcmlwdCBwYXJzZXJzIGJ5IG5vdCB1c2luZyBiaWdpbnQgbGl0ZXJhbHNcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgXzBuID0gQmlnSW50KDApLCBfMW4gPSBCaWdJbnQoMSksIF8ybiA9IEJpZ0ludCgyKSwgXzNuID0gQmlnSW50KDMpLCBfNG4gPSBCaWdJbnQoNCk7XG5mdW5jdGlvbiB3ZWllcnN0cmFzc1BvaW50cyhvcHRzKSB7XG4gICAgY29uc3QgQ1VSVkUgPSB2YWxpZGF0ZVBvaW50T3B0cyhvcHRzKTtcbiAgICBjb25zdCB7IEZwIH0gPSBDVVJWRTsgLy8gQWxsIGN1cnZlcyBoYXMgc2FtZSBmaWVsZCAvIGdyb3VwIGxlbmd0aCBhcyBmb3Igbm93LCBidXQgdGhleSBjYW4gZGlmZmVyXG4gICAgY29uc3QgRm4gPSAoMCwgbW9kdWxhcl90c18xLkZpZWxkKShDVVJWRS5uLCBDVVJWRS5uQml0TGVuZ3RoKTtcbiAgICBjb25zdCB0b0J5dGVzID0gQ1VSVkUudG9CeXRlcyB8fFxuICAgICAgICAoKF9jLCBwb2ludCwgX2lzQ29tcHJlc3NlZCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYSA9IHBvaW50LnRvQWZmaW5lKCk7XG4gICAgICAgICAgICByZXR1cm4gKDAsIHV0aWxzX3RzXzEuY29uY2F0Qnl0ZXMpKFVpbnQ4QXJyYXkuZnJvbShbMHgwNF0pLCBGcC50b0J5dGVzKGEueCksIEZwLnRvQnl0ZXMoYS55KSk7XG4gICAgICAgIH0pO1xuICAgIGNvbnN0IGZyb21CeXRlcyA9IENVUlZFLmZyb21CeXRlcyB8fFxuICAgICAgICAoKGJ5dGVzKSA9PiB7XG4gICAgICAgICAgICAvLyBjb25zdCBoZWFkID0gYnl0ZXNbMF07XG4gICAgICAgICAgICBjb25zdCB0YWlsID0gYnl0ZXMuc3ViYXJyYXkoMSk7XG4gICAgICAgICAgICAvLyBpZiAoaGVhZCAhPT0gMHgwNCkgdGhyb3cgbmV3IEVycm9yKCdPbmx5IG5vbi1jb21wcmVzc2VkIGVuY29kaW5nIGlzIHN1cHBvcnRlZCcpO1xuICAgICAgICAgICAgY29uc3QgeCA9IEZwLmZyb21CeXRlcyh0YWlsLnN1YmFycmF5KDAsIEZwLkJZVEVTKSk7XG4gICAgICAgICAgICBjb25zdCB5ID0gRnAuZnJvbUJ5dGVzKHRhaWwuc3ViYXJyYXkoRnAuQllURVMsIDIgKiBGcC5CWVRFUykpO1xuICAgICAgICAgICAgcmV0dXJuIHsgeCwgeSB9O1xuICAgICAgICB9KTtcbiAgICAvKipcbiAgICAgKiB5wrIgPSB4wrMgKyBheCArIGI6IFNob3J0IHdlaWVyc3RyYXNzIGN1cnZlIGZvcm11bGEuIFRha2VzIHgsIHJldHVybnMgecKyLlxuICAgICAqIEByZXR1cm5zIHnCslxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdlaWVyc3RyYXNzRXF1YXRpb24oeCkge1xuICAgICAgICBjb25zdCB7IGEsIGIgfSA9IENVUlZFO1xuICAgICAgICBjb25zdCB4MiA9IEZwLnNxcih4KTsgLy8geCAqIHhcbiAgICAgICAgY29uc3QgeDMgPSBGcC5tdWwoeDIsIHgpOyAvLyB4wrIgKiB4XG4gICAgICAgIHJldHVybiBGcC5hZGQoRnAuYWRkKHgzLCBGcC5tdWwoeCwgYSkpLCBiKTsgLy8geMKzICsgYSAqIHggKyBiXG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzVmFsaWRYWSh4LCB5KSB7XG4gICAgICAgIGNvbnN0IGxlZnQgPSBGcC5zcXIoeSk7IC8vIHnCslxuICAgICAgICBjb25zdCByaWdodCA9IHdlaWVyc3RyYXNzRXF1YXRpb24oeCk7IC8vIHjCsyArIGF4ICsgYlxuICAgICAgICByZXR1cm4gRnAuZXFsKGxlZnQsIHJpZ2h0KTtcbiAgICB9XG4gICAgLy8gVmFsaWRhdGUgd2hldGhlciB0aGUgcGFzc2VkIGN1cnZlIHBhcmFtcyBhcmUgdmFsaWQuXG4gICAgLy8gVGVzdCAxOiBlcXVhdGlvbiB5wrIgPSB4wrMgKyBheCArIGIgc2hvdWxkIHdvcmsgZm9yIGdlbmVyYXRvciBwb2ludC5cbiAgICBpZiAoIWlzVmFsaWRYWShDVVJWRS5HeCwgQ1VSVkUuR3kpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBjdXJ2ZSBwYXJhbXM6IGdlbmVyYXRvciBwb2ludCcpO1xuICAgIC8vIFRlc3QgMjogZGlzY3JpbWluYW50IM6UIHBhcnQgc2hvdWxkIGJlIG5vbi16ZXJvOiA0YcKzICsgMjdiwrIgIT0gMC5cbiAgICAvLyBHdWFyYW50ZWVzIGN1cnZlIGlzIGdlbnVzLTEsIHNtb290aCAobm9uLXNpbmd1bGFyKS5cbiAgICBjb25zdCBfNGEzID0gRnAubXVsKEZwLnBvdyhDVVJWRS5hLCBfM24pLCBfNG4pO1xuICAgIGNvbnN0IF8yN2IyID0gRnAubXVsKEZwLnNxcihDVVJWRS5iKSwgQmlnSW50KDI3KSk7XG4gICAgaWYgKEZwLmlzMChGcC5hZGQoXzRhMywgXzI3YjIpKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgY3VydmUgcGFyYW1zOiBhIG9yIGInKTtcbiAgICAvLyBWYWxpZCBncm91cCBlbGVtZW50cyByZXNpZGUgaW4gcmFuZ2UgMS4ubi0xXG4gICAgZnVuY3Rpb24gaXNXaXRoaW5DdXJ2ZU9yZGVyKG51bSkge1xuICAgICAgICByZXR1cm4gKDAsIHV0aWxzX3RzXzEuaW5SYW5nZSkobnVtLCBfMW4sIENVUlZFLm4pO1xuICAgIH1cbiAgICAvLyBWYWxpZGF0ZXMgaWYgcHJpdiBrZXkgaXMgdmFsaWQgYW5kIGNvbnZlcnRzIGl0IHRvIGJpZ2ludC5cbiAgICAvLyBTdXBwb3J0cyBvcHRpb25zIGFsbG93ZWRQcml2YXRlS2V5TGVuZ3RocyBhbmQgd3JhcFByaXZhdGVLZXkuXG4gICAgZnVuY3Rpb24gbm9ybVByaXZhdGVLZXlUb1NjYWxhcihrZXkpIHtcbiAgICAgICAgY29uc3QgeyBhbGxvd2VkUHJpdmF0ZUtleUxlbmd0aHM6IGxlbmd0aHMsIG5CeXRlTGVuZ3RoLCB3cmFwUHJpdmF0ZUtleSwgbjogTiB9ID0gQ1VSVkU7XG4gICAgICAgIGlmIChsZW5ndGhzICYmIHR5cGVvZiBrZXkgIT09ICdiaWdpbnQnKSB7XG4gICAgICAgICAgICBpZiAoKDAsIHV0aWxzX3RzXzEuaXNCeXRlcykoa2V5KSlcbiAgICAgICAgICAgICAgICBrZXkgPSAoMCwgdXRpbHNfdHNfMS5ieXRlc1RvSGV4KShrZXkpO1xuICAgICAgICAgICAgLy8gTm9ybWFsaXplIHRvIGhleCBzdHJpbmcsIHBhZC4gRS5nLiBQNTIxIHdvdWxkIG5vcm0gMTMwLTEzMiBjaGFyIGhleCB0byAxMzItY2hhciBieXRlc1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnIHx8ICFsZW5ndGhzLmluY2x1ZGVzKGtleS5sZW5ndGgpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBwcml2YXRlIGtleScpO1xuICAgICAgICAgICAga2V5ID0ga2V5LnBhZFN0YXJ0KG5CeXRlTGVuZ3RoICogMiwgJzAnKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbnVtO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbnVtID1cbiAgICAgICAgICAgICAgICB0eXBlb2Yga2V5ID09PSAnYmlnaW50J1xuICAgICAgICAgICAgICAgICAgICA/IGtleVxuICAgICAgICAgICAgICAgICAgICA6ICgwLCB1dGlsc190c18xLmJ5dGVzVG9OdW1iZXJCRSkoKDAsIHV0aWxzX3RzXzEuZW5zdXJlQnl0ZXMpKCdwcml2YXRlIGtleScsIGtleSwgbkJ5dGVMZW5ndGgpKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBwcml2YXRlIGtleSwgZXhwZWN0ZWQgaGV4IG9yICcgKyBuQnl0ZUxlbmd0aCArICcgYnl0ZXMsIGdvdCAnICsgdHlwZW9mIGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdyYXBQcml2YXRlS2V5KVxuICAgICAgICAgICAgbnVtID0gKDAsIG1vZHVsYXJfdHNfMS5tb2QpKG51bSwgTik7IC8vIGRpc2FibGVkIGJ5IGRlZmF1bHQsIGVuYWJsZWQgZm9yIEJMU1xuICAgICAgICAoMCwgdXRpbHNfdHNfMS5hSW5SYW5nZSkoJ3ByaXZhdGUga2V5JywgbnVtLCBfMW4sIE4pOyAvLyBudW0gaW4gcmFuZ2UgWzEuLk4tMV1cbiAgICAgICAgcmV0dXJuIG51bTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYXByanBvaW50KG90aGVyKSB7XG4gICAgICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgUG9pbnQpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcm9qZWN0aXZlUG9pbnQgZXhwZWN0ZWQnKTtcbiAgICB9XG4gICAgLy8gTWVtb2l6ZWQgdG9BZmZpbmUgLyB2YWxpZGl0eSBjaGVjay4gVGhleSBhcmUgaGVhdnkuIFBvaW50cyBhcmUgaW1tdXRhYmxlLlxuICAgIC8vIENvbnZlcnRzIFByb2plY3RpdmUgcG9pbnQgdG8gYWZmaW5lICh4LCB5KSBjb29yZGluYXRlcy5cbiAgICAvLyBDYW4gYWNjZXB0IHByZWNvbXB1dGVkIFpeLTEgLSBmb3IgZXhhbXBsZSwgZnJvbSBpbnZlcnRCYXRjaC5cbiAgICAvLyAoWCwgWSwgWikg4oiLICh4PVgvWiwgeT1ZL1opXG4gICAgY29uc3QgdG9BZmZpbmVNZW1vID0gKDAsIHV0aWxzX3RzXzEubWVtb2l6ZWQpKChwLCBpeikgPT4ge1xuICAgICAgICBjb25zdCB7IHB4OiB4LCBweTogeSwgcHo6IHogfSA9IHA7XG4gICAgICAgIC8vIEZhc3QtcGF0aCBmb3Igbm9ybWFsaXplZCBwb2ludHNcbiAgICAgICAgaWYgKEZwLmVxbCh6LCBGcC5PTkUpKVxuICAgICAgICAgICAgcmV0dXJuIHsgeCwgeSB9O1xuICAgICAgICBjb25zdCBpczAgPSBwLmlzMCgpO1xuICAgICAgICAvLyBJZiBpbnZaIHdhcyAwLCB3ZSByZXR1cm4gemVybyBwb2ludC4gSG93ZXZlciB3ZSBzdGlsbCB3YW50IHRvIGV4ZWN1dGVcbiAgICAgICAgLy8gYWxsIG9wZXJhdGlvbnMsIHNvIHdlIHJlcGxhY2UgaW52WiB3aXRoIGEgcmFuZG9tIG51bWJlciwgMS5cbiAgICAgICAgaWYgKGl6ID09IG51bGwpXG4gICAgICAgICAgICBpeiA9IGlzMCA/IEZwLk9ORSA6IEZwLmludih6KTtcbiAgICAgICAgY29uc3QgYXggPSBGcC5tdWwoeCwgaXopO1xuICAgICAgICBjb25zdCBheSA9IEZwLm11bCh5LCBpeik7XG4gICAgICAgIGNvbnN0IHp6ID0gRnAubXVsKHosIGl6KTtcbiAgICAgICAgaWYgKGlzMClcbiAgICAgICAgICAgIHJldHVybiB7IHg6IEZwLlpFUk8sIHk6IEZwLlpFUk8gfTtcbiAgICAgICAgaWYgKCFGcC5lcWwoenosIEZwLk9ORSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludlogd2FzIGludmFsaWQnKTtcbiAgICAgICAgcmV0dXJuIHsgeDogYXgsIHk6IGF5IH07XG4gICAgfSk7XG4gICAgLy8gTk9URTogb24gZXhjZXB0aW9uIHRoaXMgd2lsbCBjcmFzaCAnY2FjaGVkJyBhbmQgbm8gdmFsdWUgd2lsbCBiZSBzZXQuXG4gICAgLy8gT3RoZXJ3aXNlIHRydWUgd2lsbCBiZSByZXR1cm5cbiAgICBjb25zdCBhc3NlcnRWYWxpZE1lbW8gPSAoMCwgdXRpbHNfdHNfMS5tZW1vaXplZCkoKHApID0+IHtcbiAgICAgICAgaWYgKHAuaXMwKCkpIHtcbiAgICAgICAgICAgIC8vICgwLCAxLCAwKSBha2EgWkVSTyBpcyBpbnZhbGlkIGluIG1vc3QgY29udGV4dHMuXG4gICAgICAgICAgICAvLyBJbiBCTFMsIFpFUk8gY2FuIGJlIHNlcmlhbGl6ZWQsIHNvIHdlIGFsbG93IGl0LlxuICAgICAgICAgICAgLy8gKDAsIDAsIDApIGlzIGludmFsaWQgcmVwcmVzZW50YXRpb24gb2YgWkVSTy5cbiAgICAgICAgICAgIGlmIChDVVJWRS5hbGxvd0luZmluaXR5UG9pbnQgJiYgIUZwLmlzMChwLnB5KSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwb2ludDogWkVSTycpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNvbWUgM3JkLXBhcnR5IHRlc3QgdmVjdG9ycyByZXF1aXJlIGRpZmZlcmVudCB3b3JkaW5nIGJldHdlZW4gaGVyZSAmIGBmcm9tQ29tcHJlc3NlZEhleGBcbiAgICAgICAgY29uc3QgeyB4LCB5IH0gPSBwLnRvQWZmaW5lKCk7XG4gICAgICAgIC8vIENoZWNrIGlmIHgsIHkgYXJlIHZhbGlkIGZpZWxkIGVsZW1lbnRzXG4gICAgICAgIGlmICghRnAuaXNWYWxpZCh4KSB8fCAhRnAuaXNWYWxpZCh5KSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIHBvaW50OiB4IG9yIHkgbm90IEZFJyk7XG4gICAgICAgIGlmICghaXNWYWxpZFhZKHgsIHkpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgcG9pbnQ6IGVxdWF0aW9uIGxlZnQgIT0gcmlnaHQnKTtcbiAgICAgICAgaWYgKCFwLmlzVG9yc2lvbkZyZWUoKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIHBvaW50OiBub3QgaW4gcHJpbWUtb3JkZXIgc3ViZ3JvdXAnKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogUHJvamVjdGl2ZSBQb2ludCB3b3JrcyBpbiAzZCAvIHByb2plY3RpdmUgKGhvbW9nZW5lb3VzKSBjb29yZGluYXRlczogKFgsIFksIFopIOKIiyAoeD1YL1osIHk9WS9aKVxuICAgICAqIERlZmF1bHQgUG9pbnQgd29ya3MgaW4gMmQgLyBhZmZpbmUgY29vcmRpbmF0ZXM6ICh4LCB5KVxuICAgICAqIFdlJ3JlIGRvaW5nIGNhbGN1bGF0aW9ucyBpbiBwcm9qZWN0aXZlLCBiZWNhdXNlIGl0cyBvcGVyYXRpb25zIGRvbid0IHJlcXVpcmUgY29zdGx5IGludmVyc2lvbi5cbiAgICAgKi9cbiAgICBjbGFzcyBQb2ludCB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHB4LCBweSwgcHopIHtcbiAgICAgICAgICAgIGlmIChweCA9PSBudWxsIHx8ICFGcC5pc1ZhbGlkKHB4KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ggcmVxdWlyZWQnKTtcbiAgICAgICAgICAgIGlmIChweSA9PSBudWxsIHx8ICFGcC5pc1ZhbGlkKHB5KSB8fCBGcC5pczAocHkpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigneSByZXF1aXJlZCcpO1xuICAgICAgICAgICAgaWYgKHB6ID09IG51bGwgfHwgIUZwLmlzVmFsaWQocHopKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigneiByZXF1aXJlZCcpO1xuICAgICAgICAgICAgdGhpcy5weCA9IHB4O1xuICAgICAgICAgICAgdGhpcy5weSA9IHB5O1xuICAgICAgICAgICAgdGhpcy5weiA9IHB6O1xuICAgICAgICAgICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBEb2VzIG5vdCB2YWxpZGF0ZSBpZiB0aGUgcG9pbnQgaXMgb24tY3VydmUuXG4gICAgICAgIC8vIFVzZSBmcm9tSGV4IGluc3RlYWQsIG9yIGNhbGwgYXNzZXJ0VmFsaWRpdHkoKSBsYXRlci5cbiAgICAgICAgc3RhdGljIGZyb21BZmZpbmUocCkge1xuICAgICAgICAgICAgY29uc3QgeyB4LCB5IH0gPSBwIHx8IHt9O1xuICAgICAgICAgICAgaWYgKCFwIHx8ICFGcC5pc1ZhbGlkKHgpIHx8ICFGcC5pc1ZhbGlkKHkpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBhZmZpbmUgcG9pbnQnKTtcbiAgICAgICAgICAgIGlmIChwIGluc3RhbmNlb2YgUG9pbnQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwcm9qZWN0aXZlIHBvaW50IG5vdCBhbGxvd2VkJyk7XG4gICAgICAgICAgICBjb25zdCBpczAgPSAoaSkgPT4gRnAuZXFsKGksIEZwLlpFUk8pO1xuICAgICAgICAgICAgLy8gZnJvbUFmZmluZSh4OjAsIHk6MCkgd291bGQgcHJvZHVjZSAoeDowLCB5OjAsIHo6MSksIGJ1dCB3ZSBuZWVkICh4OjAsIHk6MSwgejowKVxuICAgICAgICAgICAgaWYgKGlzMCh4KSAmJiBpczAoeSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFBvaW50LlpFUk87XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KHgsIHksIEZwLk9ORSk7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0IHgoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b0FmZmluZSgpLng7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0IHkoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b0FmZmluZSgpLnk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRha2VzIGEgYnVuY2ggb2YgUHJvamVjdGl2ZSBQb2ludHMgYnV0IGV4ZWN1dGVzIG9ubHkgb25lXG4gICAgICAgICAqIGludmVyc2lvbiBvbiBhbGwgb2YgdGhlbS4gSW52ZXJzaW9uIGlzIHZlcnkgc2xvdyBvcGVyYXRpb24sXG4gICAgICAgICAqIHNvIHRoaXMgaW1wcm92ZXMgcGVyZm9ybWFuY2UgbWFzc2l2ZWx5LlxuICAgICAgICAgKiBPcHRpbWl6YXRpb246IGNvbnZlcnRzIGEgbGlzdCBvZiBwcm9qZWN0aXZlIHBvaW50cyB0byBhIGxpc3Qgb2YgaWRlbnRpY2FsIHBvaW50cyB3aXRoIFo9MS5cbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBub3JtYWxpemVaKHBvaW50cykge1xuICAgICAgICAgICAgY29uc3QgdG9JbnYgPSAoMCwgbW9kdWxhcl90c18xLkZwSW52ZXJ0QmF0Y2gpKEZwLCBwb2ludHMubWFwKChwKSA9PiBwLnB6KSk7XG4gICAgICAgICAgICByZXR1cm4gcG9pbnRzLm1hcCgocCwgaSkgPT4gcC50b0FmZmluZSh0b0ludltpXSkpLm1hcChQb2ludC5mcm9tQWZmaW5lKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ29udmVydHMgaGFzaCBzdHJpbmcgb3IgVWludDhBcnJheSB0byBQb2ludC5cbiAgICAgICAgICogQHBhcmFtIGhleCBzaG9ydC9sb25nIEVDRFNBIGhleFxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGZyb21IZXgoaGV4KSB7XG4gICAgICAgICAgICBjb25zdCBQID0gUG9pbnQuZnJvbUFmZmluZShmcm9tQnl0ZXMoKDAsIHV0aWxzX3RzXzEuZW5zdXJlQnl0ZXMpKCdwb2ludEhleCcsIGhleCkpKTtcbiAgICAgICAgICAgIFAuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICAgICAgICAgIHJldHVybiBQO1xuICAgICAgICB9XG4gICAgICAgIC8vIE11bHRpcGxpZXMgZ2VuZXJhdG9yIHBvaW50IGJ5IHByaXZhdGVLZXkuXG4gICAgICAgIHN0YXRpYyBmcm9tUHJpdmF0ZUtleShwcml2YXRlS2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gUG9pbnQuQkFTRS5tdWx0aXBseShub3JtUHJpdmF0ZUtleVRvU2NhbGFyKHByaXZhdGVLZXkpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBNdWx0aXNjYWxhciBNdWx0aXBsaWNhdGlvblxuICAgICAgICBzdGF0aWMgbXNtKHBvaW50cywgc2NhbGFycykge1xuICAgICAgICAgICAgcmV0dXJuICgwLCBjdXJ2ZV90c18xLnBpcHBlbmdlcikoUG9pbnQsIEZuLCBwb2ludHMsIHNjYWxhcnMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFwiUHJpdmF0ZSBtZXRob2RcIiwgZG9uJ3QgdXNlIGl0IGRpcmVjdGx5XG4gICAgICAgIF9zZXRXaW5kb3dTaXplKHdpbmRvd1NpemUpIHtcbiAgICAgICAgICAgIHduYWYuc2V0V2luZG93U2l6ZSh0aGlzLCB3aW5kb3dTaXplKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBIHBvaW50IG9uIGN1cnZlIGlzIHZhbGlkIGlmIGl0IGNvbmZvcm1zIHRvIGVxdWF0aW9uLlxuICAgICAgICBhc3NlcnRWYWxpZGl0eSgpIHtcbiAgICAgICAgICAgIGFzc2VydFZhbGlkTWVtbyh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBoYXNFdmVuWSgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgeSB9ID0gdGhpcy50b0FmZmluZSgpO1xuICAgICAgICAgICAgaWYgKEZwLmlzT2RkKVxuICAgICAgICAgICAgICAgIHJldHVybiAhRnAuaXNPZGQoeSk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGaWVsZCBkb2Vzbid0IHN1cHBvcnQgaXNPZGRcIik7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbXBhcmUgb25lIHBvaW50IHRvIGFub3RoZXIuXG4gICAgICAgICAqL1xuICAgICAgICBlcXVhbHMob3RoZXIpIHtcbiAgICAgICAgICAgIGFwcmpwb2ludChvdGhlcik7XG4gICAgICAgICAgICBjb25zdCB7IHB4OiBYMSwgcHk6IFkxLCBwejogWjEgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCB7IHB4OiBYMiwgcHk6IFkyLCBwejogWjIgfSA9IG90aGVyO1xuICAgICAgICAgICAgY29uc3QgVTEgPSBGcC5lcWwoRnAubXVsKFgxLCBaMiksIEZwLm11bChYMiwgWjEpKTtcbiAgICAgICAgICAgIGNvbnN0IFUyID0gRnAuZXFsKEZwLm11bChZMSwgWjIpLCBGcC5tdWwoWTIsIFoxKSk7XG4gICAgICAgICAgICByZXR1cm4gVTEgJiYgVTI7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZsaXBzIHBvaW50IHRvIG9uZSBjb3JyZXNwb25kaW5nIHRvICh4LCAteSkgaW4gQWZmaW5lIGNvb3JkaW5hdGVzLlxuICAgICAgICAgKi9cbiAgICAgICAgbmVnYXRlKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLnB4LCBGcC5uZWcodGhpcy5weSksIHRoaXMucHopO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlbmVzLUNvc3RlbGxvLUJhdGluYSBleGNlcHRpb24tZnJlZSBkb3VibGluZyBmb3JtdWxhLlxuICAgICAgICAvLyBUaGVyZSBpcyAzMCUgZmFzdGVyIEphY29iaWFuIGZvcm11bGEsIGJ1dCBpdCBpcyBub3QgY29tcGxldGUuXG4gICAgICAgIC8vIGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMTUvMTA2MCwgYWxnb3JpdGhtIDNcbiAgICAgICAgLy8gQ29zdDogOE0gKyAzUyArIDMqYSArIDIqYjMgKyAxNWFkZC5cbiAgICAgICAgZG91YmxlKCkge1xuICAgICAgICAgICAgY29uc3QgeyBhLCBiIH0gPSBDVVJWRTtcbiAgICAgICAgICAgIGNvbnN0IGIzID0gRnAubXVsKGIsIF8zbik7XG4gICAgICAgICAgICBjb25zdCB7IHB4OiBYMSwgcHk6IFkxLCBwejogWjEgfSA9IHRoaXM7XG4gICAgICAgICAgICBsZXQgWDMgPSBGcC5aRVJPLCBZMyA9IEZwLlpFUk8sIFozID0gRnAuWkVSTzsgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgICAgICBsZXQgdDAgPSBGcC5tdWwoWDEsIFgxKTsgLy8gc3RlcCAxXG4gICAgICAgICAgICBsZXQgdDEgPSBGcC5tdWwoWTEsIFkxKTtcbiAgICAgICAgICAgIGxldCB0MiA9IEZwLm11bChaMSwgWjEpO1xuICAgICAgICAgICAgbGV0IHQzID0gRnAubXVsKFgxLCBZMSk7XG4gICAgICAgICAgICB0MyA9IEZwLmFkZCh0MywgdDMpOyAvLyBzdGVwIDVcbiAgICAgICAgICAgIFozID0gRnAubXVsKFgxLCBaMSk7XG4gICAgICAgICAgICBaMyA9IEZwLmFkZChaMywgWjMpO1xuICAgICAgICAgICAgWDMgPSBGcC5tdWwoYSwgWjMpO1xuICAgICAgICAgICAgWTMgPSBGcC5tdWwoYjMsIHQyKTtcbiAgICAgICAgICAgIFkzID0gRnAuYWRkKFgzLCBZMyk7IC8vIHN0ZXAgMTBcbiAgICAgICAgICAgIFgzID0gRnAuc3ViKHQxLCBZMyk7XG4gICAgICAgICAgICBZMyA9IEZwLmFkZCh0MSwgWTMpO1xuICAgICAgICAgICAgWTMgPSBGcC5tdWwoWDMsIFkzKTtcbiAgICAgICAgICAgIFgzID0gRnAubXVsKHQzLCBYMyk7XG4gICAgICAgICAgICBaMyA9IEZwLm11bChiMywgWjMpOyAvLyBzdGVwIDE1XG4gICAgICAgICAgICB0MiA9IEZwLm11bChhLCB0Mik7XG4gICAgICAgICAgICB0MyA9IEZwLnN1Yih0MCwgdDIpO1xuICAgICAgICAgICAgdDMgPSBGcC5tdWwoYSwgdDMpO1xuICAgICAgICAgICAgdDMgPSBGcC5hZGQodDMsIFozKTtcbiAgICAgICAgICAgIFozID0gRnAuYWRkKHQwLCB0MCk7IC8vIHN0ZXAgMjBcbiAgICAgICAgICAgIHQwID0gRnAuYWRkKFozLCB0MCk7XG4gICAgICAgICAgICB0MCA9IEZwLmFkZCh0MCwgdDIpO1xuICAgICAgICAgICAgdDAgPSBGcC5tdWwodDAsIHQzKTtcbiAgICAgICAgICAgIFkzID0gRnAuYWRkKFkzLCB0MCk7XG4gICAgICAgICAgICB0MiA9IEZwLm11bChZMSwgWjEpOyAvLyBzdGVwIDI1XG4gICAgICAgICAgICB0MiA9IEZwLmFkZCh0MiwgdDIpO1xuICAgICAgICAgICAgdDAgPSBGcC5tdWwodDIsIHQzKTtcbiAgICAgICAgICAgIFgzID0gRnAuc3ViKFgzLCB0MCk7XG4gICAgICAgICAgICBaMyA9IEZwLm11bCh0MiwgdDEpO1xuICAgICAgICAgICAgWjMgPSBGcC5hZGQoWjMsIFozKTsgLy8gc3RlcCAzMFxuICAgICAgICAgICAgWjMgPSBGcC5hZGQoWjMsIFozKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQoWDMsIFkzLCBaMyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVuZXMtQ29zdGVsbG8tQmF0aW5hIGV4Y2VwdGlvbi1mcmVlIGFkZGl0aW9uIGZvcm11bGEuXG4gICAgICAgIC8vIFRoZXJlIGlzIDMwJSBmYXN0ZXIgSmFjb2JpYW4gZm9ybXVsYSwgYnV0IGl0IGlzIG5vdCBjb21wbGV0ZS5cbiAgICAgICAgLy8gaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAxNS8xMDYwLCBhbGdvcml0aG0gMVxuICAgICAgICAvLyBDb3N0OiAxMk0gKyAwUyArIDMqYSArIDMqYjMgKyAyM2FkZC5cbiAgICAgICAgYWRkKG90aGVyKSB7XG4gICAgICAgICAgICBhcHJqcG9pbnQob3RoZXIpO1xuICAgICAgICAgICAgY29uc3QgeyBweDogWDEsIHB5OiBZMSwgcHo6IFoxIH0gPSB0aGlzO1xuICAgICAgICAgICAgY29uc3QgeyBweDogWDIsIHB5OiBZMiwgcHo6IFoyIH0gPSBvdGhlcjtcbiAgICAgICAgICAgIGxldCBYMyA9IEZwLlpFUk8sIFkzID0gRnAuWkVSTywgWjMgPSBGcC5aRVJPOyAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgICAgIGNvbnN0IGEgPSBDVVJWRS5hO1xuICAgICAgICAgICAgY29uc3QgYjMgPSBGcC5tdWwoQ1VSVkUuYiwgXzNuKTtcbiAgICAgICAgICAgIGxldCB0MCA9IEZwLm11bChYMSwgWDIpOyAvLyBzdGVwIDFcbiAgICAgICAgICAgIGxldCB0MSA9IEZwLm11bChZMSwgWTIpO1xuICAgICAgICAgICAgbGV0IHQyID0gRnAubXVsKFoxLCBaMik7XG4gICAgICAgICAgICBsZXQgdDMgPSBGcC5hZGQoWDEsIFkxKTtcbiAgICAgICAgICAgIGxldCB0NCA9IEZwLmFkZChYMiwgWTIpOyAvLyBzdGVwIDVcbiAgICAgICAgICAgIHQzID0gRnAubXVsKHQzLCB0NCk7XG4gICAgICAgICAgICB0NCA9IEZwLmFkZCh0MCwgdDEpO1xuICAgICAgICAgICAgdDMgPSBGcC5zdWIodDMsIHQ0KTtcbiAgICAgICAgICAgIHQ0ID0gRnAuYWRkKFgxLCBaMSk7XG4gICAgICAgICAgICBsZXQgdDUgPSBGcC5hZGQoWDIsIFoyKTsgLy8gc3RlcCAxMFxuICAgICAgICAgICAgdDQgPSBGcC5tdWwodDQsIHQ1KTtcbiAgICAgICAgICAgIHQ1ID0gRnAuYWRkKHQwLCB0Mik7XG4gICAgICAgICAgICB0NCA9IEZwLnN1Yih0NCwgdDUpO1xuICAgICAgICAgICAgdDUgPSBGcC5hZGQoWTEsIFoxKTtcbiAgICAgICAgICAgIFgzID0gRnAuYWRkKFkyLCBaMik7IC8vIHN0ZXAgMTVcbiAgICAgICAgICAgIHQ1ID0gRnAubXVsKHQ1LCBYMyk7XG4gICAgICAgICAgICBYMyA9IEZwLmFkZCh0MSwgdDIpO1xuICAgICAgICAgICAgdDUgPSBGcC5zdWIodDUsIFgzKTtcbiAgICAgICAgICAgIFozID0gRnAubXVsKGEsIHQ0KTtcbiAgICAgICAgICAgIFgzID0gRnAubXVsKGIzLCB0Mik7IC8vIHN0ZXAgMjBcbiAgICAgICAgICAgIFozID0gRnAuYWRkKFgzLCBaMyk7XG4gICAgICAgICAgICBYMyA9IEZwLnN1Yih0MSwgWjMpO1xuICAgICAgICAgICAgWjMgPSBGcC5hZGQodDEsIFozKTtcbiAgICAgICAgICAgIFkzID0gRnAubXVsKFgzLCBaMyk7XG4gICAgICAgICAgICB0MSA9IEZwLmFkZCh0MCwgdDApOyAvLyBzdGVwIDI1XG4gICAgICAgICAgICB0MSA9IEZwLmFkZCh0MSwgdDApO1xuICAgICAgICAgICAgdDIgPSBGcC5tdWwoYSwgdDIpO1xuICAgICAgICAgICAgdDQgPSBGcC5tdWwoYjMsIHQ0KTtcbiAgICAgICAgICAgIHQxID0gRnAuYWRkKHQxLCB0Mik7XG4gICAgICAgICAgICB0MiA9IEZwLnN1Yih0MCwgdDIpOyAvLyBzdGVwIDMwXG4gICAgICAgICAgICB0MiA9IEZwLm11bChhLCB0Mik7XG4gICAgICAgICAgICB0NCA9IEZwLmFkZCh0NCwgdDIpO1xuICAgICAgICAgICAgdDAgPSBGcC5tdWwodDEsIHQ0KTtcbiAgICAgICAgICAgIFkzID0gRnAuYWRkKFkzLCB0MCk7XG4gICAgICAgICAgICB0MCA9IEZwLm11bCh0NSwgdDQpOyAvLyBzdGVwIDM1XG4gICAgICAgICAgICBYMyA9IEZwLm11bCh0MywgWDMpO1xuICAgICAgICAgICAgWDMgPSBGcC5zdWIoWDMsIHQwKTtcbiAgICAgICAgICAgIHQwID0gRnAubXVsKHQzLCB0MSk7XG4gICAgICAgICAgICBaMyA9IEZwLm11bCh0NSwgWjMpO1xuICAgICAgICAgICAgWjMgPSBGcC5hZGQoWjMsIHQwKTsgLy8gc3RlcCA0MFxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludChYMywgWTMsIFozKTtcbiAgICAgICAgfVxuICAgICAgICBzdWJ0cmFjdChvdGhlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkKG90aGVyLm5lZ2F0ZSgpKTtcbiAgICAgICAgfVxuICAgICAgICBpczAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lcXVhbHMoUG9pbnQuWkVSTyk7XG4gICAgICAgIH1cbiAgICAgICAgd05BRihuKSB7XG4gICAgICAgICAgICByZXR1cm4gd25hZi53TkFGQ2FjaGVkKHRoaXMsIG4sIFBvaW50Lm5vcm1hbGl6ZVopO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOb24tY29uc3RhbnQtdGltZSBtdWx0aXBsaWNhdGlvbi4gVXNlcyBkb3VibGUtYW5kLWFkZCBhbGdvcml0aG0uXG4gICAgICAgICAqIEl0J3MgZmFzdGVyLCBidXQgc2hvdWxkIG9ubHkgYmUgdXNlZCB3aGVuIHlvdSBkb24ndCBjYXJlIGFib3V0XG4gICAgICAgICAqIGFuIGV4cG9zZWQgcHJpdmF0ZSBrZXkgZS5nLiBzaWcgdmVyaWZpY2F0aW9uLCB3aGljaCB3b3JrcyBvdmVyICpwdWJsaWMqIGtleXMuXG4gICAgICAgICAqL1xuICAgICAgICBtdWx0aXBseVVuc2FmZShzYykge1xuICAgICAgICAgICAgY29uc3QgeyBlbmRvLCBuOiBOIH0gPSBDVVJWRTtcbiAgICAgICAgICAgICgwLCB1dGlsc190c18xLmFJblJhbmdlKSgnc2NhbGFyJywgc2MsIF8wbiwgTik7XG4gICAgICAgICAgICBjb25zdCBJID0gUG9pbnQuWkVSTztcbiAgICAgICAgICAgIGlmIChzYyA9PT0gXzBuKVxuICAgICAgICAgICAgICAgIHJldHVybiBJO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXMwKCkgfHwgc2MgPT09IF8xbilcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIC8vIENhc2UgYTogbm8gZW5kb21vcnBoaXNtLiBDYXNlIGI6IGhhcyBwcmVjb21wdXRlcy5cbiAgICAgICAgICAgIGlmICghZW5kbyB8fCB3bmFmLmhhc1ByZWNvbXB1dGVzKHRoaXMpKVxuICAgICAgICAgICAgICAgIHJldHVybiB3bmFmLndOQUZDYWNoZWRVbnNhZmUodGhpcywgc2MsIFBvaW50Lm5vcm1hbGl6ZVopO1xuICAgICAgICAgICAgLy8gQ2FzZSBjOiBlbmRvbW9ycGhpc21cbiAgICAgICAgICAgIC8qKiBTZWUgZG9jcyBmb3Ige0BsaW5rIEVuZG9tb3JwaGlzbU9wdHN9ICovXG4gICAgICAgICAgICBsZXQgeyBrMW5lZywgazEsIGsybmVnLCBrMiB9ID0gZW5kby5zcGxpdFNjYWxhcihzYyk7XG4gICAgICAgICAgICBsZXQgazFwID0gSTtcbiAgICAgICAgICAgIGxldCBrMnAgPSBJO1xuICAgICAgICAgICAgbGV0IGQgPSB0aGlzO1xuICAgICAgICAgICAgd2hpbGUgKGsxID4gXzBuIHx8IGsyID4gXzBuKSB7XG4gICAgICAgICAgICAgICAgaWYgKGsxICYgXzFuKVxuICAgICAgICAgICAgICAgICAgICBrMXAgPSBrMXAuYWRkKGQpO1xuICAgICAgICAgICAgICAgIGlmIChrMiAmIF8xbilcbiAgICAgICAgICAgICAgICAgICAgazJwID0gazJwLmFkZChkKTtcbiAgICAgICAgICAgICAgICBkID0gZC5kb3VibGUoKTtcbiAgICAgICAgICAgICAgICBrMSA+Pj0gXzFuO1xuICAgICAgICAgICAgICAgIGsyID4+PSBfMW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoazFuZWcpXG4gICAgICAgICAgICAgICAgazFwID0gazFwLm5lZ2F0ZSgpO1xuICAgICAgICAgICAgaWYgKGsybmVnKVxuICAgICAgICAgICAgICAgIGsycCA9IGsycC5uZWdhdGUoKTtcbiAgICAgICAgICAgIGsycCA9IG5ldyBQb2ludChGcC5tdWwoazJwLnB4LCBlbmRvLmJldGEpLCBrMnAucHksIGsycC5weik7XG4gICAgICAgICAgICByZXR1cm4gazFwLmFkZChrMnApO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb25zdGFudCB0aW1lIG11bHRpcGxpY2F0aW9uLlxuICAgICAgICAgKiBVc2VzIHdOQUYgbWV0aG9kLiBXaW5kb3dlZCBtZXRob2QgbWF5IGJlIDEwJSBmYXN0ZXIsXG4gICAgICAgICAqIGJ1dCB0YWtlcyAyeCBsb25nZXIgdG8gZ2VuZXJhdGUgYW5kIGNvbnN1bWVzIDJ4IG1lbW9yeS5cbiAgICAgICAgICogVXNlcyBwcmVjb21wdXRlcyB3aGVuIGF2YWlsYWJsZS5cbiAgICAgICAgICogVXNlcyBlbmRvbW9ycGhpc20gZm9yIEtvYmxpdHogY3VydmVzLlxuICAgICAgICAgKiBAcGFyYW0gc2NhbGFyIGJ5IHdoaWNoIHRoZSBwb2ludCB3b3VsZCBiZSBtdWx0aXBsaWVkXG4gICAgICAgICAqIEByZXR1cm5zIE5ldyBwb2ludFxuICAgICAgICAgKi9cbiAgICAgICAgbXVsdGlwbHkoc2NhbGFyKSB7XG4gICAgICAgICAgICBjb25zdCB7IGVuZG8sIG46IE4gfSA9IENVUlZFO1xuICAgICAgICAgICAgKDAsIHV0aWxzX3RzXzEuYUluUmFuZ2UpKCdzY2FsYXInLCBzY2FsYXIsIF8xbiwgTik7XG4gICAgICAgICAgICBsZXQgcG9pbnQsIGZha2U7IC8vIEZha2UgcG9pbnQgaXMgdXNlZCB0byBjb25zdC10aW1lIG11bHRcbiAgICAgICAgICAgIC8qKiBTZWUgZG9jcyBmb3Ige0BsaW5rIEVuZG9tb3JwaGlzbU9wdHN9ICovXG4gICAgICAgICAgICBpZiAoZW5kbykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgazFuZWcsIGsxLCBrMm5lZywgazIgfSA9IGVuZG8uc3BsaXRTY2FsYXIoc2NhbGFyKTtcbiAgICAgICAgICAgICAgICBsZXQgeyBwOiBrMXAsIGY6IGYxcCB9ID0gdGhpcy53TkFGKGsxKTtcbiAgICAgICAgICAgICAgICBsZXQgeyBwOiBrMnAsIGY6IGYycCB9ID0gdGhpcy53TkFGKGsyKTtcbiAgICAgICAgICAgICAgICBrMXAgPSB3bmFmLmNvbnN0VGltZU5lZ2F0ZShrMW5lZywgazFwKTtcbiAgICAgICAgICAgICAgICBrMnAgPSB3bmFmLmNvbnN0VGltZU5lZ2F0ZShrMm5lZywgazJwKTtcbiAgICAgICAgICAgICAgICBrMnAgPSBuZXcgUG9pbnQoRnAubXVsKGsycC5weCwgZW5kby5iZXRhKSwgazJwLnB5LCBrMnAucHopO1xuICAgICAgICAgICAgICAgIHBvaW50ID0gazFwLmFkZChrMnApO1xuICAgICAgICAgICAgICAgIGZha2UgPSBmMXAuYWRkKGYycCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHAsIGYgfSA9IHRoaXMud05BRihzY2FsYXIpO1xuICAgICAgICAgICAgICAgIHBvaW50ID0gcDtcbiAgICAgICAgICAgICAgICBmYWtlID0gZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE5vcm1hbGl6ZSBgemAgZm9yIGJvdGggcG9pbnRzLCBidXQgcmV0dXJuIG9ubHkgcmVhbCBvbmVcbiAgICAgICAgICAgIHJldHVybiBQb2ludC5ub3JtYWxpemVaKFtwb2ludCwgZmFrZV0pWzBdO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFZmZpY2llbnRseSBjYWxjdWxhdGUgYGFQICsgYlFgLiBVbnNhZmUsIGNhbiBleHBvc2UgcHJpdmF0ZSBrZXksIGlmIHVzZWQgaW5jb3JyZWN0bHkuXG4gICAgICAgICAqIE5vdCB1c2luZyBTdHJhdXNzLVNoYW1pciB0cmljazogcHJlY29tcHV0YXRpb24gdGFibGVzIGFyZSBmYXN0ZXIuXG4gICAgICAgICAqIFRoZSB0cmljayBjb3VsZCBiZSB1c2VmdWwgaWYgYm90aCBQIGFuZCBRIGFyZSBub3QgRyAobm90IGluIG91ciBjYXNlKS5cbiAgICAgICAgICogQHJldHVybnMgbm9uLXplcm8gYWZmaW5lIHBvaW50XG4gICAgICAgICAqL1xuICAgICAgICBtdWx0aXBseUFuZEFkZFVuc2FmZShRLCBhLCBiKSB7XG4gICAgICAgICAgICBjb25zdCBHID0gUG9pbnQuQkFTRTsgLy8gTm8gU3RyYXVzcy1TaGFtaXIgdHJpY2s6IHdlIGhhdmUgMTAlIGZhc3RlciBHIHByZWNvbXB1dGVzXG4gICAgICAgICAgICBjb25zdCBtdWwgPSAoUCwgYSAvLyBTZWxlY3QgZmFzdGVyIG11bHRpcGx5KCkgbWV0aG9kXG4gICAgICAgICAgICApID0+IChhID09PSBfMG4gfHwgYSA9PT0gXzFuIHx8ICFQLmVxdWFscyhHKSA/IFAubXVsdGlwbHlVbnNhZmUoYSkgOiBQLm11bHRpcGx5KGEpKTtcbiAgICAgICAgICAgIGNvbnN0IHN1bSA9IG11bCh0aGlzLCBhKS5hZGQobXVsKFEsIGIpKTtcbiAgICAgICAgICAgIHJldHVybiBzdW0uaXMwKCkgPyB1bmRlZmluZWQgOiBzdW07XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29udmVydHMgUHJvamVjdGl2ZSBwb2ludCB0byBhZmZpbmUgKHgsIHkpIGNvb3JkaW5hdGVzLlxuICAgICAgICAvLyBDYW4gYWNjZXB0IHByZWNvbXB1dGVkIFpeLTEgLSBmb3IgZXhhbXBsZSwgZnJvbSBpbnZlcnRCYXRjaC5cbiAgICAgICAgLy8gKHgsIHksIHopIOKIiyAoeD14L3osIHk9eS96KVxuICAgICAgICB0b0FmZmluZShpeikge1xuICAgICAgICAgICAgcmV0dXJuIHRvQWZmaW5lTWVtbyh0aGlzLCBpeik7XG4gICAgICAgIH1cbiAgICAgICAgaXNUb3JzaW9uRnJlZSgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgaDogY29mYWN0b3IsIGlzVG9yc2lvbkZyZWUgfSA9IENVUlZFO1xuICAgICAgICAgICAgaWYgKGNvZmFjdG9yID09PSBfMW4pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7IC8vIE5vIHN1Ymdyb3VwcywgYWx3YXlzIHRvcnNpb24tZnJlZVxuICAgICAgICAgICAgaWYgKGlzVG9yc2lvbkZyZWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzVG9yc2lvbkZyZWUoUG9pbnQsIHRoaXMpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpc1RvcnNpb25GcmVlKCkgaGFzIG5vdCBiZWVuIGRlY2xhcmVkIGZvciB0aGUgZWxsaXB0aWMgY3VydmUnKTtcbiAgICAgICAgfVxuICAgICAgICBjbGVhckNvZmFjdG9yKCkge1xuICAgICAgICAgICAgY29uc3QgeyBoOiBjb2ZhY3RvciwgY2xlYXJDb2ZhY3RvciB9ID0gQ1VSVkU7XG4gICAgICAgICAgICBpZiAoY29mYWN0b3IgPT09IF8xbilcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpczsgLy8gRmFzdC1wYXRoXG4gICAgICAgICAgICBpZiAoY2xlYXJDb2ZhY3RvcilcbiAgICAgICAgICAgICAgICByZXR1cm4gY2xlYXJDb2ZhY3RvcihQb2ludCwgdGhpcyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tdWx0aXBseVVuc2FmZShDVVJWRS5oKTtcbiAgICAgICAgfVxuICAgICAgICB0b1Jhd0J5dGVzKGlzQ29tcHJlc3NlZCA9IHRydWUpIHtcbiAgICAgICAgICAgICgwLCB1dGlsc190c18xLmFib29sKSgnaXNDb21wcmVzc2VkJywgaXNDb21wcmVzc2VkKTtcbiAgICAgICAgICAgIHRoaXMuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICAgICAgICAgIHJldHVybiB0b0J5dGVzKFBvaW50LCB0aGlzLCBpc0NvbXByZXNzZWQpO1xuICAgICAgICB9XG4gICAgICAgIHRvSGV4KGlzQ29tcHJlc3NlZCA9IHRydWUpIHtcbiAgICAgICAgICAgICgwLCB1dGlsc190c18xLmFib29sKSgnaXNDb21wcmVzc2VkJywgaXNDb21wcmVzc2VkKTtcbiAgICAgICAgICAgIHJldHVybiAoMCwgdXRpbHNfdHNfMS5ieXRlc1RvSGV4KSh0aGlzLnRvUmF3Qnl0ZXMoaXNDb21wcmVzc2VkKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gYmFzZSAvIGdlbmVyYXRvciBwb2ludFxuICAgIFBvaW50LkJBU0UgPSBuZXcgUG9pbnQoQ1VSVkUuR3gsIENVUlZFLkd5LCBGcC5PTkUpO1xuICAgIC8vIHplcm8gLyBpbmZpbml0eSAvIGlkZW50aXR5IHBvaW50XG4gICAgUG9pbnQuWkVSTyA9IG5ldyBQb2ludChGcC5aRVJPLCBGcC5PTkUsIEZwLlpFUk8pOyAvLyAwLCAxLCAwXG4gICAgY29uc3QgeyBlbmRvLCBuQml0TGVuZ3RoIH0gPSBDVVJWRTtcbiAgICBjb25zdCB3bmFmID0gKDAsIGN1cnZlX3RzXzEud05BRikoUG9pbnQsIGVuZG8gPyBNYXRoLmNlaWwobkJpdExlbmd0aCAvIDIpIDogbkJpdExlbmd0aCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgQ1VSVkUsXG4gICAgICAgIFByb2plY3RpdmVQb2ludDogUG9pbnQsXG4gICAgICAgIG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIsXG4gICAgICAgIHdlaWVyc3RyYXNzRXF1YXRpb24sXG4gICAgICAgIGlzV2l0aGluQ3VydmVPcmRlcixcbiAgICB9O1xufVxuZnVuY3Rpb24gdmFsaWRhdGVPcHRzKGN1cnZlKSB7XG4gICAgY29uc3Qgb3B0cyA9ICgwLCBjdXJ2ZV90c18xLnZhbGlkYXRlQmFzaWMpKGN1cnZlKTtcbiAgICAoMCwgdXRpbHNfdHNfMS52YWxpZGF0ZU9iamVjdCkob3B0cywge1xuICAgICAgICBoYXNoOiAnaGFzaCcsXG4gICAgICAgIGhtYWM6ICdmdW5jdGlvbicsXG4gICAgICAgIHJhbmRvbUJ5dGVzOiAnZnVuY3Rpb24nLFxuICAgIH0sIHtcbiAgICAgICAgYml0czJpbnQ6ICdmdW5jdGlvbicsXG4gICAgICAgIGJpdHMyaW50X21vZE46ICdmdW5jdGlvbicsXG4gICAgICAgIGxvd1M6ICdib29sZWFuJyxcbiAgICB9KTtcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7IGxvd1M6IHRydWUsIC4uLm9wdHMgfSk7XG59XG4vKipcbiAqIENyZWF0ZXMgc2hvcnQgd2VpZXJzdHJhc3MgY3VydmUgYW5kIEVDRFNBIHNpZ25hdHVyZSBtZXRob2RzIGZvciBpdC5cbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgeyBGaWVsZCB9IGZyb20gJ0Bub2JsZS9jdXJ2ZXMvYWJzdHJhY3QvbW9kdWxhcic7XG4gKiAvLyBCZWZvcmUgdGhhdCwgZGVmaW5lIEJpZ0ludC1zOiBhLCBiLCBwLCBuLCBHeCwgR3lcbiAqIGNvbnN0IGN1cnZlID0gd2VpZXJzdHJhc3MoeyBhLCBiLCBGcDogRmllbGQocCksIG4sIEd4LCBHeSwgaDogMW4gfSlcbiAqL1xuZnVuY3Rpb24gd2VpZXJzdHJhc3MoY3VydmVEZWYpIHtcbiAgICBjb25zdCBDVVJWRSA9IHZhbGlkYXRlT3B0cyhjdXJ2ZURlZik7XG4gICAgY29uc3QgeyBGcCwgbjogQ1VSVkVfT1JERVIsIG5CeXRlTGVuZ3RoLCBuQml0TGVuZ3RoIH0gPSBDVVJWRTtcbiAgICBjb25zdCBjb21wcmVzc2VkTGVuID0gRnAuQllURVMgKyAxOyAvLyBlLmcuIDMzIGZvciAzMlxuICAgIGNvbnN0IHVuY29tcHJlc3NlZExlbiA9IDIgKiBGcC5CWVRFUyArIDE7IC8vIGUuZy4gNjUgZm9yIDMyXG4gICAgZnVuY3Rpb24gbW9kTihhKSB7XG4gICAgICAgIHJldHVybiAoMCwgbW9kdWxhcl90c18xLm1vZCkoYSwgQ1VSVkVfT1JERVIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbnZOKGEpIHtcbiAgICAgICAgcmV0dXJuICgwLCBtb2R1bGFyX3RzXzEuaW52ZXJ0KShhLCBDVVJWRV9PUkRFUik7XG4gICAgfVxuICAgIGNvbnN0IHsgUHJvamVjdGl2ZVBvaW50OiBQb2ludCwgbm9ybVByaXZhdGVLZXlUb1NjYWxhciwgd2VpZXJzdHJhc3NFcXVhdGlvbiwgaXNXaXRoaW5DdXJ2ZU9yZGVyLCB9ID0gd2VpZXJzdHJhc3NQb2ludHMoe1xuICAgICAgICAuLi5DVVJWRSxcbiAgICAgICAgdG9CeXRlcyhfYywgcG9pbnQsIGlzQ29tcHJlc3NlZCkge1xuICAgICAgICAgICAgY29uc3QgYSA9IHBvaW50LnRvQWZmaW5lKCk7XG4gICAgICAgICAgICBjb25zdCB4ID0gRnAudG9CeXRlcyhhLngpO1xuICAgICAgICAgICAgY29uc3QgY2F0ID0gdXRpbHNfdHNfMS5jb25jYXRCeXRlcztcbiAgICAgICAgICAgICgwLCB1dGlsc190c18xLmFib29sKSgnaXNDb21wcmVzc2VkJywgaXNDb21wcmVzc2VkKTtcbiAgICAgICAgICAgIGlmIChpc0NvbXByZXNzZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2F0KFVpbnQ4QXJyYXkuZnJvbShbcG9pbnQuaGFzRXZlblkoKSA/IDB4MDIgOiAweDAzXSksIHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhdChVaW50OEFycmF5LmZyb20oWzB4MDRdKSwgeCwgRnAudG9CeXRlcyhhLnkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZnJvbUJ5dGVzKGJ5dGVzKSB7XG4gICAgICAgICAgICBjb25zdCBsZW4gPSBieXRlcy5sZW5ndGg7XG4gICAgICAgICAgICBjb25zdCBoZWFkID0gYnl0ZXNbMF07XG4gICAgICAgICAgICBjb25zdCB0YWlsID0gYnl0ZXMuc3ViYXJyYXkoMSk7XG4gICAgICAgICAgICAvLyB0aGlzLmFzc2VydFZhbGlkaXR5KCkgaXMgZG9uZSBpbnNpZGUgb2YgZnJvbUhleFxuICAgICAgICAgICAgaWYgKGxlbiA9PT0gY29tcHJlc3NlZExlbiAmJiAoaGVhZCA9PT0gMHgwMiB8fCBoZWFkID09PSAweDAzKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHggPSAoMCwgdXRpbHNfdHNfMS5ieXRlc1RvTnVtYmVyQkUpKHRhaWwpO1xuICAgICAgICAgICAgICAgIGlmICghKDAsIHV0aWxzX3RzXzEuaW5SYW5nZSkoeCwgXzFuLCBGcC5PUkRFUikpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUG9pbnQgaXMgbm90IG9uIGN1cnZlJyk7XG4gICAgICAgICAgICAgICAgY29uc3QgeTIgPSB3ZWllcnN0cmFzc0VxdWF0aW9uKHgpOyAvLyB5wrIgPSB4wrMgKyBheCArIGJcbiAgICAgICAgICAgICAgICBsZXQgeTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB5ID0gRnAuc3FydCh5Mik7IC8vIHkgPSB5wrIgXiAocCsxKS80XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChzcXJ0RXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3VmZml4ID0gc3FydEVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyAnOiAnICsgc3FydEVycm9yLm1lc3NhZ2UgOiAnJztcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQb2ludCBpcyBub3Qgb24gY3VydmUnICsgc3VmZml4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgaXNZT2RkID0gKHkgJiBfMW4pID09PSBfMW47XG4gICAgICAgICAgICAgICAgLy8gRUNEU0FcbiAgICAgICAgICAgICAgICBjb25zdCBpc0hlYWRPZGQgPSAoaGVhZCAmIDEpID09PSAxO1xuICAgICAgICAgICAgICAgIGlmIChpc0hlYWRPZGQgIT09IGlzWU9kZClcbiAgICAgICAgICAgICAgICAgICAgeSA9IEZwLm5lZyh5KTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChsZW4gPT09IHVuY29tcHJlc3NlZExlbiAmJiBoZWFkID09PSAweDA0KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeCA9IEZwLmZyb21CeXRlcyh0YWlsLnN1YmFycmF5KDAsIEZwLkJZVEVTKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgeSA9IEZwLmZyb21CeXRlcyh0YWlsLnN1YmFycmF5KEZwLkJZVEVTLCAyICogRnAuQllURVMpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjbCA9IGNvbXByZXNzZWRMZW47XG4gICAgICAgICAgICAgICAgY29uc3QgdWwgPSB1bmNvbXByZXNzZWRMZW47XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIFBvaW50LCBleHBlY3RlZCBsZW5ndGggb2YgJyArIGNsICsgJywgb3IgdW5jb21wcmVzc2VkICcgKyB1bCArICcsIGdvdCAnICsgbGVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICB9KTtcbiAgICBmdW5jdGlvbiBpc0JpZ2dlclRoYW5IYWxmT3JkZXIobnVtYmVyKSB7XG4gICAgICAgIGNvbnN0IEhBTEYgPSBDVVJWRV9PUkRFUiA+PiBfMW47XG4gICAgICAgIHJldHVybiBudW1iZXIgPiBIQUxGO1xuICAgIH1cbiAgICBmdW5jdGlvbiBub3JtYWxpemVTKHMpIHtcbiAgICAgICAgcmV0dXJuIGlzQmlnZ2VyVGhhbkhhbGZPcmRlcihzKSA/IG1vZE4oLXMpIDogcztcbiAgICB9XG4gICAgLy8gc2xpY2UgYnl0ZXMgbnVtXG4gICAgY29uc3Qgc2xjTnVtID0gKGIsIGZyb20sIHRvKSA9PiAoMCwgdXRpbHNfdHNfMS5ieXRlc1RvTnVtYmVyQkUpKGIuc2xpY2UoZnJvbSwgdG8pKTtcbiAgICAvKipcbiAgICAgKiBFQ0RTQSBzaWduYXR1cmUgd2l0aCBpdHMgKHIsIHMpIHByb3BlcnRpZXMuIFN1cHBvcnRzIERFUiAmIGNvbXBhY3QgcmVwcmVzZW50YXRpb25zLlxuICAgICAqL1xuICAgIGNsYXNzIFNpZ25hdHVyZSB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHIsIHMsIHJlY292ZXJ5KSB7XG4gICAgICAgICAgICAoMCwgdXRpbHNfdHNfMS5hSW5SYW5nZSkoJ3InLCByLCBfMW4sIENVUlZFX09SREVSKTsgLy8gciBpbiBbMS4uTl1cbiAgICAgICAgICAgICgwLCB1dGlsc190c18xLmFJblJhbmdlKSgncycsIHMsIF8xbiwgQ1VSVkVfT1JERVIpOyAvLyBzIGluIFsxLi5OXVxuICAgICAgICAgICAgdGhpcy5yID0gcjtcbiAgICAgICAgICAgIHRoaXMucyA9IHM7XG4gICAgICAgICAgICBpZiAocmVjb3ZlcnkgIT0gbnVsbClcbiAgICAgICAgICAgICAgICB0aGlzLnJlY292ZXJ5ID0gcmVjb3Zlcnk7XG4gICAgICAgICAgICBPYmplY3QuZnJlZXplKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHBhaXIgKGJ5dGVzIG9mIHIsIGJ5dGVzIG9mIHMpXG4gICAgICAgIHN0YXRpYyBmcm9tQ29tcGFjdChoZXgpIHtcbiAgICAgICAgICAgIGNvbnN0IGwgPSBuQnl0ZUxlbmd0aDtcbiAgICAgICAgICAgIGhleCA9ICgwLCB1dGlsc190c18xLmVuc3VyZUJ5dGVzKSgnY29tcGFjdFNpZ25hdHVyZScsIGhleCwgbCAqIDIpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTaWduYXR1cmUoc2xjTnVtKGhleCwgMCwgbCksIHNsY051bShoZXgsIGwsIDIgKiBsKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gREVSIGVuY29kZWQgRUNEU0Egc2lnbmF0dXJlXG4gICAgICAgIC8vIGh0dHBzOi8vYml0Y29pbi5zdGFja2V4Y2hhbmdlLmNvbS9xdWVzdGlvbnMvNTc2NDQvd2hhdC1hcmUtdGhlLXBhcnRzLW9mLWEtYml0Y29pbi10cmFuc2FjdGlvbi1pbnB1dC1zY3JpcHRcbiAgICAgICAgc3RhdGljIGZyb21ERVIoaGV4KSB7XG4gICAgICAgICAgICBjb25zdCB7IHIsIHMgfSA9IGV4cG9ydHMuREVSLnRvU2lnKCgwLCB1dGlsc190c18xLmVuc3VyZUJ5dGVzKSgnREVSJywgaGV4KSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNpZ25hdHVyZShyLCBzKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHRvZG8gcmVtb3ZlXG4gICAgICAgICAqIEBkZXByZWNhdGVkXG4gICAgICAgICAqL1xuICAgICAgICBhc3NlcnRWYWxpZGl0eSgpIHsgfVxuICAgICAgICBhZGRSZWNvdmVyeUJpdChyZWNvdmVyeSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTaWduYXR1cmUodGhpcy5yLCB0aGlzLnMsIHJlY292ZXJ5KTtcbiAgICAgICAgfVxuICAgICAgICByZWNvdmVyUHVibGljS2V5KG1zZ0hhc2gpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgciwgcywgcmVjb3Zlcnk6IHJlYyB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IGggPSBiaXRzMmludF9tb2ROKCgwLCB1dGlsc190c18xLmVuc3VyZUJ5dGVzKSgnbXNnSGFzaCcsIG1zZ0hhc2gpKTsgLy8gVHJ1bmNhdGUgaGFzaFxuICAgICAgICAgICAgaWYgKHJlYyA9PSBudWxsIHx8ICFbMCwgMSwgMiwgM10uaW5jbHVkZXMocmVjKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlY292ZXJ5IGlkIGludmFsaWQnKTtcbiAgICAgICAgICAgIGNvbnN0IHJhZGogPSByZWMgPT09IDIgfHwgcmVjID09PSAzID8gciArIENVUlZFLm4gOiByO1xuICAgICAgICAgICAgaWYgKHJhZGogPj0gRnAuT1JERVIpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZWNvdmVyeSBpZCAyIG9yIDMgaW52YWxpZCcpO1xuICAgICAgICAgICAgY29uc3QgcHJlZml4ID0gKHJlYyAmIDEpID09PSAwID8gJzAyJyA6ICcwMyc7XG4gICAgICAgICAgICBjb25zdCBSID0gUG9pbnQuZnJvbUhleChwcmVmaXggKyBudW1Ub1NpemVkSGV4KHJhZGosIEZwLkJZVEVTKSk7XG4gICAgICAgICAgICBjb25zdCBpciA9IGludk4ocmFkaik7IC8vIHJeLTFcbiAgICAgICAgICAgIGNvbnN0IHUxID0gbW9kTigtaCAqIGlyKTsgLy8gLWhyXi0xXG4gICAgICAgICAgICBjb25zdCB1MiA9IG1vZE4ocyAqIGlyKTsgLy8gc3JeLTFcbiAgICAgICAgICAgIGNvbnN0IFEgPSBQb2ludC5CQVNFLm11bHRpcGx5QW5kQWRkVW5zYWZlKFIsIHUxLCB1Mik7IC8vIChzcl4tMSlSLShocl4tMSlHID0gLShocl4tMSlHICsgKHNyXi0xKVxuICAgICAgICAgICAgaWYgKCFRKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncG9pbnQgYXQgaW5maW5pZnknKTsgLy8gdW5zYWZlIGlzIGZpbmU6IG5vIHByaXYgZGF0YSBsZWFrZWRcbiAgICAgICAgICAgIFEuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICAgICAgICAgIHJldHVybiBRO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNpZ25hdHVyZXMgc2hvdWxkIGJlIGxvdy1zLCB0byBwcmV2ZW50IG1hbGxlYWJpbGl0eS5cbiAgICAgICAgaGFzSGlnaFMoKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNCaWdnZXJUaGFuSGFsZk9yZGVyKHRoaXMucyk7XG4gICAgICAgIH1cbiAgICAgICAgbm9ybWFsaXplUygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhhc0hpZ2hTKCkgPyBuZXcgU2lnbmF0dXJlKHRoaXMuciwgbW9kTigtdGhpcy5zKSwgdGhpcy5yZWNvdmVyeSkgOiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIC8vIERFUi1lbmNvZGVkXG4gICAgICAgIHRvREVSUmF3Qnl0ZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIHV0aWxzX3RzXzEuaGV4VG9CeXRlcykodGhpcy50b0RFUkhleCgpKTtcbiAgICAgICAgfVxuICAgICAgICB0b0RFUkhleCgpIHtcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLkRFUi5oZXhGcm9tU2lnKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHBhZGRlZCBieXRlcyBvZiByLCB0aGVuIHBhZGRlZCBieXRlcyBvZiBzXG4gICAgICAgIHRvQ29tcGFjdFJhd0J5dGVzKCkge1xuICAgICAgICAgICAgcmV0dXJuICgwLCB1dGlsc190c18xLmhleFRvQnl0ZXMpKHRoaXMudG9Db21wYWN0SGV4KCkpO1xuICAgICAgICB9XG4gICAgICAgIHRvQ29tcGFjdEhleCgpIHtcbiAgICAgICAgICAgIGNvbnN0IGwgPSBuQnl0ZUxlbmd0aDtcbiAgICAgICAgICAgIHJldHVybiBudW1Ub1NpemVkSGV4KHRoaXMuciwgbCkgKyBudW1Ub1NpemVkSGV4KHRoaXMucywgbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgdXRpbHMgPSB7XG4gICAgICAgIGlzVmFsaWRQcml2YXRlS2V5KHByaXZhdGVLZXkpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbm9ybVByaXZhdGVLZXlUb1NjYWxhcihwcml2YXRlS2V5KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbm9ybVByaXZhdGVLZXlUb1NjYWxhcjogbm9ybVByaXZhdGVLZXlUb1NjYWxhcixcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb2R1Y2VzIGNyeXB0b2dyYXBoaWNhbGx5IHNlY3VyZSBwcml2YXRlIGtleSBmcm9tIHJhbmRvbSBvZiBzaXplXG4gICAgICAgICAqIChncm91cExlbiArIGNlaWwoZ3JvdXBMZW4gLyAyKSkgd2l0aCBtb2R1bG8gYmlhcyBiZWluZyBuZWdsaWdpYmxlLlxuICAgICAgICAgKi9cbiAgICAgICAgcmFuZG9tUHJpdmF0ZUtleTogKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gKDAsIG1vZHVsYXJfdHNfMS5nZXRNaW5IYXNoTGVuZ3RoKShDVVJWRS5uKTtcbiAgICAgICAgICAgIHJldHVybiAoMCwgbW9kdWxhcl90c18xLm1hcEhhc2hUb0ZpZWxkKShDVVJWRS5yYW5kb21CeXRlcyhsZW5ndGgpLCBDVVJWRS5uKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgcHJlY29tcHV0ZSB0YWJsZSBmb3IgYW4gYXJiaXRyYXJ5IEVDIHBvaW50LiBNYWtlcyBwb2ludCBcImNhY2hlZFwiLlxuICAgICAgICAgKiBBbGxvd3MgdG8gbWFzc2l2ZWx5IHNwZWVkLXVwIGBwb2ludC5tdWx0aXBseShzY2FsYXIpYC5cbiAgICAgICAgICogQHJldHVybnMgY2FjaGVkIHBvaW50XG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGNvbnN0IGZhc3QgPSB1dGlscy5wcmVjb21wdXRlKDgsIFByb2plY3RpdmVQb2ludC5mcm9tSGV4KHNvbWVvbmVzUHViS2V5KSk7XG4gICAgICAgICAqIGZhc3QubXVsdGlwbHkocHJpdktleSk7IC8vIG11Y2ggZmFzdGVyIEVDREggbm93XG4gICAgICAgICAqL1xuICAgICAgICBwcmVjb21wdXRlKHdpbmRvd1NpemUgPSA4LCBwb2ludCA9IFBvaW50LkJBU0UpIHtcbiAgICAgICAgICAgIHBvaW50Ll9zZXRXaW5kb3dTaXplKHdpbmRvd1NpemUpO1xuICAgICAgICAgICAgcG9pbnQubXVsdGlwbHkoQmlnSW50KDMpKTsgLy8gMyBpcyBhcmJpdHJhcnksIGp1c3QgbmVlZCBhbnkgbnVtYmVyIGhlcmVcbiAgICAgICAgICAgIHJldHVybiBwb2ludDtcbiAgICAgICAgfSxcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHB1YmxpYyBrZXkgZm9yIGEgcHJpdmF0ZSBrZXkuIENoZWNrcyBmb3IgdmFsaWRpdHkgb2YgdGhlIHByaXZhdGUga2V5LlxuICAgICAqIEBwYXJhbSBwcml2YXRlS2V5IHByaXZhdGUga2V5XG4gICAgICogQHBhcmFtIGlzQ29tcHJlc3NlZCB3aGV0aGVyIHRvIHJldHVybiBjb21wYWN0IChkZWZhdWx0KSwgb3IgZnVsbCBrZXlcbiAgICAgKiBAcmV0dXJucyBQdWJsaWMga2V5LCBmdWxsIHdoZW4gaXNDb21wcmVzc2VkPWZhbHNlOyBzaG9ydCB3aGVuIGlzQ29tcHJlc3NlZD10cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0UHVibGljS2V5KHByaXZhdGVLZXksIGlzQ29tcHJlc3NlZCA9IHRydWUpIHtcbiAgICAgICAgcmV0dXJuIFBvaW50LmZyb21Qcml2YXRlS2V5KHByaXZhdGVLZXkpLnRvUmF3Qnl0ZXMoaXNDb21wcmVzc2VkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUXVpY2sgYW5kIGRpcnR5IGNoZWNrIGZvciBpdGVtIGJlaW5nIHB1YmxpYyBrZXkuIERvZXMgbm90IHZhbGlkYXRlIGhleCwgb3IgYmVpbmcgb24tY3VydmUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNQcm9iUHViKGl0ZW0pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpdGVtID09PSAnYmlnaW50JylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBQb2ludClcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBjb25zdCBhcnIgPSAoMCwgdXRpbHNfdHNfMS5lbnN1cmVCeXRlcykoJ2tleScsIGl0ZW0pO1xuICAgICAgICBjb25zdCBsZW4gPSBhcnIubGVuZ3RoO1xuICAgICAgICBjb25zdCBmcGwgPSBGcC5CWVRFUztcbiAgICAgICAgY29uc3QgY29tcExlbiA9IGZwbCArIDE7IC8vIGUuZy4gMzMgZm9yIDMyXG4gICAgICAgIGNvbnN0IHVuY29tcExlbiA9IDIgKiBmcGwgKyAxOyAvLyBlLmcuIDY1IGZvciAzMlxuICAgICAgICBpZiAoQ1VSVkUuYWxsb3dlZFByaXZhdGVLZXlMZW5ndGhzIHx8IG5CeXRlTGVuZ3RoID09PSBjb21wTGVuKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGxlbiA9PT0gY29tcExlbiB8fCBsZW4gPT09IHVuY29tcExlbjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBFQ0RIIChFbGxpcHRpYyBDdXJ2ZSBEaWZmaWUgSGVsbG1hbikuXG4gICAgICogQ29tcHV0ZXMgc2hhcmVkIHB1YmxpYyBrZXkgZnJvbSBwcml2YXRlIGtleSBhbmQgcHVibGljIGtleS5cbiAgICAgKiBDaGVja3M6IDEpIHByaXZhdGUga2V5IHZhbGlkaXR5IDIpIHNoYXJlZCBrZXkgaXMgb24tY3VydmUuXG4gICAgICogRG9lcyBOT1QgaGFzaCB0aGUgcmVzdWx0LlxuICAgICAqIEBwYXJhbSBwcml2YXRlQSBwcml2YXRlIGtleVxuICAgICAqIEBwYXJhbSBwdWJsaWNCIGRpZmZlcmVudCBwdWJsaWMga2V5XG4gICAgICogQHBhcmFtIGlzQ29tcHJlc3NlZCB3aGV0aGVyIHRvIHJldHVybiBjb21wYWN0IChkZWZhdWx0KSwgb3IgZnVsbCBrZXlcbiAgICAgKiBAcmV0dXJucyBzaGFyZWQgcHVibGljIGtleVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFNoYXJlZFNlY3JldChwcml2YXRlQSwgcHVibGljQiwgaXNDb21wcmVzc2VkID0gdHJ1ZSkge1xuICAgICAgICBpZiAoaXNQcm9iUHViKHByaXZhdGVBKSA9PT0gdHJ1ZSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZmlyc3QgYXJnIG11c3QgYmUgcHJpdmF0ZSBrZXknKTtcbiAgICAgICAgaWYgKGlzUHJvYlB1YihwdWJsaWNCKSA9PT0gZmFsc2UpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NlY29uZCBhcmcgbXVzdCBiZSBwdWJsaWMga2V5Jyk7XG4gICAgICAgIGNvbnN0IGIgPSBQb2ludC5mcm9tSGV4KHB1YmxpY0IpOyAvLyBjaGVjayBmb3IgYmVpbmcgb24tY3VydmVcbiAgICAgICAgcmV0dXJuIGIubXVsdGlwbHkobm9ybVByaXZhdGVLZXlUb1NjYWxhcihwcml2YXRlQSkpLnRvUmF3Qnl0ZXMoaXNDb21wcmVzc2VkKTtcbiAgICB9XG4gICAgLy8gUkZDNjk3OTogZW5zdXJlIEVDRFNBIG1zZyBpcyBYIGJ5dGVzIGFuZCA8IE4uIFJGQyBzdWdnZXN0cyBvcHRpb25hbCB0cnVuY2F0aW5nIHZpYSBiaXRzMm9jdGV0cy5cbiAgICAvLyBGSVBTIDE4Ni00IDQuNiBzdWdnZXN0cyB0aGUgbGVmdG1vc3QgbWluKG5CaXRMZW4sIG91dExlbikgYml0cywgd2hpY2ggbWF0Y2hlcyBiaXRzMmludC5cbiAgICAvLyBiaXRzMmludCBjYW4gcHJvZHVjZSByZXM+Tiwgd2UgY2FuIGRvIG1vZChyZXMsIE4pIHNpbmNlIHRoZSBiaXRMZW4gaXMgdGhlIHNhbWUuXG4gICAgLy8gaW50Mm9jdGV0cyBjYW4ndCBiZSB1c2VkOyBwYWRzIHNtYWxsIG1zZ3Mgd2l0aCAwOiB1bmFjY2VwdGF0YmxlIGZvciB0cnVuYyBhcyBwZXIgUkZDIHZlY3RvcnNcbiAgICBjb25zdCBiaXRzMmludCA9IENVUlZFLmJpdHMyaW50IHx8XG4gICAgICAgIGZ1bmN0aW9uIChieXRlcykge1xuICAgICAgICAgICAgLy8gT3VyIGN1c3RvbSBjaGVjayBcImp1c3QgaW4gY2FzZVwiLCBmb3IgcHJvdGVjdGlvbiBhZ2FpbnN0IERvU1xuICAgICAgICAgICAgaWYgKGJ5dGVzLmxlbmd0aCA+IDgxOTIpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnB1dCBpcyB0b28gbGFyZ2UnKTtcbiAgICAgICAgICAgIC8vIEZvciBjdXJ2ZXMgd2l0aCBuQml0TGVuZ3RoICUgOCAhPT0gMDogYml0czJvY3RldHMoYml0czJvY3RldHMobSkpICE9PSBiaXRzMm9jdGV0cyhtKVxuICAgICAgICAgICAgLy8gZm9yIHNvbWUgY2FzZXMsIHNpbmNlIGJ5dGVzLmxlbmd0aCAqIDggaXMgbm90IGFjdHVhbCBiaXRMZW5ndGguXG4gICAgICAgICAgICBjb25zdCBudW0gPSAoMCwgdXRpbHNfdHNfMS5ieXRlc1RvTnVtYmVyQkUpKGJ5dGVzKTsgLy8gY2hlY2sgZm9yID09IHU4IGRvbmUgaGVyZVxuICAgICAgICAgICAgY29uc3QgZGVsdGEgPSBieXRlcy5sZW5ndGggKiA4IC0gbkJpdExlbmd0aDsgLy8gdHJ1bmNhdGUgdG8gbkJpdExlbmd0aCBsZWZ0bW9zdCBiaXRzXG4gICAgICAgICAgICByZXR1cm4gZGVsdGEgPiAwID8gbnVtID4+IEJpZ0ludChkZWx0YSkgOiBudW07XG4gICAgICAgIH07XG4gICAgY29uc3QgYml0czJpbnRfbW9kTiA9IENVUlZFLmJpdHMyaW50X21vZE4gfHxcbiAgICAgICAgZnVuY3Rpb24gKGJ5dGVzKSB7XG4gICAgICAgICAgICByZXR1cm4gbW9kTihiaXRzMmludChieXRlcykpOyAvLyBjYW4ndCB1c2UgYnl0ZXNUb051bWJlckJFIGhlcmVcbiAgICAgICAgfTtcbiAgICAvLyBOT1RFOiBwYWRzIG91dHB1dCB3aXRoIHplcm8gYXMgcGVyIHNwZWNcbiAgICBjb25zdCBPUkRFUl9NQVNLID0gKDAsIHV0aWxzX3RzXzEuYml0TWFzaykobkJpdExlbmd0aCk7XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdG8gYnl0ZXMuIENoZWNrcyBpZiBudW0gaW4gYFswLi5PUkRFUl9NQVNLLTFdYCBlLmcuOiBgWzAuLjJeMjU2LTFdYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbnQyb2N0ZXRzKG51bSkge1xuICAgICAgICAoMCwgdXRpbHNfdHNfMS5hSW5SYW5nZSkoJ251bSA8IDJeJyArIG5CaXRMZW5ndGgsIG51bSwgXzBuLCBPUkRFUl9NQVNLKTtcbiAgICAgICAgLy8gd29ya3Mgd2l0aCBvcmRlciwgY2FuIGhhdmUgZGlmZmVyZW50IHNpemUgdGhhbiBudW1Ub0ZpZWxkIVxuICAgICAgICByZXR1cm4gKDAsIHV0aWxzX3RzXzEubnVtYmVyVG9CeXRlc0JFKShudW0sIG5CeXRlTGVuZ3RoKTtcbiAgICB9XG4gICAgLy8gU3RlcHMgQSwgRCBvZiBSRkM2OTc5IDMuMlxuICAgIC8vIENyZWF0ZXMgUkZDNjk3OSBzZWVkOyBjb252ZXJ0cyBtc2cvcHJpdktleSB0byBudW1iZXJzLlxuICAgIC8vIFVzZWQgb25seSBpbiBzaWduLCBub3QgaW4gdmVyaWZ5LlxuICAgIC8vIE5PVEU6IHdlIGNhbm5vdCBhc3N1bWUgaGVyZSB0aGF0IG1zZ0hhc2ggaGFzIHNhbWUgYW1vdW50IG9mIGJ5dGVzIGFzIGN1cnZlIG9yZGVyLFxuICAgIC8vIHRoaXMgd2lsbCBiZSBpbnZhbGlkIGF0IGxlYXN0IGZvciBQNTIxLiBBbHNvIGl0IGNhbiBiZSBiaWdnZXIgZm9yIFAyMjQgKyBTSEEyNTZcbiAgICBmdW5jdGlvbiBwcmVwU2lnKG1zZ0hhc2gsIHByaXZhdGVLZXksIG9wdHMgPSBkZWZhdWx0U2lnT3B0cykge1xuICAgICAgICBpZiAoWydyZWNvdmVyZWQnLCAnY2Fub25pY2FsJ10uc29tZSgoaykgPT4gayBpbiBvcHRzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2lnbigpIGxlZ2FjeSBvcHRpb25zIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgICAgY29uc3QgeyBoYXNoLCByYW5kb21CeXRlcyB9ID0gQ1VSVkU7XG4gICAgICAgIGxldCB7IGxvd1MsIHByZWhhc2gsIGV4dHJhRW50cm9weTogZW50IH0gPSBvcHRzOyAvLyBnZW5lcmF0ZXMgbG93LXMgc2lncyBieSBkZWZhdWx0XG4gICAgICAgIGlmIChsb3dTID09IG51bGwpXG4gICAgICAgICAgICBsb3dTID0gdHJ1ZTsgLy8gUkZDNjk3OSAzLjI6IHdlIHNraXAgc3RlcCBBLCBiZWNhdXNlIHdlIGFscmVhZHkgcHJvdmlkZSBoYXNoXG4gICAgICAgIG1zZ0hhc2ggPSAoMCwgdXRpbHNfdHNfMS5lbnN1cmVCeXRlcykoJ21zZ0hhc2gnLCBtc2dIYXNoKTtcbiAgICAgICAgdmFsaWRhdGVTaWdWZXJPcHRzKG9wdHMpO1xuICAgICAgICBpZiAocHJlaGFzaClcbiAgICAgICAgICAgIG1zZ0hhc2ggPSAoMCwgdXRpbHNfdHNfMS5lbnN1cmVCeXRlcykoJ3ByZWhhc2hlZCBtc2dIYXNoJywgaGFzaChtc2dIYXNoKSk7XG4gICAgICAgIC8vIFdlIGNhbid0IGxhdGVyIGNhbGwgYml0czJvY3RldHMsIHNpbmNlIG5lc3RlZCBiaXRzMmludCBpcyBicm9rZW4gZm9yIGN1cnZlc1xuICAgICAgICAvLyB3aXRoIG5CaXRMZW5ndGggJSA4ICE9PSAwLiBCZWNhdXNlIG9mIHRoYXQsIHdlIHVud3JhcCBpdCBoZXJlIGFzIGludDJvY3RldHMgY2FsbC5cbiAgICAgICAgLy8gY29uc3QgYml0czJvY3RldHMgPSAoYml0cykgPT4gaW50Mm9jdGV0cyhiaXRzMmludF9tb2ROKGJpdHMpKVxuICAgICAgICBjb25zdCBoMWludCA9IGJpdHMyaW50X21vZE4obXNnSGFzaCk7XG4gICAgICAgIGNvbnN0IGQgPSBub3JtUHJpdmF0ZUtleVRvU2NhbGFyKHByaXZhdGVLZXkpOyAvLyB2YWxpZGF0ZSBwcml2YXRlIGtleSwgY29udmVydCB0byBiaWdpbnRcbiAgICAgICAgY29uc3Qgc2VlZEFyZ3MgPSBbaW50Mm9jdGV0cyhkKSwgaW50Mm9jdGV0cyhoMWludCldO1xuICAgICAgICAvLyBleHRyYUVudHJvcHkuIFJGQzY5NzkgMy42OiBhZGRpdGlvbmFsIGsnIChvcHRpb25hbCkuXG4gICAgICAgIGlmIChlbnQgIT0gbnVsbCAmJiBlbnQgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAvLyBLID0gSE1BQ19LKFYgfHwgMHgwMCB8fCBpbnQyb2N0ZXRzKHgpIHx8IGJpdHMyb2N0ZXRzKGgxKSB8fCBrJylcbiAgICAgICAgICAgIGNvbnN0IGUgPSBlbnQgPT09IHRydWUgPyByYW5kb21CeXRlcyhGcC5CWVRFUykgOiBlbnQ7IC8vIGdlbmVyYXRlIHJhbmRvbSBieXRlcyBPUiBwYXNzIGFzLWlzXG4gICAgICAgICAgICBzZWVkQXJncy5wdXNoKCgwLCB1dGlsc190c18xLmVuc3VyZUJ5dGVzKSgnZXh0cmFFbnRyb3B5JywgZSkpOyAvLyBjaGVjayBmb3IgYmVpbmcgYnl0ZXNcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZWVkID0gKDAsIHV0aWxzX3RzXzEuY29uY2F0Qnl0ZXMpKC4uLnNlZWRBcmdzKTsgLy8gU3RlcCBEIG9mIFJGQzY5NzkgMy4yXG4gICAgICAgIGNvbnN0IG0gPSBoMWludDsgLy8gTk9URTogbm8gbmVlZCB0byBjYWxsIGJpdHMyaW50IHNlY29uZCB0aW1lIGhlcmUsIGl0IGlzIGluc2lkZSB0cnVuY2F0ZUhhc2ghXG4gICAgICAgIC8vIENvbnZlcnRzIHNpZ25hdHVyZSBwYXJhbXMgaW50byBwb2ludCB3IHIvcywgY2hlY2tzIHJlc3VsdCBmb3IgdmFsaWRpdHkuXG4gICAgICAgIGZ1bmN0aW9uIGsyc2lnKGtCeXRlcykge1xuICAgICAgICAgICAgLy8gUkZDIDY5NzkgU2VjdGlvbiAzLjIsIHN0ZXAgMzogayA9IGJpdHMyaW50KFQpXG4gICAgICAgICAgICBjb25zdCBrID0gYml0czJpbnQoa0J5dGVzKTsgLy8gQ2Fubm90IHVzZSBmaWVsZHMgbWV0aG9kcywgc2luY2UgaXQgaXMgZ3JvdXAgZWxlbWVudFxuICAgICAgICAgICAgaWYgKCFpc1dpdGhpbkN1cnZlT3JkZXIoaykpXG4gICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBJbXBvcnRhbnQ6IGFsbCBtb2QoKSBjYWxscyBoZXJlIG11c3QgYmUgZG9uZSBvdmVyIE5cbiAgICAgICAgICAgIGNvbnN0IGlrID0gaW52TihrKTsgLy8ga14tMSBtb2QgblxuICAgICAgICAgICAgY29uc3QgcSA9IFBvaW50LkJBU0UubXVsdGlwbHkoaykudG9BZmZpbmUoKTsgLy8gcSA9IEdrXG4gICAgICAgICAgICBjb25zdCByID0gbW9kTihxLngpOyAvLyByID0gcS54IG1vZCBuXG4gICAgICAgICAgICBpZiAociA9PT0gXzBuKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIC8vIENhbiB1c2Ugc2NhbGFyIGJsaW5kaW5nIGJeLTEoYm0gKyBiZHIpIHdoZXJlIGIg4oiIIFsxLHHiiJIxXSBhY2NvcmRpbmcgdG9cbiAgICAgICAgICAgIC8vIGh0dHBzOi8vdGNoZXMuaWFjci5vcmcvaW5kZXgucGhwL1RDSEVTL2FydGljbGUvdmlldy83MzM3LzY1MDkuIFdlJ3ZlIGRlY2lkZWQgYWdhaW5zdCBpdDpcbiAgICAgICAgICAgIC8vIGEpIGRlcGVuZGVuY3kgb24gQ1NQUk5HIGIpIDE1JSBzbG93ZG93biBjKSBkb2Vzbid0IHJlYWxseSBoZWxwIHNpbmNlIGJpZ2ludHMgYXJlIG5vdCBDVFxuICAgICAgICAgICAgY29uc3QgcyA9IG1vZE4oaWsgKiBtb2ROKG0gKyByICogZCkpOyAvLyBOb3QgdXNpbmcgYmxpbmRpbmcgaGVyZVxuICAgICAgICAgICAgaWYgKHMgPT09IF8wbilcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBsZXQgcmVjb3ZlcnkgPSAocS54ID09PSByID8gMCA6IDIpIHwgTnVtYmVyKHEueSAmIF8xbik7IC8vIHJlY292ZXJ5IGJpdCAoMiBvciAzLCB3aGVuIHEueCA+IG4pXG4gICAgICAgICAgICBsZXQgbm9ybVMgPSBzO1xuICAgICAgICAgICAgaWYgKGxvd1MgJiYgaXNCaWdnZXJUaGFuSGFsZk9yZGVyKHMpKSB7XG4gICAgICAgICAgICAgICAgbm9ybVMgPSBub3JtYWxpemVTKHMpOyAvLyBpZiBsb3dTIHdhcyBwYXNzZWQsIGVuc3VyZSBzIGlzIGFsd2F5c1xuICAgICAgICAgICAgICAgIHJlY292ZXJ5IF49IDE7IC8vIC8vIGluIHRoZSBib3R0b20gaGFsZiBvZiBOXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNpZ25hdHVyZShyLCBub3JtUywgcmVjb3ZlcnkpOyAvLyB1c2Ugbm9ybVMsIG5vdCBzXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgc2VlZCwgazJzaWcgfTtcbiAgICB9XG4gICAgY29uc3QgZGVmYXVsdFNpZ09wdHMgPSB7IGxvd1M6IENVUlZFLmxvd1MsIHByZWhhc2g6IGZhbHNlIH07XG4gICAgY29uc3QgZGVmYXVsdFZlck9wdHMgPSB7IGxvd1M6IENVUlZFLmxvd1MsIHByZWhhc2g6IGZhbHNlIH07XG4gICAgLyoqXG4gICAgICogU2lnbnMgbWVzc2FnZSBoYXNoIHdpdGggYSBwcml2YXRlIGtleS5cbiAgICAgKiBgYGBcbiAgICAgKiBzaWduKG0sIGQsIGspIHdoZXJlXG4gICAgICogICAoeCwgeSkgPSBHIMOXIGtcbiAgICAgKiAgIHIgPSB4IG1vZCBuXG4gICAgICogICBzID0gKG0gKyBkcikvayBtb2QgblxuICAgICAqIGBgYFxuICAgICAqIEBwYXJhbSBtc2dIYXNoIE5PVCBtZXNzYWdlLiBtc2cgbmVlZHMgdG8gYmUgaGFzaGVkIHRvIGBtc2dIYXNoYCwgb3IgdXNlIGBwcmVoYXNoYC5cbiAgICAgKiBAcGFyYW0gcHJpdktleSBwcml2YXRlIGtleVxuICAgICAqIEBwYXJhbSBvcHRzIGxvd1MgZm9yIG5vbi1tYWxsZWFibGUgc2lncy4gZXh0cmFFbnRyb3B5IGZvciBtaXhpbmcgcmFuZG9tbmVzcyBpbnRvIGsuIHByZWhhc2ggd2lsbCBoYXNoIGZpcnN0IGFyZy5cbiAgICAgKiBAcmV0dXJucyBzaWduYXR1cmUgd2l0aCByZWNvdmVyeSBwYXJhbVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNpZ24obXNnSGFzaCwgcHJpdktleSwgb3B0cyA9IGRlZmF1bHRTaWdPcHRzKSB7XG4gICAgICAgIGNvbnN0IHsgc2VlZCwgazJzaWcgfSA9IHByZXBTaWcobXNnSGFzaCwgcHJpdktleSwgb3B0cyk7IC8vIFN0ZXBzIEEsIEQgb2YgUkZDNjk3OSAzLjIuXG4gICAgICAgIGNvbnN0IEMgPSBDVVJWRTtcbiAgICAgICAgY29uc3QgZHJiZyA9ICgwLCB1dGlsc190c18xLmNyZWF0ZUhtYWNEcmJnKShDLmhhc2gub3V0cHV0TGVuLCBDLm5CeXRlTGVuZ3RoLCBDLmhtYWMpO1xuICAgICAgICByZXR1cm4gZHJiZyhzZWVkLCBrMnNpZyk7IC8vIFN0ZXBzIEIsIEMsIEQsIEUsIEYsIEdcbiAgICB9XG4gICAgLy8gRW5hYmxlIHByZWNvbXB1dGVzLiBTbG93cyBkb3duIGZpcnN0IHB1YmxpY0tleSBjb21wdXRhdGlvbiBieSAyMG1zLlxuICAgIFBvaW50LkJBU0UuX3NldFdpbmRvd1NpemUoOCk7XG4gICAgLy8gdXRpbHMucHJlY29tcHV0ZSg4LCBQcm9qZWN0aXZlUG9pbnQuQkFTRSlcbiAgICAvKipcbiAgICAgKiBWZXJpZmllcyBhIHNpZ25hdHVyZSBhZ2FpbnN0IG1lc3NhZ2UgaGFzaCBhbmQgcHVibGljIGtleS5cbiAgICAgKiBSZWplY3RzIGxvd1Mgc2lnbmF0dXJlcyBieSBkZWZhdWx0OiB0byBvdmVycmlkZSxcbiAgICAgKiBzcGVjaWZ5IG9wdGlvbiBge2xvd1M6IGZhbHNlfWAuIEltcGxlbWVudHMgc2VjdGlvbiA0LjEuNCBmcm9tIGh0dHBzOi8vd3d3LnNlY2cub3JnL3NlYzEtdjIucGRmOlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogdmVyaWZ5KHIsIHMsIGgsIFApIHdoZXJlXG4gICAgICogICBVMSA9IGhzXi0xIG1vZCBuXG4gICAgICogICBVMiA9IHJzXi0xIG1vZCBuXG4gICAgICogICBSID0gVTHii4VHIC0gVTLii4VQXG4gICAgICogICBtb2QoUi54LCBuKSA9PSByXG4gICAgICogYGBgXG4gICAgICovXG4gICAgZnVuY3Rpb24gdmVyaWZ5KHNpZ25hdHVyZSwgbXNnSGFzaCwgcHVibGljS2V5LCBvcHRzID0gZGVmYXVsdFZlck9wdHMpIHtcbiAgICAgICAgY29uc3Qgc2cgPSBzaWduYXR1cmU7XG4gICAgICAgIG1zZ0hhc2ggPSAoMCwgdXRpbHNfdHNfMS5lbnN1cmVCeXRlcykoJ21zZ0hhc2gnLCBtc2dIYXNoKTtcbiAgICAgICAgcHVibGljS2V5ID0gKDAsIHV0aWxzX3RzXzEuZW5zdXJlQnl0ZXMpKCdwdWJsaWNLZXknLCBwdWJsaWNLZXkpO1xuICAgICAgICBjb25zdCB7IGxvd1MsIHByZWhhc2gsIGZvcm1hdCB9ID0gb3B0cztcbiAgICAgICAgLy8gVmVyaWZ5IG9wdHMsIGRlZHVjZSBzaWduYXR1cmUgZm9ybWF0XG4gICAgICAgIHZhbGlkYXRlU2lnVmVyT3B0cyhvcHRzKTtcbiAgICAgICAgaWYgKCdzdHJpY3QnIGluIG9wdHMpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ29wdGlvbnMuc3RyaWN0IHdhcyByZW5hbWVkIHRvIGxvd1MnKTtcbiAgICAgICAgaWYgKGZvcm1hdCAhPT0gdW5kZWZpbmVkICYmIGZvcm1hdCAhPT0gJ2NvbXBhY3QnICYmIGZvcm1hdCAhPT0gJ2RlcicpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Zvcm1hdCBtdXN0IGJlIGNvbXBhY3Qgb3IgZGVyJyk7XG4gICAgICAgIGNvbnN0IGlzSGV4ID0gdHlwZW9mIHNnID09PSAnc3RyaW5nJyB8fCAoMCwgdXRpbHNfdHNfMS5pc0J5dGVzKShzZyk7XG4gICAgICAgIGNvbnN0IGlzT2JqID0gIWlzSGV4ICYmXG4gICAgICAgICAgICAhZm9ybWF0ICYmXG4gICAgICAgICAgICB0eXBlb2Ygc2cgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICBzZyAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgdHlwZW9mIHNnLnIgPT09ICdiaWdpbnQnICYmXG4gICAgICAgICAgICB0eXBlb2Ygc2cucyA9PT0gJ2JpZ2ludCc7XG4gICAgICAgIGlmICghaXNIZXggJiYgIWlzT2JqKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHNpZ25hdHVyZSwgZXhwZWN0ZWQgVWludDhBcnJheSwgaGV4IHN0cmluZyBvciBTaWduYXR1cmUgaW5zdGFuY2UnKTtcbiAgICAgICAgbGV0IF9zaWcgPSB1bmRlZmluZWQ7XG4gICAgICAgIGxldCBQO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKGlzT2JqKVxuICAgICAgICAgICAgICAgIF9zaWcgPSBuZXcgU2lnbmF0dXJlKHNnLnIsIHNnLnMpO1xuICAgICAgICAgICAgaWYgKGlzSGV4KSB7XG4gICAgICAgICAgICAgICAgLy8gU2lnbmF0dXJlIGNhbiBiZSByZXByZXNlbnRlZCBpbiAyIHdheXM6IGNvbXBhY3QgKDIqbkJ5dGVMZW5ndGgpICYgREVSICh2YXJpYWJsZS1sZW5ndGgpLlxuICAgICAgICAgICAgICAgIC8vIFNpbmNlIERFUiBjYW4gYWxzbyBiZSAyKm5CeXRlTGVuZ3RoIGJ5dGVzLCB3ZSBjaGVjayBmb3IgaXQgZmlyc3QuXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZvcm1hdCAhPT0gJ2NvbXBhY3QnKVxuICAgICAgICAgICAgICAgICAgICAgICAgX3NpZyA9IFNpZ25hdHVyZS5mcm9tREVSKHNnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGRlckVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKGRlckVycm9yIGluc3RhbmNlb2YgZXhwb3J0cy5ERVIuRXJyKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGRlckVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIV9zaWcgJiYgZm9ybWF0ICE9PSAnZGVyJylcbiAgICAgICAgICAgICAgICAgICAgX3NpZyA9IFNpZ25hdHVyZS5mcm9tQ29tcGFjdChzZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBQID0gUG9pbnQuZnJvbUhleChwdWJsaWNLZXkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghX3NpZylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGxvd1MgJiYgX3NpZy5oYXNIaWdoUygpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAocHJlaGFzaClcbiAgICAgICAgICAgIG1zZ0hhc2ggPSBDVVJWRS5oYXNoKG1zZ0hhc2gpO1xuICAgICAgICBjb25zdCB7IHIsIHMgfSA9IF9zaWc7XG4gICAgICAgIGNvbnN0IGggPSBiaXRzMmludF9tb2ROKG1zZ0hhc2gpOyAvLyBDYW5ub3QgdXNlIGZpZWxkcyBtZXRob2RzLCBzaW5jZSBpdCBpcyBncm91cCBlbGVtZW50XG4gICAgICAgIGNvbnN0IGlzID0gaW52TihzKTsgLy8gc14tMVxuICAgICAgICBjb25zdCB1MSA9IG1vZE4oaCAqIGlzKTsgLy8gdTEgPSBoc14tMSBtb2QgblxuICAgICAgICBjb25zdCB1MiA9IG1vZE4ociAqIGlzKTsgLy8gdTIgPSByc14tMSBtb2QgblxuICAgICAgICBjb25zdCBSID0gUG9pbnQuQkFTRS5tdWx0aXBseUFuZEFkZFVuc2FmZShQLCB1MSwgdTIpPy50b0FmZmluZSgpOyAvLyBSID0gdTHii4VHICsgdTLii4VQXG4gICAgICAgIGlmICghUilcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgY29uc3QgdiA9IG1vZE4oUi54KTtcbiAgICAgICAgcmV0dXJuIHYgPT09IHI7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIENVUlZFLFxuICAgICAgICBnZXRQdWJsaWNLZXksXG4gICAgICAgIGdldFNoYXJlZFNlY3JldCxcbiAgICAgICAgc2lnbixcbiAgICAgICAgdmVyaWZ5LFxuICAgICAgICBQcm9qZWN0aXZlUG9pbnQ6IFBvaW50LFxuICAgICAgICBTaWduYXR1cmUsXG4gICAgICAgIHV0aWxzLFxuICAgIH07XG59XG4vKipcbiAqIEltcGxlbWVudGF0aW9uIG9mIHRoZSBTaGFsbHVlIGFuZCB2YW4gZGUgV29lc3Rpam5lIG1ldGhvZCBmb3IgYW55IHdlaWVyc3RyYXNzIGN1cnZlLlxuICogVE9ETzogY2hlY2sgaWYgdGhlcmUgaXMgYSB3YXkgdG8gbWVyZ2UgdGhpcyB3aXRoIHV2UmF0aW8gaW4gRWR3YXJkczsgbW92ZSB0byBtb2R1bGFyLlxuICogYiA9IFRydWUgYW5kIHkgPSBzcXJ0KHUgLyB2KSBpZiAodSAvIHYpIGlzIHNxdWFyZSBpbiBGLCBhbmRcbiAqIGIgPSBGYWxzZSBhbmQgeSA9IHNxcnQoWiAqICh1IC8gdikpIG90aGVyd2lzZS5cbiAqIEBwYXJhbSBGcFxuICogQHBhcmFtIFpcbiAqIEByZXR1cm5zXG4gKi9cbmZ1bmN0aW9uIFNXVUZwU3FydFJhdGlvKEZwLCBaKSB7XG4gICAgLy8gR2VuZXJpYyBpbXBsZW1lbnRhdGlvblxuICAgIGNvbnN0IHEgPSBGcC5PUkRFUjtcbiAgICBsZXQgbCA9IF8wbjtcbiAgICBmb3IgKGxldCBvID0gcSAtIF8xbjsgbyAlIF8ybiA9PT0gXzBuOyBvIC89IF8ybilcbiAgICAgICAgbCArPSBfMW47XG4gICAgY29uc3QgYzEgPSBsOyAvLyAxLiBjMSwgdGhlIGxhcmdlc3QgaW50ZWdlciBzdWNoIHRoYXQgMl5jMSBkaXZpZGVzIHEgLSAxLlxuICAgIC8vIFdlIG5lZWQgMm4gKiogYzEgYW5kIDJuICoqIChjMS0xKS4gV2UgY2FuJ3QgdXNlICoqOyBidXQgd2UgY2FuIHVzZSA8PC5cbiAgICAvLyAybiAqKiBjMSA9PSAybiA8PCAoYzEtMSlcbiAgICBjb25zdCBfMm5fcG93X2MxXzEgPSBfMm4gPDwgKGMxIC0gXzFuIC0gXzFuKTtcbiAgICBjb25zdCBfMm5fcG93X2MxID0gXzJuX3Bvd19jMV8xICogXzJuO1xuICAgIGNvbnN0IGMyID0gKHEgLSBfMW4pIC8gXzJuX3Bvd19jMTsgLy8gMi4gYzIgPSAocSAtIDEpIC8gKDJeYzEpICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIGNvbnN0IGMzID0gKGMyIC0gXzFuKSAvIF8ybjsgLy8gMy4gYzMgPSAoYzIgLSAxKSAvIDIgICAgICAgICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIGNvbnN0IGM0ID0gXzJuX3Bvd19jMSAtIF8xbjsgLy8gNC4gYzQgPSAyXmMxIC0gMSAgICAgICAgICAgICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIGNvbnN0IGM1ID0gXzJuX3Bvd19jMV8xOyAvLyA1LiBjNSA9IDJeKGMxIC0gMSkgICAgICAgICAgICAgICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIGNvbnN0IGM2ID0gRnAucG93KFosIGMyKTsgLy8gNi4gYzYgPSBaXmMyXG4gICAgY29uc3QgYzcgPSBGcC5wb3coWiwgKGMyICsgXzFuKSAvIF8ybik7IC8vIDcuIGM3ID0gWl4oKGMyICsgMSkgLyAyKVxuICAgIGxldCBzcXJ0UmF0aW8gPSAodSwgdikgPT4ge1xuICAgICAgICBsZXQgdHYxID0gYzY7IC8vIDEuIHR2MSA9IGM2XG4gICAgICAgIGxldCB0djIgPSBGcC5wb3codiwgYzQpOyAvLyAyLiB0djIgPSB2XmM0XG4gICAgICAgIGxldCB0djMgPSBGcC5zcXIodHYyKTsgLy8gMy4gdHYzID0gdHYyXjJcbiAgICAgICAgdHYzID0gRnAubXVsKHR2Mywgdik7IC8vIDQuIHR2MyA9IHR2MyAqIHZcbiAgICAgICAgbGV0IHR2NSA9IEZwLm11bCh1LCB0djMpOyAvLyA1LiB0djUgPSB1ICogdHYzXG4gICAgICAgIHR2NSA9IEZwLnBvdyh0djUsIGMzKTsgLy8gNi4gdHY1ID0gdHY1XmMzXG4gICAgICAgIHR2NSA9IEZwLm11bCh0djUsIHR2Mik7IC8vIDcuIHR2NSA9IHR2NSAqIHR2MlxuICAgICAgICB0djIgPSBGcC5tdWwodHY1LCB2KTsgLy8gOC4gdHYyID0gdHY1ICogdlxuICAgICAgICB0djMgPSBGcC5tdWwodHY1LCB1KTsgLy8gOS4gdHYzID0gdHY1ICogdVxuICAgICAgICBsZXQgdHY0ID0gRnAubXVsKHR2MywgdHYyKTsgLy8gMTAuIHR2NCA9IHR2MyAqIHR2MlxuICAgICAgICB0djUgPSBGcC5wb3codHY0LCBjNSk7IC8vIDExLiB0djUgPSB0djReYzVcbiAgICAgICAgbGV0IGlzUVIgPSBGcC5lcWwodHY1LCBGcC5PTkUpOyAvLyAxMi4gaXNRUiA9IHR2NSA9PSAxXG4gICAgICAgIHR2MiA9IEZwLm11bCh0djMsIGM3KTsgLy8gMTMuIHR2MiA9IHR2MyAqIGM3XG4gICAgICAgIHR2NSA9IEZwLm11bCh0djQsIHR2MSk7IC8vIDE0LiB0djUgPSB0djQgKiB0djFcbiAgICAgICAgdHYzID0gRnAuY21vdih0djIsIHR2MywgaXNRUik7IC8vIDE1LiB0djMgPSBDTU9WKHR2MiwgdHYzLCBpc1FSKVxuICAgICAgICB0djQgPSBGcC5jbW92KHR2NSwgdHY0LCBpc1FSKTsgLy8gMTYuIHR2NCA9IENNT1YodHY1LCB0djQsIGlzUVIpXG4gICAgICAgIC8vIDE3LiBmb3IgaSBpbiAoYzEsIGMxIC0gMSwgLi4uLCAyKTpcbiAgICAgICAgZm9yIChsZXQgaSA9IGMxOyBpID4gXzFuOyBpLS0pIHtcbiAgICAgICAgICAgIGxldCB0djUgPSBpIC0gXzJuOyAvLyAxOC4gICAgdHY1ID0gaSAtIDJcbiAgICAgICAgICAgIHR2NSA9IF8ybiA8PCAodHY1IC0gXzFuKTsgLy8gMTkuICAgIHR2NSA9IDJedHY1XG4gICAgICAgICAgICBsZXQgdHZ2NSA9IEZwLnBvdyh0djQsIHR2NSk7IC8vIDIwLiAgICB0djUgPSB0djRedHY1XG4gICAgICAgICAgICBjb25zdCBlMSA9IEZwLmVxbCh0dnY1LCBGcC5PTkUpOyAvLyAyMS4gICAgZTEgPSB0djUgPT0gMVxuICAgICAgICAgICAgdHYyID0gRnAubXVsKHR2MywgdHYxKTsgLy8gMjIuICAgIHR2MiA9IHR2MyAqIHR2MVxuICAgICAgICAgICAgdHYxID0gRnAubXVsKHR2MSwgdHYxKTsgLy8gMjMuICAgIHR2MSA9IHR2MSAqIHR2MVxuICAgICAgICAgICAgdHZ2NSA9IEZwLm11bCh0djQsIHR2MSk7IC8vIDI0LiAgICB0djUgPSB0djQgKiB0djFcbiAgICAgICAgICAgIHR2MyA9IEZwLmNtb3YodHYyLCB0djMsIGUxKTsgLy8gMjUuICAgIHR2MyA9IENNT1YodHYyLCB0djMsIGUxKVxuICAgICAgICAgICAgdHY0ID0gRnAuY21vdih0dnY1LCB0djQsIGUxKTsgLy8gMjYuICAgIHR2NCA9IENNT1YodHY1LCB0djQsIGUxKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGlzVmFsaWQ6IGlzUVIsIHZhbHVlOiB0djMgfTtcbiAgICB9O1xuICAgIGlmIChGcC5PUkRFUiAlIF80biA9PT0gXzNuKSB7XG4gICAgICAgIC8vIHNxcnRfcmF0aW9fM21vZDQodSwgdilcbiAgICAgICAgY29uc3QgYzEgPSAoRnAuT1JERVIgLSBfM24pIC8gXzRuOyAvLyAxLiBjMSA9IChxIC0gMykgLyA0ICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgICAgICBjb25zdCBjMiA9IEZwLnNxcnQoRnAubmVnKFopKTsgLy8gMi4gYzIgPSBzcXJ0KC1aKVxuICAgICAgICBzcXJ0UmF0aW8gPSAodSwgdikgPT4ge1xuICAgICAgICAgICAgbGV0IHR2MSA9IEZwLnNxcih2KTsgLy8gMS4gdHYxID0gdl4yXG4gICAgICAgICAgICBjb25zdCB0djIgPSBGcC5tdWwodSwgdik7IC8vIDIuIHR2MiA9IHUgKiB2XG4gICAgICAgICAgICB0djEgPSBGcC5tdWwodHYxLCB0djIpOyAvLyAzLiB0djEgPSB0djEgKiB0djJcbiAgICAgICAgICAgIGxldCB5MSA9IEZwLnBvdyh0djEsIGMxKTsgLy8gNC4geTEgPSB0djFeYzFcbiAgICAgICAgICAgIHkxID0gRnAubXVsKHkxLCB0djIpOyAvLyA1LiB5MSA9IHkxICogdHYyXG4gICAgICAgICAgICBjb25zdCB5MiA9IEZwLm11bCh5MSwgYzIpOyAvLyA2LiB5MiA9IHkxICogYzJcbiAgICAgICAgICAgIGNvbnN0IHR2MyA9IEZwLm11bChGcC5zcXIoeTEpLCB2KTsgLy8gNy4gdHYzID0geTFeMjsgOC4gdHYzID0gdHYzICogdlxuICAgICAgICAgICAgY29uc3QgaXNRUiA9IEZwLmVxbCh0djMsIHUpOyAvLyA5LiBpc1FSID0gdHYzID09IHVcbiAgICAgICAgICAgIGxldCB5ID0gRnAuY21vdih5MiwgeTEsIGlzUVIpOyAvLyAxMC4geSA9IENNT1YoeTIsIHkxLCBpc1FSKVxuICAgICAgICAgICAgcmV0dXJuIHsgaXNWYWxpZDogaXNRUiwgdmFsdWU6IHkgfTsgLy8gMTEuIHJldHVybiAoaXNRUiwgeSkgaXNRUiA/IHkgOiB5KmMyXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIE5vIGN1cnZlcyB1c2VzIHRoYXRcbiAgICAvLyBpZiAoRnAuT1JERVIgJSBfOG4gPT09IF81bikgLy8gc3FydF9yYXRpb181bW9kOFxuICAgIHJldHVybiBzcXJ0UmF0aW87XG59XG4vKipcbiAqIFNpbXBsaWZpZWQgU2hhbGx1ZS12YW4gZGUgV29lc3Rpam5lLVVsYXMgTWV0aG9kXG4gKiBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTYuNi4yXG4gKi9cbmZ1bmN0aW9uIG1hcFRvQ3VydmVTaW1wbGVTV1UoRnAsIG9wdHMpIHtcbiAgICAoMCwgbW9kdWxhcl90c18xLnZhbGlkYXRlRmllbGQpKEZwKTtcbiAgICBpZiAoIUZwLmlzVmFsaWQob3B0cy5BKSB8fCAhRnAuaXNWYWxpZChvcHRzLkIpIHx8ICFGcC5pc1ZhbGlkKG9wdHMuWikpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbWFwVG9DdXJ2ZVNpbXBsZVNXVTogaW52YWxpZCBvcHRzJyk7XG4gICAgY29uc3Qgc3FydFJhdGlvID0gU1dVRnBTcXJ0UmF0aW8oRnAsIG9wdHMuWik7XG4gICAgaWYgKCFGcC5pc09kZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGcC5pc09kZCBpcyBub3QgaW1wbGVtZW50ZWQhJyk7XG4gICAgLy8gSW5wdXQ6IHUsIGFuIGVsZW1lbnQgb2YgRi5cbiAgICAvLyBPdXRwdXQ6ICh4LCB5KSwgYSBwb2ludCBvbiBFLlxuICAgIHJldHVybiAodSkgPT4ge1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgbGV0IHR2MSwgdHYyLCB0djMsIHR2NCwgdHY1LCB0djYsIHgsIHk7XG4gICAgICAgIHR2MSA9IEZwLnNxcih1KTsgLy8gMS4gIHR2MSA9IHVeMlxuICAgICAgICB0djEgPSBGcC5tdWwodHYxLCBvcHRzLlopOyAvLyAyLiAgdHYxID0gWiAqIHR2MVxuICAgICAgICB0djIgPSBGcC5zcXIodHYxKTsgLy8gMy4gIHR2MiA9IHR2MV4yXG4gICAgICAgIHR2MiA9IEZwLmFkZCh0djIsIHR2MSk7IC8vIDQuICB0djIgPSB0djIgKyB0djFcbiAgICAgICAgdHYzID0gRnAuYWRkKHR2MiwgRnAuT05FKTsgLy8gNS4gIHR2MyA9IHR2MiArIDFcbiAgICAgICAgdHYzID0gRnAubXVsKHR2Mywgb3B0cy5CKTsgLy8gNi4gIHR2MyA9IEIgKiB0djNcbiAgICAgICAgdHY0ID0gRnAuY21vdihvcHRzLlosIEZwLm5lZyh0djIpLCAhRnAuZXFsKHR2MiwgRnAuWkVSTykpOyAvLyA3LiAgdHY0ID0gQ01PVihaLCAtdHYyLCB0djIgIT0gMClcbiAgICAgICAgdHY0ID0gRnAubXVsKHR2NCwgb3B0cy5BKTsgLy8gOC4gIHR2NCA9IEEgKiB0djRcbiAgICAgICAgdHYyID0gRnAuc3FyKHR2Myk7IC8vIDkuICB0djIgPSB0djNeMlxuICAgICAgICB0djYgPSBGcC5zcXIodHY0KTsgLy8gMTAuIHR2NiA9IHR2NF4yXG4gICAgICAgIHR2NSA9IEZwLm11bCh0djYsIG9wdHMuQSk7IC8vIDExLiB0djUgPSBBICogdHY2XG4gICAgICAgIHR2MiA9IEZwLmFkZCh0djIsIHR2NSk7IC8vIDEyLiB0djIgPSB0djIgKyB0djVcbiAgICAgICAgdHYyID0gRnAubXVsKHR2MiwgdHYzKTsgLy8gMTMuIHR2MiA9IHR2MiAqIHR2M1xuICAgICAgICB0djYgPSBGcC5tdWwodHY2LCB0djQpOyAvLyAxNC4gdHY2ID0gdHY2ICogdHY0XG4gICAgICAgIHR2NSA9IEZwLm11bCh0djYsIG9wdHMuQik7IC8vIDE1LiB0djUgPSBCICogdHY2XG4gICAgICAgIHR2MiA9IEZwLmFkZCh0djIsIHR2NSk7IC8vIDE2LiB0djIgPSB0djIgKyB0djVcbiAgICAgICAgeCA9IEZwLm11bCh0djEsIHR2Myk7IC8vIDE3LiAgIHggPSB0djEgKiB0djNcbiAgICAgICAgY29uc3QgeyBpc1ZhbGlkLCB2YWx1ZSB9ID0gc3FydFJhdGlvKHR2MiwgdHY2KTsgLy8gMTguIChpc19neDFfc3F1YXJlLCB5MSkgPSBzcXJ0X3JhdGlvKHR2MiwgdHY2KVxuICAgICAgICB5ID0gRnAubXVsKHR2MSwgdSk7IC8vIDE5LiAgIHkgPSB0djEgKiB1ICAtPiBaICogdV4zICogeTFcbiAgICAgICAgeSA9IEZwLm11bCh5LCB2YWx1ZSk7IC8vIDIwLiAgIHkgPSB5ICogeTFcbiAgICAgICAgeCA9IEZwLmNtb3YoeCwgdHYzLCBpc1ZhbGlkKTsgLy8gMjEuICAgeCA9IENNT1YoeCwgdHYzLCBpc19neDFfc3F1YXJlKVxuICAgICAgICB5ID0gRnAuY21vdih5LCB2YWx1ZSwgaXNWYWxpZCk7IC8vIDIyLiAgIHkgPSBDTU9WKHksIHkxLCBpc19neDFfc3F1YXJlKVxuICAgICAgICBjb25zdCBlMSA9IEZwLmlzT2RkKHUpID09PSBGcC5pc09kZCh5KTsgLy8gMjMuICBlMSA9IHNnbjAodSkgPT0gc2duMCh5KVxuICAgICAgICB5ID0gRnAuY21vdihGcC5uZWcoeSksIHksIGUxKTsgLy8gMjQuICAgeSA9IENNT1YoLXksIHksIGUxKVxuICAgICAgICBjb25zdCB0djRfaW52ID0gKDAsIG1vZHVsYXJfdHNfMS5GcEludmVydEJhdGNoKShGcCwgW3R2NF0sIHRydWUpWzBdO1xuICAgICAgICB4ID0gRnAubXVsKHgsIHR2NF9pbnYpOyAvLyAyNS4gICB4ID0geCAvIHR2NFxuICAgICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdlaWVyc3RyYXNzLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkRFUiIsIkRFUkVyciIsIndlaWVyc3RyYXNzUG9pbnRzIiwid2VpZXJzdHJhc3MiLCJTV1VGcFNxcnRSYXRpbyIsIm1hcFRvQ3VydmVTaW1wbGVTV1UiLCJjdXJ2ZV90c18xIiwicmVxdWlyZSIsIm1vZHVsYXJfdHNfMSIsInV0aWxzX3RzXzEiLCJ2YWxpZGF0ZVNpZ1Zlck9wdHMiLCJvcHRzIiwibG93UyIsInVuZGVmaW5lZCIsImFib29sIiwicHJlaGFzaCIsInZhbGlkYXRlUG9pbnRPcHRzIiwiY3VydmUiLCJ2YWxpZGF0ZUJhc2ljIiwidmFsaWRhdGVPYmplY3QiLCJhIiwiYiIsImFsbG93SW5maW5pdHlQb2ludCIsImFsbG93ZWRQcml2YXRlS2V5TGVuZ3RocyIsImNsZWFyQ29mYWN0b3IiLCJmcm9tQnl0ZXMiLCJpc1RvcnNpb25GcmVlIiwidG9CeXRlcyIsIndyYXBQcml2YXRlS2V5IiwiZW5kbyIsIkZwIiwiZXFsIiwiWkVSTyIsIkVycm9yIiwiYmV0YSIsInNwbGl0U2NhbGFyIiwiZnJlZXplIiwiY29uc3RydWN0b3IiLCJtIiwiRXJyIiwiX3RsdiIsImVuY29kZSIsInRhZyIsImRhdGEiLCJFIiwibGVuZ3RoIiwiZGF0YUxlbiIsImxlbiIsIm51bWJlclRvSGV4VW5wYWRkZWQiLCJsZW5MZW4iLCJ0IiwiZGVjb2RlIiwicG9zIiwiZmlyc3QiLCJpc0xvbmciLCJsZW5ndGhCeXRlcyIsInN1YmFycmF5IiwidiIsImwiLCJfaW50IiwibnVtIiwiXzBuIiwiaGV4IiwiTnVtYmVyIiwicGFyc2VJbnQiLCJieXRlc1RvTnVtYmVyQkUiLCJ0b1NpZyIsImludCIsInRsdiIsImVuc3VyZUJ5dGVzIiwic2VxQnl0ZXMiLCJzZXFMZWZ0Qnl0ZXMiLCJyQnl0ZXMiLCJyTGVmdEJ5dGVzIiwic0J5dGVzIiwic0xlZnRCeXRlcyIsInIiLCJzIiwiaGV4RnJvbVNpZyIsInNpZyIsInJzIiwic3MiLCJzZXEiLCJudW1Ub1NpemVkSGV4Iiwic2l6ZSIsImJ5dGVzVG9IZXgiLCJudW1iZXJUb0J5dGVzQkUiLCJCaWdJbnQiLCJfMW4iLCJfMm4iLCJfM24iLCJfNG4iLCJDVVJWRSIsIkZuIiwiRmllbGQiLCJuIiwibkJpdExlbmd0aCIsIl9jIiwicG9pbnQiLCJfaXNDb21wcmVzc2VkIiwidG9BZmZpbmUiLCJjb25jYXRCeXRlcyIsIlVpbnQ4QXJyYXkiLCJmcm9tIiwieCIsInkiLCJieXRlcyIsInRhaWwiLCJCWVRFUyIsIndlaWVyc3RyYXNzRXF1YXRpb24iLCJ4MiIsInNxciIsIngzIiwibXVsIiwiYWRkIiwiaXNWYWxpZFhZIiwibGVmdCIsInJpZ2h0IiwiR3giLCJHeSIsIl80YTMiLCJwb3ciLCJfMjdiMiIsImlzMCIsImlzV2l0aGluQ3VydmVPcmRlciIsImluUmFuZ2UiLCJub3JtUHJpdmF0ZUtleVRvU2NhbGFyIiwia2V5IiwibGVuZ3RocyIsIm5CeXRlTGVuZ3RoIiwiTiIsImlzQnl0ZXMiLCJpbmNsdWRlcyIsInBhZFN0YXJ0IiwiZXJyb3IiLCJtb2QiLCJhSW5SYW5nZSIsImFwcmpwb2ludCIsIm90aGVyIiwiUG9pbnQiLCJ0b0FmZmluZU1lbW8iLCJtZW1vaXplZCIsInAiLCJpeiIsInB4IiwicHkiLCJweiIsInoiLCJPTkUiLCJpbnYiLCJheCIsImF5IiwienoiLCJhc3NlcnRWYWxpZE1lbW8iLCJpc1ZhbGlkIiwiZnJvbUFmZmluZSIsImkiLCJub3JtYWxpemVaIiwicG9pbnRzIiwidG9JbnYiLCJGcEludmVydEJhdGNoIiwibWFwIiwiZnJvbUhleCIsIlAiLCJhc3NlcnRWYWxpZGl0eSIsImZyb21Qcml2YXRlS2V5IiwicHJpdmF0ZUtleSIsIkJBU0UiLCJtdWx0aXBseSIsIm1zbSIsInNjYWxhcnMiLCJwaXBwZW5nZXIiLCJfc2V0V2luZG93U2l6ZSIsIndpbmRvd1NpemUiLCJ3bmFmIiwic2V0V2luZG93U2l6ZSIsImhhc0V2ZW5ZIiwiaXNPZGQiLCJlcXVhbHMiLCJYMSIsIlkxIiwiWjEiLCJYMiIsIlkyIiwiWjIiLCJVMSIsIlUyIiwibmVnYXRlIiwibmVnIiwiZG91YmxlIiwiYjMiLCJYMyIsIlkzIiwiWjMiLCJ0MCIsInQxIiwidDIiLCJ0MyIsInN1YiIsInQ0IiwidDUiLCJzdWJ0cmFjdCIsIndOQUYiLCJ3TkFGQ2FjaGVkIiwibXVsdGlwbHlVbnNhZmUiLCJzYyIsIkkiLCJoYXNQcmVjb21wdXRlcyIsIndOQUZDYWNoZWRVbnNhZmUiLCJrMW5lZyIsImsxIiwiazJuZWciLCJrMiIsImsxcCIsImsycCIsImQiLCJzY2FsYXIiLCJmYWtlIiwiZiIsImYxcCIsImYycCIsImNvbnN0VGltZU5lZ2F0ZSIsIm11bHRpcGx5QW5kQWRkVW5zYWZlIiwiUSIsIkciLCJzdW0iLCJoIiwiY29mYWN0b3IiLCJ0b1Jhd0J5dGVzIiwiaXNDb21wcmVzc2VkIiwidG9IZXgiLCJNYXRoIiwiY2VpbCIsIlByb2plY3RpdmVQb2ludCIsInZhbGlkYXRlT3B0cyIsImhhc2giLCJobWFjIiwicmFuZG9tQnl0ZXMiLCJiaXRzMmludCIsImJpdHMyaW50X21vZE4iLCJjdXJ2ZURlZiIsIkNVUlZFX09SREVSIiwiY29tcHJlc3NlZExlbiIsInVuY29tcHJlc3NlZExlbiIsIm1vZE4iLCJpbnZOIiwiaW52ZXJ0IiwiY2F0IiwiaGVhZCIsIk9SREVSIiwieTIiLCJzcXJ0Iiwic3FydEVycm9yIiwic3VmZml4IiwibWVzc2FnZSIsImlzWU9kZCIsImlzSGVhZE9kZCIsImNsIiwidWwiLCJpc0JpZ2dlclRoYW5IYWxmT3JkZXIiLCJudW1iZXIiLCJIQUxGIiwibm9ybWFsaXplUyIsInNsY051bSIsInRvIiwic2xpY2UiLCJTaWduYXR1cmUiLCJyZWNvdmVyeSIsImZyb21Db21wYWN0IiwiZnJvbURFUiIsImFkZFJlY292ZXJ5Qml0IiwicmVjb3ZlclB1YmxpY0tleSIsIm1zZ0hhc2giLCJyZWMiLCJyYWRqIiwicHJlZml4IiwiUiIsImlyIiwidTEiLCJ1MiIsImhhc0hpZ2hTIiwidG9ERVJSYXdCeXRlcyIsImhleFRvQnl0ZXMiLCJ0b0RFUkhleCIsInRvQ29tcGFjdFJhd0J5dGVzIiwidG9Db21wYWN0SGV4IiwidXRpbHMiLCJpc1ZhbGlkUHJpdmF0ZUtleSIsInJhbmRvbVByaXZhdGVLZXkiLCJnZXRNaW5IYXNoTGVuZ3RoIiwibWFwSGFzaFRvRmllbGQiLCJwcmVjb21wdXRlIiwiZ2V0UHVibGljS2V5IiwiaXNQcm9iUHViIiwiaXRlbSIsImFyciIsImZwbCIsImNvbXBMZW4iLCJ1bmNvbXBMZW4iLCJnZXRTaGFyZWRTZWNyZXQiLCJwcml2YXRlQSIsInB1YmxpY0IiLCJkZWx0YSIsIk9SREVSX01BU0siLCJiaXRNYXNrIiwiaW50Mm9jdGV0cyIsInByZXBTaWciLCJkZWZhdWx0U2lnT3B0cyIsInNvbWUiLCJrIiwiZXh0cmFFbnRyb3B5IiwiZW50IiwiaDFpbnQiLCJzZWVkQXJncyIsImUiLCJwdXNoIiwic2VlZCIsImsyc2lnIiwia0J5dGVzIiwiaWsiLCJxIiwibm9ybVMiLCJkZWZhdWx0VmVyT3B0cyIsInNpZ24iLCJwcml2S2V5IiwiQyIsImRyYmciLCJjcmVhdGVIbWFjRHJiZyIsIm91dHB1dExlbiIsInZlcmlmeSIsInNpZ25hdHVyZSIsInB1YmxpY0tleSIsInNnIiwiZm9ybWF0IiwiaXNIZXgiLCJpc09iaiIsIl9zaWciLCJkZXJFcnJvciIsImlzIiwiWiIsIm8iLCJjMSIsIl8ybl9wb3dfYzFfMSIsIl8ybl9wb3dfYzEiLCJjMiIsImMzIiwiYzQiLCJjNSIsImM2IiwiYzciLCJzcXJ0UmF0aW8iLCJ1IiwidHYxIiwidHYyIiwidHYzIiwidHY1IiwidHY0IiwiaXNRUiIsImNtb3YiLCJ0dnY1IiwiZTEiLCJ5MSIsInZhbGlkYXRlRmllbGQiLCJBIiwiQiIsInR2NiIsInR2NF9pbnYiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@noble/curves/abstract/weierstrass.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@noble/curves/secp256k1.js":
/*!*************************************************!*\
  !*** ./node_modules/@noble/curves/secp256k1.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.encodeToCurve = exports.hashToCurve = exports.secp256k1_hasher = exports.schnorr = exports.secp256k1 = void 0;\n/**\n * NIST secp256k1. See [pdf](https://www.secg.org/sec2-v2.pdf).\n *\n * Seems to be rigid (not backdoored)\n * [as per discussion](https://bitcointalk.org/index.php?topic=289795.msg3183975#msg3183975).\n *\n * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.\n * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.\n * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.\n * [See explanation](https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066).\n * @module\n */ /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const sha2_1 = __webpack_require__(/*! @noble/hashes/sha2 */ \"(rsc)/./node_modules/@noble/hashes/sha2.js\");\nconst utils_1 = __webpack_require__(/*! @noble/hashes/utils */ \"(rsc)/./node_modules/@noble/hashes/utils.js\");\nconst _shortw_utils_ts_1 = __webpack_require__(/*! ./_shortw_utils.js */ \"(rsc)/./node_modules/@noble/curves/_shortw_utils.js\");\nconst hash_to_curve_ts_1 = __webpack_require__(/*! ./abstract/hash-to-curve.js */ \"(rsc)/./node_modules/@noble/curves/abstract/hash-to-curve.js\");\nconst modular_ts_1 = __webpack_require__(/*! ./abstract/modular.js */ \"(rsc)/./node_modules/@noble/curves/abstract/modular.js\");\nconst utils_ts_1 = __webpack_require__(/*! ./abstract/utils.js */ \"(rsc)/./node_modules/@noble/curves/abstract/utils.js\");\nconst weierstrass_ts_1 = __webpack_require__(/*! ./abstract/weierstrass.js */ \"(rsc)/./node_modules/@noble/curves/abstract/weierstrass.js\");\nconst secp256k1P = BigInt(\"0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f\");\nconst secp256k1N = BigInt(\"0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\");\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst divNearest = (a, b)=>(a + b / _2n) / b;\n/**\n * ‚àön = n^((p+1)/4) for fields p = 3 mod 4. We unwrap the loop and multiply bit-by-bit.\n * (P+1n/4n).toString(2) would produce bits [223x 1, 0, 22x 1, 4x 0, 11, 00]\n */ function sqrtMod(y) {\n    const P = secp256k1P;\n    // prettier-ignore\n    const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);\n    // prettier-ignore\n    const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);\n    const b2 = y * y * y % P; // x^3, 11\n    const b3 = b2 * b2 * y % P; // x^7\n    const b6 = (0, modular_ts_1.pow2)(b3, _3n, P) * b3 % P;\n    const b9 = (0, modular_ts_1.pow2)(b6, _3n, P) * b3 % P;\n    const b11 = (0, modular_ts_1.pow2)(b9, _2n, P) * b2 % P;\n    const b22 = (0, modular_ts_1.pow2)(b11, _11n, P) * b11 % P;\n    const b44 = (0, modular_ts_1.pow2)(b22, _22n, P) * b22 % P;\n    const b88 = (0, modular_ts_1.pow2)(b44, _44n, P) * b44 % P;\n    const b176 = (0, modular_ts_1.pow2)(b88, _88n, P) * b88 % P;\n    const b220 = (0, modular_ts_1.pow2)(b176, _44n, P) * b44 % P;\n    const b223 = (0, modular_ts_1.pow2)(b220, _3n, P) * b3 % P;\n    const t1 = (0, modular_ts_1.pow2)(b223, _23n, P) * b22 % P;\n    const t2 = (0, modular_ts_1.pow2)(t1, _6n, P) * b2 % P;\n    const root = (0, modular_ts_1.pow2)(t2, _2n, P);\n    if (!Fpk1.eql(Fpk1.sqr(root), y)) throw new Error(\"Cannot find square root\");\n    return root;\n}\nconst Fpk1 = (0, modular_ts_1.Field)(secp256k1P, undefined, undefined, {\n    sqrt: sqrtMod\n});\n/**\n * secp256k1 curve, ECDSA and ECDH methods.\n *\n * Field: `2n**256n - 2n**32n - 2n**9n - 2n**8n - 2n**7n - 2n**6n - 2n**4n - 1n`\n *\n * @example\n * ```js\n * import { secp256k1 } from '@noble/curves/secp256k1';\n * const priv = secp256k1.utils.randomPrivateKey();\n * const pub = secp256k1.getPublicKey(priv);\n * const msg = new Uint8Array(32).fill(1); // message hash (not message) in ecdsa\n * const sig = secp256k1.sign(msg, priv); // `{prehash: true}` option is available\n * const isValid = secp256k1.verify(sig, msg, pub) === true;\n * ```\n */ exports.secp256k1 = (0, _shortw_utils_ts_1.createCurve)({\n    a: _0n,\n    b: BigInt(7),\n    Fp: Fpk1,\n    n: secp256k1N,\n    Gx: BigInt(\"55066263022277343669578718895168534326250603453777594175500187360389116729240\"),\n    Gy: BigInt(\"32670510020758816978083085130507043184471273380659243275938904335757337482424\"),\n    h: BigInt(1),\n    lowS: true,\n    endo: {\n        // Endomorphism, see above\n        beta: BigInt(\"0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\"),\n        splitScalar: (k)=>{\n            const n = secp256k1N;\n            const a1 = BigInt(\"0x3086d221a7d46bcde86c90e49284eb15\");\n            const b1 = -_1n * BigInt(\"0xe4437ed6010e88286f547fa90abfe4c3\");\n            const a2 = BigInt(\"0x114ca50f7a8e2f3f657c1108d9d44cfd8\");\n            const b2 = a1;\n            const POW_2_128 = BigInt(\"0x100000000000000000000000000000000\"); // (2n**128n).toString(16)\n            const c1 = divNearest(b2 * k, n);\n            const c2 = divNearest(-b1 * k, n);\n            let k1 = (0, modular_ts_1.mod)(k - c1 * a1 - c2 * a2, n);\n            let k2 = (0, modular_ts_1.mod)(-c1 * b1 - c2 * b2, n);\n            const k1neg = k1 > POW_2_128;\n            const k2neg = k2 > POW_2_128;\n            if (k1neg) k1 = n - k1;\n            if (k2neg) k2 = n - k2;\n            if (k1 > POW_2_128 || k2 > POW_2_128) {\n                throw new Error(\"splitScalar: Endomorphism failed, k=\" + k);\n            }\n            return {\n                k1neg,\n                k1,\n                k2neg,\n                k2\n            };\n        }\n    }\n}, sha2_1.sha256);\n// Schnorr signatures are superior to ECDSA from above. Below is Schnorr-specific BIP0340 code.\n// https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\n/** An object mapping tags to their tagged hash prefix of [SHA256(tag) | SHA256(tag)] */ const TAGGED_HASH_PREFIXES = {};\nfunction taggedHash(tag, ...messages) {\n    let tagP = TAGGED_HASH_PREFIXES[tag];\n    if (tagP === undefined) {\n        const tagH = (0, sha2_1.sha256)(Uint8Array.from(tag, (c)=>c.charCodeAt(0)));\n        tagP = (0, utils_ts_1.concatBytes)(tagH, tagH);\n        TAGGED_HASH_PREFIXES[tag] = tagP;\n    }\n    return (0, sha2_1.sha256)((0, utils_ts_1.concatBytes)(tagP, ...messages));\n}\n// ECDSA compact points are 33-byte. Schnorr is 32: we strip first byte 0x02 or 0x03\nconst pointToBytes = (point)=>point.toRawBytes(true).slice(1);\nconst numTo32b = (n)=>(0, utils_ts_1.numberToBytesBE)(n, 32);\nconst modP = (x)=>(0, modular_ts_1.mod)(x, secp256k1P);\nconst modN = (x)=>(0, modular_ts_1.mod)(x, secp256k1N);\nconst Point = /* @__PURE__ */ (()=>exports.secp256k1.ProjectivePoint)();\nconst GmulAdd = (Q, a, b)=>Point.BASE.multiplyAndAddUnsafe(Q, a, b);\n// Calculate point, scalar and bytes\nfunction schnorrGetExtPubKey(priv) {\n    let d_ = exports.secp256k1.utils.normPrivateKeyToScalar(priv); // same method executed in fromPrivateKey\n    let p = Point.fromPrivateKey(d_); // P = d'‚ãÖG; 0 < d' < n check is done inside\n    const scalar = p.hasEvenY() ? d_ : modN(-d_);\n    return {\n        scalar: scalar,\n        bytes: pointToBytes(p)\n    };\n}\n/**\n * lift_x from BIP340. Convert 32-byte x coordinate to elliptic curve point.\n * @returns valid point checked for being on-curve\n */ function lift_x(x) {\n    (0, utils_ts_1.aInRange)(\"x\", x, _1n, secp256k1P); // Fail if x ‚â• p.\n    const xx = modP(x * x);\n    const c = modP(xx * x + BigInt(7)); // Let c = x¬≥ + 7 mod p.\n    let y = sqrtMod(c); // Let y = c^(p+1)/4 mod p.\n    if (y % _2n !== _0n) y = modP(-y); // Return the unique point P such that x(P) = x and\n    const p = new Point(x, y, _1n); // y(P) = y if y mod 2 = 0 or y(P) = p-y otherwise.\n    p.assertValidity();\n    return p;\n}\nconst num = utils_ts_1.bytesToNumberBE;\n/**\n * Create tagged hash, convert it to bigint, reduce modulo-n.\n */ function challenge(...args) {\n    return modN(num(taggedHash(\"BIP0340/challenge\", ...args)));\n}\n/**\n * Schnorr public key is just `x` coordinate of Point as per BIP340.\n */ function schnorrGetPublicKey(privateKey) {\n    return schnorrGetExtPubKey(privateKey).bytes; // d'=int(sk). Fail if d'=0 or d'‚â•n. Ret bytes(d'‚ãÖG)\n}\n/**\n * Creates Schnorr signature as per BIP340. Verifies itself before returning anything.\n * auxRand is optional and is not the sole source of k generation: bad CSPRNG won't be dangerous.\n */ function schnorrSign(message, privateKey, auxRand = (0, utils_1.randomBytes)(32)) {\n    const m = (0, utils_ts_1.ensureBytes)(\"message\", message);\n    const { bytes: px, scalar: d } = schnorrGetExtPubKey(privateKey); // checks for isWithinCurveOrder\n    const a = (0, utils_ts_1.ensureBytes)(\"auxRand\", auxRand, 32); // Auxiliary random data a: a 32-byte array\n    const t = numTo32b(d ^ num(taggedHash(\"BIP0340/aux\", a))); // Let t be the byte-wise xor of bytes(d) and hash/aux(a)\n    const rand = taggedHash(\"BIP0340/nonce\", t, px, m); // Let rand = hash/nonce(t || bytes(P) || m)\n    const k_ = modN(num(rand)); // Let k' = int(rand) mod n\n    if (k_ === _0n) throw new Error(\"sign failed: k is zero\"); // Fail if k' = 0.\n    const { bytes: rx, scalar: k } = schnorrGetExtPubKey(k_); // Let R = k'‚ãÖG.\n    const e = challenge(rx, px, m); // Let e = int(hash/challenge(bytes(R) || bytes(P) || m)) mod n.\n    const sig = new Uint8Array(64); // Let sig = bytes(R) || bytes((k + ed) mod n).\n    sig.set(rx, 0);\n    sig.set(numTo32b(modN(k + e * d)), 32);\n    // If Verify(bytes(P), m, sig) (see below) returns failure, abort\n    if (!schnorrVerify(sig, m, px)) throw new Error(\"sign: Invalid signature produced\");\n    return sig;\n}\n/**\n * Verifies Schnorr signature.\n * Will swallow errors & return false except for initial type validation of arguments.\n */ function schnorrVerify(signature, message, publicKey) {\n    const sig = (0, utils_ts_1.ensureBytes)(\"signature\", signature, 64);\n    const m = (0, utils_ts_1.ensureBytes)(\"message\", message);\n    const pub = (0, utils_ts_1.ensureBytes)(\"publicKey\", publicKey, 32);\n    try {\n        const P = lift_x(num(pub)); // P = lift_x(int(pk)); fail if that fails\n        const r = num(sig.subarray(0, 32)); // Let r = int(sig[0:32]); fail if r ‚â• p.\n        if (!(0, utils_ts_1.inRange)(r, _1n, secp256k1P)) return false;\n        const s = num(sig.subarray(32, 64)); // Let s = int(sig[32:64]); fail if s ‚â• n.\n        if (!(0, utils_ts_1.inRange)(s, _1n, secp256k1N)) return false;\n        const e = challenge(numTo32b(r), pointToBytes(P), m); // int(challenge(bytes(r)||bytes(P)||m))%n\n        const R = GmulAdd(P, s, modN(-e)); // R = s‚ãÖG - e‚ãÖP\n        if (!R || !R.hasEvenY() || R.toAffine().x !== r) return false; // -eP == (n-e)P\n        return true; // Fail if is_infinite(R) / not has_even_y(R) / x(R) ‚â† r.\n    } catch (error) {\n        return false;\n    }\n}\n/**\n * Schnorr signatures over secp256k1.\n * https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\n * @example\n * ```js\n * import { schnorr } from '@noble/curves/secp256k1';\n * const priv = schnorr.utils.randomPrivateKey();\n * const pub = schnorr.getPublicKey(priv);\n * const msg = new TextEncoder().encode('hello');\n * const sig = schnorr.sign(msg, priv);\n * const isValid = schnorr.verify(sig, msg, pub);\n * ```\n */ exports.schnorr = (()=>({\n        getPublicKey: schnorrGetPublicKey,\n        sign: schnorrSign,\n        verify: schnorrVerify,\n        utils: {\n            randomPrivateKey: exports.secp256k1.utils.randomPrivateKey,\n            lift_x,\n            pointToBytes,\n            numberToBytesBE: utils_ts_1.numberToBytesBE,\n            bytesToNumberBE: utils_ts_1.bytesToNumberBE,\n            taggedHash,\n            mod: modular_ts_1.mod\n        }\n    }))();\nconst isoMap = /* @__PURE__ */ (()=>(0, hash_to_curve_ts_1.isogenyMap)(Fpk1, [\n        // xNum\n        [\n            \"0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7\",\n            \"0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581\",\n            \"0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262\",\n            \"0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c\"\n        ],\n        // xDen\n        [\n            \"0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b\",\n            \"0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14\",\n            \"0x0000000000000000000000000000000000000000000000000000000000000001\"\n        ],\n        // yNum\n        [\n            \"0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c\",\n            \"0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3\",\n            \"0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931\",\n            \"0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84\"\n        ],\n        // yDen\n        [\n            \"0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b\",\n            \"0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573\",\n            \"0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f\",\n            \"0x0000000000000000000000000000000000000000000000000000000000000001\"\n        ]\n    ].map((i)=>i.map((j)=>BigInt(j)))))();\nconst mapSWU = /* @__PURE__ */ (()=>(0, weierstrass_ts_1.mapToCurveSimpleSWU)(Fpk1, {\n        A: BigInt(\"0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533\"),\n        B: BigInt(\"1771\"),\n        Z: Fpk1.create(BigInt(\"-11\"))\n    }))();\n/** Hashing / encoding to secp256k1 points / field. RFC 9380 methods. */ exports.secp256k1_hasher = (()=>(0, hash_to_curve_ts_1.createHasher)(exports.secp256k1.ProjectivePoint, (scalars)=>{\n        const { x, y } = mapSWU(Fpk1.create(scalars[0]));\n        return isoMap(x, y);\n    }, {\n        DST: \"secp256k1_XMD:SHA-256_SSWU_RO_\",\n        encodeDST: \"secp256k1_XMD:SHA-256_SSWU_NU_\",\n        p: Fpk1.ORDER,\n        m: 1,\n        k: 128,\n        expand: \"xmd\",\n        hash: sha2_1.sha256\n    }))();\nexports.hashToCurve = (()=>exports.secp256k1_hasher.hashToCurve)();\nexports.encodeToCurve = (()=>exports.secp256k1_hasher.encodeToCurve)(); //# sourceMappingURL=secp256k1.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9zZWNwMjU2azEuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELHFCQUFxQixHQUFHQSxtQkFBbUIsR0FBR0Esd0JBQXdCLEdBQUdBLGVBQWUsR0FBR0EsaUJBQWlCLEdBQUcsS0FBSztBQUNwSDs7Ozs7Ozs7Ozs7Q0FXQyxHQUNELG9FQUFvRSxHQUNwRSxNQUFNTyxTQUFTQyxtQkFBT0EsQ0FBQyxzRUFBb0I7QUFDM0MsTUFBTUMsVUFBVUQsbUJBQU9BLENBQUMsd0VBQXFCO0FBQzdDLE1BQU1FLHFCQUFxQkYsbUJBQU9BLENBQUMsK0VBQW9CO0FBQ3ZELE1BQU1HLHFCQUFxQkgsbUJBQU9BLENBQUMsaUdBQTZCO0FBQ2hFLE1BQU1JLGVBQWVKLG1CQUFPQSxDQUFDLHFGQUF1QjtBQUNwRCxNQUFNSyxhQUFhTCxtQkFBT0EsQ0FBQyxpRkFBcUI7QUFDaEQsTUFBTU0sbUJBQW1CTixtQkFBT0EsQ0FBQyw2RkFBMkI7QUFDNUQsTUFBTU8sYUFBYUMsT0FBTztBQUMxQixNQUFNQyxhQUFhRCxPQUFPO0FBQzFCLE1BQU1FLE1BQU1GLE9BQU87QUFDbkIsTUFBTUcsTUFBTUgsT0FBTztBQUNuQixNQUFNSSxNQUFNSixPQUFPO0FBQ25CLE1BQU1LLGFBQWEsQ0FBQ0MsR0FBR0MsSUFBTSxDQUFDRCxJQUFJQyxJQUFJSCxHQUFFLElBQUtHO0FBQzdDOzs7Q0FHQyxHQUNELFNBQVNDLFFBQVFDLENBQUM7SUFDZCxNQUFNQyxJQUFJWDtJQUNWLGtCQUFrQjtJQUNsQixNQUFNWSxNQUFNWCxPQUFPLElBQUlZLE1BQU1aLE9BQU8sSUFBSWEsT0FBT2IsT0FBTyxLQUFLYyxPQUFPZCxPQUFPO0lBQ3pFLGtCQUFrQjtJQUNsQixNQUFNZSxPQUFPZixPQUFPLEtBQUtnQixPQUFPaEIsT0FBTyxLQUFLaUIsT0FBT2pCLE9BQU87SUFDMUQsTUFBTWtCLEtBQUssSUFBS1QsSUFBSUEsSUFBS0MsR0FBRyxVQUFVO0lBQ3RDLE1BQU1TLEtBQUssS0FBTUQsS0FBS1QsSUFBS0MsR0FBRyxNQUFNO0lBQ3BDLE1BQU1VLEtBQUssQ0FBRSxHQUFHeEIsYUFBYXlCLElBQUksRUFBRUYsSUFBSVIsS0FBS0QsS0FBS1MsS0FBTVQ7SUFDdkQsTUFBTVksS0FBSyxDQUFFLEdBQUcxQixhQUFheUIsSUFBSSxFQUFFRCxJQUFJVCxLQUFLRCxLQUFLUyxLQUFNVDtJQUN2RCxNQUFNYSxNQUFNLENBQUUsR0FBRzNCLGFBQWF5QixJQUFJLEVBQUVDLElBQUlsQixLQUFLTSxLQUFLUSxLQUFNUjtJQUN4RCxNQUFNYyxNQUFNLENBQUUsR0FBRzVCLGFBQWF5QixJQUFJLEVBQUVFLEtBQUtWLE1BQU1ILEtBQUthLE1BQU9iO0lBQzNELE1BQU1lLE1BQU0sQ0FBRSxHQUFHN0IsYUFBYXlCLElBQUksRUFBRUcsS0FBS1YsTUFBTUosS0FBS2MsTUFBT2Q7SUFDM0QsTUFBTWdCLE1BQU0sQ0FBRSxHQUFHOUIsYUFBYXlCLElBQUksRUFBRUksS0FBS1QsTUFBTU4sS0FBS2UsTUFBT2Y7SUFDM0QsTUFBTWlCLE9BQU8sQ0FBRSxHQUFHL0IsYUFBYXlCLElBQUksRUFBRUssS0FBS1QsTUFBTVAsS0FBS2dCLE1BQU9oQjtJQUM1RCxNQUFNa0IsT0FBTyxDQUFFLEdBQUdoQyxhQUFheUIsSUFBSSxFQUFFTSxNQUFNWCxNQUFNTixLQUFLZSxNQUFPZjtJQUM3RCxNQUFNbUIsT0FBTyxDQUFFLEdBQUdqQyxhQUFheUIsSUFBSSxFQUFFTyxNQUFNakIsS0FBS0QsS0FBS1MsS0FBTVQ7SUFDM0QsTUFBTW9CLEtBQUssQ0FBRSxHQUFHbEMsYUFBYXlCLElBQUksRUFBRVEsTUFBTWQsTUFBTUwsS0FBS2MsTUFBT2Q7SUFDM0QsTUFBTXFCLEtBQUssQ0FBRSxHQUFHbkMsYUFBYXlCLElBQUksRUFBRVMsSUFBSWxCLEtBQUtGLEtBQUtRLEtBQU1SO0lBQ3ZELE1BQU1zQixPQUFPLENBQUMsR0FBR3BDLGFBQWF5QixJQUFJLEVBQUVVLElBQUkzQixLQUFLTTtJQUM3QyxJQUFJLENBQUN1QixLQUFLQyxHQUFHLENBQUNELEtBQUtFLEdBQUcsQ0FBQ0gsT0FBT3ZCLElBQzFCLE1BQU0sSUFBSTJCLE1BQU07SUFDcEIsT0FBT0o7QUFDWDtBQUNBLE1BQU1DLE9BQU8sQ0FBQyxHQUFHckMsYUFBYXlDLEtBQUssRUFBRXRDLFlBQVl1QyxXQUFXQSxXQUFXO0lBQUVDLE1BQU0vQjtBQUFRO0FBQ3ZGOzs7Ozs7Ozs7Ozs7OztDQWNDLEdBQ0R4QixpQkFBaUIsR0FBRyxDQUFDLEdBQUdVLG1CQUFtQjhDLFdBQVcsRUFBRTtJQUNwRGxDLEdBQUdKO0lBQ0hLLEdBQUdQLE9BQU87SUFDVnlDLElBQUlSO0lBQ0pTLEdBQUd6QztJQUNIMEMsSUFBSTNDLE9BQU87SUFDWDRDLElBQUk1QyxPQUFPO0lBQ1g2QyxHQUFHN0MsT0FBTztJQUNWOEMsTUFBTTtJQUNOQyxNQUFNO1FBQ0YsMEJBQTBCO1FBQzFCQyxNQUFNaEQsT0FBTztRQUNiaUQsYUFBYSxDQUFDQztZQUNWLE1BQU1SLElBQUl6QztZQUNWLE1BQU1rRCxLQUFLbkQsT0FBTztZQUNsQixNQUFNb0QsS0FBSyxDQUFDakQsTUFBTUgsT0FBTztZQUN6QixNQUFNcUQsS0FBS3JELE9BQU87WUFDbEIsTUFBTWtCLEtBQUtpQztZQUNYLE1BQU1HLFlBQVl0RCxPQUFPLHdDQUF3QywwQkFBMEI7WUFDM0YsTUFBTXVELEtBQUtsRCxXQUFXYSxLQUFLZ0MsR0FBR1I7WUFDOUIsTUFBTWMsS0FBS25ELFdBQVcsQ0FBQytDLEtBQUtGLEdBQUdSO1lBQy9CLElBQUllLEtBQUssQ0FBQyxHQUFHN0QsYUFBYThELEdBQUcsRUFBRVIsSUFBSUssS0FBS0osS0FBS0ssS0FBS0gsSUFBSVg7WUFDdEQsSUFBSWlCLEtBQUssQ0FBQyxHQUFHL0QsYUFBYThELEdBQUcsRUFBRSxDQUFDSCxLQUFLSCxLQUFLSSxLQUFLdEMsSUFBSXdCO1lBQ25ELE1BQU1rQixRQUFRSCxLQUFLSDtZQUNuQixNQUFNTyxRQUFRRixLQUFLTDtZQUNuQixJQUFJTSxPQUNBSCxLQUFLZixJQUFJZTtZQUNiLElBQUlJLE9BQ0FGLEtBQUtqQixJQUFJaUI7WUFDYixJQUFJRixLQUFLSCxhQUFhSyxLQUFLTCxXQUFXO2dCQUNsQyxNQUFNLElBQUlsQixNQUFNLHlDQUF5Q2M7WUFDN0Q7WUFDQSxPQUFPO2dCQUFFVTtnQkFBT0g7Z0JBQUlJO2dCQUFPRjtZQUFHO1FBQ2xDO0lBQ0o7QUFDSixHQUFHcEUsT0FBT3VFLE1BQU07QUFDaEIsK0ZBQStGO0FBQy9GLGlFQUFpRTtBQUNqRSxzRkFBc0YsR0FDdEYsTUFBTUMsdUJBQXVCLENBQUM7QUFDOUIsU0FBU0MsV0FBV0MsR0FBRyxFQUFFLEdBQUdDLFFBQVE7SUFDaEMsSUFBSUMsT0FBT0osb0JBQW9CLENBQUNFLElBQUk7SUFDcEMsSUFBSUUsU0FBUzdCLFdBQVc7UUFDcEIsTUFBTThCLE9BQU8sQ0FBQyxHQUFHN0UsT0FBT3VFLE1BQU0sRUFBRU8sV0FBV0MsSUFBSSxDQUFDTCxLQUFLLENBQUNNLElBQU1BLEVBQUVDLFVBQVUsQ0FBQztRQUN6RUwsT0FBTyxDQUFDLEdBQUd0RSxXQUFXNEUsV0FBVyxFQUFFTCxNQUFNQTtRQUN6Q0wsb0JBQW9CLENBQUNFLElBQUksR0FBR0U7SUFDaEM7SUFDQSxPQUFPLENBQUMsR0FBRzVFLE9BQU91RSxNQUFNLEVBQUUsQ0FBQyxHQUFHakUsV0FBVzRFLFdBQVcsRUFBRU4sU0FBU0Q7QUFDbkU7QUFDQSxvRkFBb0Y7QUFDcEYsTUFBTVEsZUFBZSxDQUFDQyxRQUFVQSxNQUFNQyxVQUFVLENBQUMsTUFBTUMsS0FBSyxDQUFDO0FBQzdELE1BQU1DLFdBQVcsQ0FBQ3BDLElBQU0sQ0FBQyxHQUFHN0MsV0FBV2tGLGVBQWUsRUFBRXJDLEdBQUc7QUFDM0QsTUFBTXNDLE9BQU8sQ0FBQ0MsSUFBTSxDQUFDLEdBQUdyRixhQUFhOEQsR0FBRyxFQUFFdUIsR0FBR2xGO0FBQzdDLE1BQU1tRixPQUFPLENBQUNELElBQU0sQ0FBQyxHQUFHckYsYUFBYThELEdBQUcsRUFBRXVCLEdBQUdoRjtBQUM3QyxNQUFNa0YsUUFBd0IsYUFBSCxHQUFJLEtBQU1uRyxRQUFRTSxTQUFTLENBQUM4RixlQUFlO0FBQ3RFLE1BQU1DLFVBQVUsQ0FBQ0MsR0FBR2hGLEdBQUdDLElBQU00RSxNQUFNSSxJQUFJLENBQUNDLG9CQUFvQixDQUFDRixHQUFHaEYsR0FBR0M7QUFDbkUsb0NBQW9DO0FBQ3BDLFNBQVNrRixvQkFBb0JDLElBQUk7SUFDN0IsSUFBSUMsS0FBSzNHLFFBQVFNLFNBQVMsQ0FBQ3NHLEtBQUssQ0FBQ0Msc0JBQXNCLENBQUNILE9BQU8seUNBQXlDO0lBQ3hHLElBQUlJLElBQUlYLE1BQU1ZLGNBQWMsQ0FBQ0osS0FBSyw0Q0FBNEM7SUFDOUUsTUFBTUssU0FBU0YsRUFBRUcsUUFBUSxLQUFLTixLQUFLVCxLQUFLLENBQUNTO0lBQ3pDLE9BQU87UUFBRUssUUFBUUE7UUFBUUUsT0FBT3hCLGFBQWFvQjtJQUFHO0FBQ3BEO0FBQ0E7OztDQUdDLEdBQ0QsU0FBU0ssT0FBT2xCLENBQUM7SUFDWixJQUFHcEYsV0FBV3VHLFFBQVEsRUFBRSxLQUFLbkIsR0FBRzlFLEtBQUtKLGFBQWEsaUJBQWlCO0lBQ3BFLE1BQU1zRyxLQUFLckIsS0FBS0MsSUFBSUE7SUFDcEIsTUFBTVYsSUFBSVMsS0FBS3FCLEtBQUtwQixJQUFJakYsT0FBTyxLQUFLLHdCQUF3QjtJQUM1RCxJQUFJUyxJQUFJRCxRQUFRK0QsSUFBSSwyQkFBMkI7SUFDL0MsSUFBSTlELElBQUlMLFFBQVFGLEtBQ1pPLElBQUl1RSxLQUFLLENBQUN2RSxJQUFJLG1EQUFtRDtJQUNyRSxNQUFNcUYsSUFBSSxJQUFJWCxNQUFNRixHQUFHeEUsR0FBR04sTUFBTSxtREFBbUQ7SUFDbkYyRixFQUFFUSxjQUFjO0lBQ2hCLE9BQU9SO0FBQ1g7QUFDQSxNQUFNUyxNQUFNMUcsV0FBVzJHLGVBQWU7QUFDdEM7O0NBRUMsR0FDRCxTQUFTQyxVQUFVLEdBQUdDLElBQUk7SUFDdEIsT0FBT3hCLEtBQUtxQixJQUFJdkMsV0FBVyx3QkFBd0IwQztBQUN2RDtBQUNBOztDQUVDLEdBQ0QsU0FBU0Msb0JBQW9CQyxVQUFVO0lBQ25DLE9BQU9uQixvQkFBb0JtQixZQUFZVixLQUFLLEVBQUUsb0RBQW9EO0FBQ3RHO0FBQ0E7OztDQUdDLEdBQ0QsU0FBU1csWUFBWUMsT0FBTyxFQUFFRixVQUFVLEVBQUVHLFVBQVUsQ0FBQyxHQUFHdEgsUUFBUXVILFdBQVcsRUFBRSxHQUFHO0lBQzVFLE1BQU1DLElBQUksQ0FBQyxHQUFHcEgsV0FBV3FILFdBQVcsRUFBRSxXQUFXSjtJQUNqRCxNQUFNLEVBQUVaLE9BQU9pQixFQUFFLEVBQUVuQixRQUFRb0IsQ0FBQyxFQUFFLEdBQUczQixvQkFBb0JtQixhQUFhLGdDQUFnQztJQUNsRyxNQUFNdEcsSUFBSSxDQUFDLEdBQUdULFdBQVdxSCxXQUFXLEVBQUUsV0FBV0gsU0FBUyxLQUFLLDJDQUEyQztJQUMxRyxNQUFNTSxJQUFJdkMsU0FBU3NDLElBQUliLElBQUl2QyxXQUFXLGVBQWUxRCxNQUFNLHlEQUF5RDtJQUNwSCxNQUFNZ0gsT0FBT3RELFdBQVcsaUJBQWlCcUQsR0FBR0YsSUFBSUYsSUFBSSw0Q0FBNEM7SUFDaEcsTUFBTU0sS0FBS3JDLEtBQUtxQixJQUFJZSxRQUFRLDJCQUEyQjtJQUN2RCxJQUFJQyxPQUFPckgsS0FDUCxNQUFNLElBQUlrQyxNQUFNLDJCQUEyQixrQkFBa0I7SUFDakUsTUFBTSxFQUFFOEQsT0FBT3NCLEVBQUUsRUFBRXhCLFFBQVE5QyxDQUFDLEVBQUUsR0FBR3VDLG9CQUFvQjhCLEtBQUssZ0JBQWdCO0lBQzFFLE1BQU1FLElBQUloQixVQUFVZSxJQUFJTCxJQUFJRixJQUFJLGdFQUFnRTtJQUNoRyxNQUFNUyxNQUFNLElBQUlyRCxXQUFXLEtBQUssK0NBQStDO0lBQy9FcUQsSUFBSUMsR0FBRyxDQUFDSCxJQUFJO0lBQ1pFLElBQUlDLEdBQUcsQ0FBQzdDLFNBQVNJLEtBQUtoQyxJQUFJdUUsSUFBSUwsS0FBSztJQUNuQyxpRUFBaUU7SUFDakUsSUFBSSxDQUFDUSxjQUFjRixLQUFLVCxHQUFHRSxLQUN2QixNQUFNLElBQUkvRSxNQUFNO0lBQ3BCLE9BQU9zRjtBQUNYO0FBQ0E7OztDQUdDLEdBQ0QsU0FBU0UsY0FBY0MsU0FBUyxFQUFFZixPQUFPLEVBQUVnQixTQUFTO0lBQ2hELE1BQU1KLE1BQU0sQ0FBQyxHQUFHN0gsV0FBV3FILFdBQVcsRUFBRSxhQUFhVyxXQUFXO0lBQ2hFLE1BQU1aLElBQUksQ0FBQyxHQUFHcEgsV0FBV3FILFdBQVcsRUFBRSxXQUFXSjtJQUNqRCxNQUFNaUIsTUFBTSxDQUFDLEdBQUdsSSxXQUFXcUgsV0FBVyxFQUFFLGFBQWFZLFdBQVc7SUFDaEUsSUFBSTtRQUNBLE1BQU1wSCxJQUFJeUYsT0FBT0ksSUFBSXdCLE9BQU8sMENBQTBDO1FBQ3RFLE1BQU1DLElBQUl6QixJQUFJbUIsSUFBSU8sUUFBUSxDQUFDLEdBQUcsTUFBTSx5Q0FBeUM7UUFDN0UsSUFBSSxDQUFDLENBQUMsR0FBR3BJLFdBQVdxSSxPQUFPLEVBQUVGLEdBQUc3SCxLQUFLSixhQUNqQyxPQUFPO1FBQ1gsTUFBTW9JLElBQUk1QixJQUFJbUIsSUFBSU8sUUFBUSxDQUFDLElBQUksTUFBTSwwQ0FBMEM7UUFDL0UsSUFBSSxDQUFDLENBQUMsR0FBR3BJLFdBQVdxSSxPQUFPLEVBQUVDLEdBQUdoSSxLQUFLRixhQUNqQyxPQUFPO1FBQ1gsTUFBTXdILElBQUloQixVQUFVM0IsU0FBU2tELElBQUl0RCxhQUFhaEUsSUFBSXVHLElBQUksMENBQTBDO1FBQ2hHLE1BQU1tQixJQUFJL0MsUUFBUTNFLEdBQUd5SCxHQUFHakQsS0FBSyxDQUFDdUMsS0FBSyxnQkFBZ0I7UUFDbkQsSUFBSSxDQUFDVyxLQUFLLENBQUNBLEVBQUVuQyxRQUFRLE1BQU1tQyxFQUFFQyxRQUFRLEdBQUdwRCxDQUFDLEtBQUsrQyxHQUMxQyxPQUFPLE9BQU8sZ0JBQWdCO1FBQ2xDLE9BQU8sTUFBTSx5REFBeUQ7SUFDMUUsRUFDQSxPQUFPTSxPQUFPO1FBQ1YsT0FBTztJQUNYO0FBQ0o7QUFDQTs7Ozs7Ozs7Ozs7O0NBWUMsR0FDRHRKLGVBQWUsR0FBRyxDQUFDLElBQU87UUFDdEJ1SixjQUFjNUI7UUFDZDZCLE1BQU0zQjtRQUNONEIsUUFBUWI7UUFDUmhDLE9BQU87WUFDSDhDLGtCQUFrQjFKLFFBQVFNLFNBQVMsQ0FBQ3NHLEtBQUssQ0FBQzhDLGdCQUFnQjtZQUMxRHZDO1lBQ0F6QjtZQUNBSyxpQkFBaUJsRixXQUFXa0YsZUFBZTtZQUMzQ3lCLGlCQUFpQjNHLFdBQVcyRyxlQUFlO1lBQzNDeEM7WUFDQU4sS0FBSzlELGFBQWE4RCxHQUFHO1FBQ3pCO0lBQ0osRUFBQztBQUNELE1BQU1pRixTQUF5QixhQUFILEdBQUksS0FBTSxDQUFDLEdBQUdoSixtQkFBbUJpSixVQUFVLEVBQUUzRyxNQUFNO1FBQzNFLE9BQU87UUFDUDtZQUNJO1lBQ0E7WUFDQTtZQUNBO1NBQ0g7UUFDRCxPQUFPO1FBQ1A7WUFDSTtZQUNBO1lBQ0E7U0FDSDtRQUNELE9BQU87UUFDUDtZQUNJO1lBQ0E7WUFDQTtZQUNBO1NBQ0g7UUFDRCxPQUFPO1FBQ1A7WUFDSTtZQUNBO1lBQ0E7WUFDQTtTQUNIO0tBQ0osQ0FBQzRHLEdBQUcsQ0FBQyxDQUFDQyxJQUFNQSxFQUFFRCxHQUFHLENBQUMsQ0FBQ0UsSUFBTS9JLE9BQU8rSSxLQUFJO0FBQ3JDLE1BQU1DLFNBQXlCLGFBQUgsR0FBSSxLQUFNLENBQUMsR0FBR2xKLGlCQUFpQm1KLG1CQUFtQixFQUFFaEgsTUFBTTtRQUNsRmlILEdBQUdsSixPQUFPO1FBQ1ZtSixHQUFHbkosT0FBTztRQUNWb0osR0FBR25ILEtBQUtvSCxNQUFNLENBQUNySixPQUFPO0lBQzFCLEVBQUM7QUFDRCxzRUFBc0UsR0FDdEVoQix3QkFBd0IsR0FBRyxDQUFDLElBQU0sQ0FBQyxHQUFHVyxtQkFBbUIySixZQUFZLEVBQUV0SyxRQUFRTSxTQUFTLENBQUM4RixlQUFlLEVBQUUsQ0FBQ21FO1FBQ3ZHLE1BQU0sRUFBRXRFLENBQUMsRUFBRXhFLENBQUMsRUFBRSxHQUFHdUksT0FBTy9HLEtBQUtvSCxNQUFNLENBQUNFLE9BQU8sQ0FBQyxFQUFFO1FBQzlDLE9BQU9aLE9BQU8xRCxHQUFHeEU7SUFDckIsR0FBRztRQUNDK0ksS0FBSztRQUNMQyxXQUFXO1FBQ1gzRCxHQUFHN0QsS0FBS3lILEtBQUs7UUFDYnpDLEdBQUc7UUFDSC9ELEdBQUc7UUFDSHlHLFFBQVE7UUFDUkMsTUFBTXJLLE9BQU91RSxNQUFNO0lBQ3ZCLEVBQUM7QUFDRDlFLG1CQUFtQixHQUFHLENBQUMsSUFBTUEsUUFBUUksZ0JBQWdCLENBQUNELFdBQVc7QUFDakVILHFCQUFxQixHQUFHLENBQUMsSUFBTUEsUUFBUUksZ0JBQWdCLENBQUNGLGFBQWEsS0FDckUscUNBQXFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZmFyY2FzdGVyc3RhdHMvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9zZWNwMjU2azEuanM/ZDBkZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZW5jb2RlVG9DdXJ2ZSA9IGV4cG9ydHMuaGFzaFRvQ3VydmUgPSBleHBvcnRzLnNlY3AyNTZrMV9oYXNoZXIgPSBleHBvcnRzLnNjaG5vcnIgPSBleHBvcnRzLnNlY3AyNTZrMSA9IHZvaWQgMDtcbi8qKlxuICogTklTVCBzZWNwMjU2azEuIFNlZSBbcGRmXShodHRwczovL3d3dy5zZWNnLm9yZy9zZWMyLXYyLnBkZikuXG4gKlxuICogU2VlbXMgdG8gYmUgcmlnaWQgKG5vdCBiYWNrZG9vcmVkKVxuICogW2FzIHBlciBkaXNjdXNzaW9uXShodHRwczovL2JpdGNvaW50YWxrLm9yZy9pbmRleC5waHA/dG9waWM9Mjg5Nzk1Lm1zZzMxODM5NzUjbXNnMzE4Mzk3NSkuXG4gKlxuICogc2VjcDI1NmsxIGJlbG9uZ3MgdG8gS29ibGl0eiBjdXJ2ZXM6IGl0IGhhcyBlZmZpY2llbnRseSBjb21wdXRhYmxlIGVuZG9tb3JwaGlzbS5cbiAqIEVuZG9tb3JwaGlzbSB1c2VzIDJ4IGxlc3MgUkFNLCBzcGVlZHMgdXAgcHJlY29tcHV0YXRpb24gYnkgMnggYW5kIEVDREggLyBrZXkgcmVjb3ZlcnkgYnkgMjAlLlxuICogRm9yIHByZWNvbXB1dGVkIHdOQUYgaXQgdHJhZGVzIG9mZiAxLzIgaW5pdCB0aW1lICYgMS8zIHJhbSBmb3IgMjAlIHBlcmYgaGl0LlxuICogW1NlZSBleHBsYW5hdGlvbl0oaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vcGF1bG1pbGxyL2ViNjcwODA2NzkzZTg0ZGY2MjhhN2M0MzRhODczMDY2KS5cbiAqIEBtb2R1bGVcbiAqL1xuLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuY29uc3Qgc2hhMl8xID0gcmVxdWlyZShcIkBub2JsZS9oYXNoZXMvc2hhMlwiKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiQG5vYmxlL2hhc2hlcy91dGlsc1wiKTtcbmNvbnN0IF9zaG9ydHdfdXRpbHNfdHNfMSA9IHJlcXVpcmUoXCIuL19zaG9ydHdfdXRpbHMuanNcIik7XG5jb25zdCBoYXNoX3RvX2N1cnZlX3RzXzEgPSByZXF1aXJlKFwiLi9hYnN0cmFjdC9oYXNoLXRvLWN1cnZlLmpzXCIpO1xuY29uc3QgbW9kdWxhcl90c18xID0gcmVxdWlyZShcIi4vYWJzdHJhY3QvbW9kdWxhci5qc1wiKTtcbmNvbnN0IHV0aWxzX3RzXzEgPSByZXF1aXJlKFwiLi9hYnN0cmFjdC91dGlscy5qc1wiKTtcbmNvbnN0IHdlaWVyc3RyYXNzX3RzXzEgPSByZXF1aXJlKFwiLi9hYnN0cmFjdC93ZWllcnN0cmFzcy5qc1wiKTtcbmNvbnN0IHNlY3AyNTZrMVAgPSBCaWdJbnQoJzB4ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmVmZmZmZmMyZicpO1xuY29uc3Qgc2VjcDI1NmsxTiA9IEJpZ0ludCgnMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZWJhYWVkY2U2YWY0OGEwM2JiZmQyNWU4Y2QwMzY0MTQxJyk7XG5jb25zdCBfMG4gPSBCaWdJbnQoMCk7XG5jb25zdCBfMW4gPSBCaWdJbnQoMSk7XG5jb25zdCBfMm4gPSBCaWdJbnQoMik7XG5jb25zdCBkaXZOZWFyZXN0ID0gKGEsIGIpID0+IChhICsgYiAvIF8ybikgLyBiO1xuLyoqXG4gKiDiiJpuID0gbl4oKHArMSkvNCkgZm9yIGZpZWxkcyBwID0gMyBtb2QgNC4gV2UgdW53cmFwIHRoZSBsb29wIGFuZCBtdWx0aXBseSBiaXQtYnktYml0LlxuICogKFArMW4vNG4pLnRvU3RyaW5nKDIpIHdvdWxkIHByb2R1Y2UgYml0cyBbMjIzeCAxLCAwLCAyMnggMSwgNHggMCwgMTEsIDAwXVxuICovXG5mdW5jdGlvbiBzcXJ0TW9kKHkpIHtcbiAgICBjb25zdCBQID0gc2VjcDI1NmsxUDtcbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBjb25zdCBfM24gPSBCaWdJbnQoMyksIF82biA9IEJpZ0ludCg2KSwgXzExbiA9IEJpZ0ludCgxMSksIF8yMm4gPSBCaWdJbnQoMjIpO1xuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIGNvbnN0IF8yM24gPSBCaWdJbnQoMjMpLCBfNDRuID0gQmlnSW50KDQ0KSwgXzg4biA9IEJpZ0ludCg4OCk7XG4gICAgY29uc3QgYjIgPSAoeSAqIHkgKiB5KSAlIFA7IC8vIHheMywgMTFcbiAgICBjb25zdCBiMyA9IChiMiAqIGIyICogeSkgJSBQOyAvLyB4XjdcbiAgICBjb25zdCBiNiA9ICgoMCwgbW9kdWxhcl90c18xLnBvdzIpKGIzLCBfM24sIFApICogYjMpICUgUDtcbiAgICBjb25zdCBiOSA9ICgoMCwgbW9kdWxhcl90c18xLnBvdzIpKGI2LCBfM24sIFApICogYjMpICUgUDtcbiAgICBjb25zdCBiMTEgPSAoKDAsIG1vZHVsYXJfdHNfMS5wb3cyKShiOSwgXzJuLCBQKSAqIGIyKSAlIFA7XG4gICAgY29uc3QgYjIyID0gKCgwLCBtb2R1bGFyX3RzXzEucG93MikoYjExLCBfMTFuLCBQKSAqIGIxMSkgJSBQO1xuICAgIGNvbnN0IGI0NCA9ICgoMCwgbW9kdWxhcl90c18xLnBvdzIpKGIyMiwgXzIybiwgUCkgKiBiMjIpICUgUDtcbiAgICBjb25zdCBiODggPSAoKDAsIG1vZHVsYXJfdHNfMS5wb3cyKShiNDQsIF80NG4sIFApICogYjQ0KSAlIFA7XG4gICAgY29uc3QgYjE3NiA9ICgoMCwgbW9kdWxhcl90c18xLnBvdzIpKGI4OCwgXzg4biwgUCkgKiBiODgpICUgUDtcbiAgICBjb25zdCBiMjIwID0gKCgwLCBtb2R1bGFyX3RzXzEucG93MikoYjE3NiwgXzQ0biwgUCkgKiBiNDQpICUgUDtcbiAgICBjb25zdCBiMjIzID0gKCgwLCBtb2R1bGFyX3RzXzEucG93MikoYjIyMCwgXzNuLCBQKSAqIGIzKSAlIFA7XG4gICAgY29uc3QgdDEgPSAoKDAsIG1vZHVsYXJfdHNfMS5wb3cyKShiMjIzLCBfMjNuLCBQKSAqIGIyMikgJSBQO1xuICAgIGNvbnN0IHQyID0gKCgwLCBtb2R1bGFyX3RzXzEucG93MikodDEsIF82biwgUCkgKiBiMikgJSBQO1xuICAgIGNvbnN0IHJvb3QgPSAoMCwgbW9kdWxhcl90c18xLnBvdzIpKHQyLCBfMm4sIFApO1xuICAgIGlmICghRnBrMS5lcWwoRnBrMS5zcXIocm9vdCksIHkpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIHNxdWFyZSByb290Jyk7XG4gICAgcmV0dXJuIHJvb3Q7XG59XG5jb25zdCBGcGsxID0gKDAsIG1vZHVsYXJfdHNfMS5GaWVsZCkoc2VjcDI1NmsxUCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHsgc3FydDogc3FydE1vZCB9KTtcbi8qKlxuICogc2VjcDI1NmsxIGN1cnZlLCBFQ0RTQSBhbmQgRUNESCBtZXRob2RzLlxuICpcbiAqIEZpZWxkOiBgMm4qKjI1Nm4gLSAybioqMzJuIC0gMm4qKjluIC0gMm4qKjhuIC0gMm4qKjduIC0gMm4qKjZuIC0gMm4qKjRuIC0gMW5gXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKiBpbXBvcnQgeyBzZWNwMjU2azEgfSBmcm9tICdAbm9ibGUvY3VydmVzL3NlY3AyNTZrMSc7XG4gKiBjb25zdCBwcml2ID0gc2VjcDI1NmsxLnV0aWxzLnJhbmRvbVByaXZhdGVLZXkoKTtcbiAqIGNvbnN0IHB1YiA9IHNlY3AyNTZrMS5nZXRQdWJsaWNLZXkocHJpdik7XG4gKiBjb25zdCBtc2cgPSBuZXcgVWludDhBcnJheSgzMikuZmlsbCgxKTsgLy8gbWVzc2FnZSBoYXNoIChub3QgbWVzc2FnZSkgaW4gZWNkc2FcbiAqIGNvbnN0IHNpZyA9IHNlY3AyNTZrMS5zaWduKG1zZywgcHJpdik7IC8vIGB7cHJlaGFzaDogdHJ1ZX1gIG9wdGlvbiBpcyBhdmFpbGFibGVcbiAqIGNvbnN0IGlzVmFsaWQgPSBzZWNwMjU2azEudmVyaWZ5KHNpZywgbXNnLCBwdWIpID09PSB0cnVlO1xuICogYGBgXG4gKi9cbmV4cG9ydHMuc2VjcDI1NmsxID0gKDAsIF9zaG9ydHdfdXRpbHNfdHNfMS5jcmVhdGVDdXJ2ZSkoe1xuICAgIGE6IF8wbixcbiAgICBiOiBCaWdJbnQoNyksXG4gICAgRnA6IEZwazEsXG4gICAgbjogc2VjcDI1NmsxTixcbiAgICBHeDogQmlnSW50KCc1NTA2NjI2MzAyMjI3NzM0MzY2OTU3ODcxODg5NTE2ODUzNDMyNjI1MDYwMzQ1Mzc3NzU5NDE3NTUwMDE4NzM2MDM4OTExNjcyOTI0MCcpLFxuICAgIEd5OiBCaWdJbnQoJzMyNjcwNTEwMDIwNzU4ODE2OTc4MDgzMDg1MTMwNTA3MDQzMTg0NDcxMjczMzgwNjU5MjQzMjc1OTM4OTA0MzM1NzU3MzM3NDgyNDI0JyksXG4gICAgaDogQmlnSW50KDEpLFxuICAgIGxvd1M6IHRydWUsIC8vIEFsbG93IG9ubHkgbG93LVMgc2lnbmF0dXJlcyBieSBkZWZhdWx0IGluIHNpZ24oKSBhbmQgdmVyaWZ5KClcbiAgICBlbmRvOiB7XG4gICAgICAgIC8vIEVuZG9tb3JwaGlzbSwgc2VlIGFib3ZlXG4gICAgICAgIGJldGE6IEJpZ0ludCgnMHg3YWU5NmEyYjY1N2MwNzEwNmU2NDQ3OWVhYzM0MzRlOTljZjA0OTc1MTJmNTg5OTVjMTM5NmMyODcxOTUwMWVlJyksXG4gICAgICAgIHNwbGl0U2NhbGFyOiAoaykgPT4ge1xuICAgICAgICAgICAgY29uc3QgbiA9IHNlY3AyNTZrMU47XG4gICAgICAgICAgICBjb25zdCBhMSA9IEJpZ0ludCgnMHgzMDg2ZDIyMWE3ZDQ2YmNkZTg2YzkwZTQ5Mjg0ZWIxNScpO1xuICAgICAgICAgICAgY29uc3QgYjEgPSAtXzFuICogQmlnSW50KCcweGU0NDM3ZWQ2MDEwZTg4Mjg2ZjU0N2ZhOTBhYmZlNGMzJyk7XG4gICAgICAgICAgICBjb25zdCBhMiA9IEJpZ0ludCgnMHgxMTRjYTUwZjdhOGUyZjNmNjU3YzExMDhkOWQ0NGNmZDgnKTtcbiAgICAgICAgICAgIGNvbnN0IGIyID0gYTE7XG4gICAgICAgICAgICBjb25zdCBQT1dfMl8xMjggPSBCaWdJbnQoJzB4MTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyk7IC8vICgybioqMTI4bikudG9TdHJpbmcoMTYpXG4gICAgICAgICAgICBjb25zdCBjMSA9IGRpdk5lYXJlc3QoYjIgKiBrLCBuKTtcbiAgICAgICAgICAgIGNvbnN0IGMyID0gZGl2TmVhcmVzdCgtYjEgKiBrLCBuKTtcbiAgICAgICAgICAgIGxldCBrMSA9ICgwLCBtb2R1bGFyX3RzXzEubW9kKShrIC0gYzEgKiBhMSAtIGMyICogYTIsIG4pO1xuICAgICAgICAgICAgbGV0IGsyID0gKDAsIG1vZHVsYXJfdHNfMS5tb2QpKC1jMSAqIGIxIC0gYzIgKiBiMiwgbik7XG4gICAgICAgICAgICBjb25zdCBrMW5lZyA9IGsxID4gUE9XXzJfMTI4O1xuICAgICAgICAgICAgY29uc3QgazJuZWcgPSBrMiA+IFBPV18yXzEyODtcbiAgICAgICAgICAgIGlmIChrMW5lZylcbiAgICAgICAgICAgICAgICBrMSA9IG4gLSBrMTtcbiAgICAgICAgICAgIGlmIChrMm5lZylcbiAgICAgICAgICAgICAgICBrMiA9IG4gLSBrMjtcbiAgICAgICAgICAgIGlmIChrMSA+IFBPV18yXzEyOCB8fCBrMiA+IFBPV18yXzEyOCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc3BsaXRTY2FsYXI6IEVuZG9tb3JwaGlzbSBmYWlsZWQsIGs9JyArIGspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgazFuZWcsIGsxLCBrMm5lZywgazIgfTtcbiAgICAgICAgfSxcbiAgICB9LFxufSwgc2hhMl8xLnNoYTI1Nik7XG4vLyBTY2hub3JyIHNpZ25hdHVyZXMgYXJlIHN1cGVyaW9yIHRvIEVDRFNBIGZyb20gYWJvdmUuIEJlbG93IGlzIFNjaG5vcnItc3BlY2lmaWMgQklQMDM0MCBjb2RlLlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2JpdGNvaW4vYmlwcy9ibG9iL21hc3Rlci9iaXAtMDM0MC5tZWRpYXdpa2lcbi8qKiBBbiBvYmplY3QgbWFwcGluZyB0YWdzIHRvIHRoZWlyIHRhZ2dlZCBoYXNoIHByZWZpeCBvZiBbU0hBMjU2KHRhZykgfCBTSEEyNTYodGFnKV0gKi9cbmNvbnN0IFRBR0dFRF9IQVNIX1BSRUZJWEVTID0ge307XG5mdW5jdGlvbiB0YWdnZWRIYXNoKHRhZywgLi4ubWVzc2FnZXMpIHtcbiAgICBsZXQgdGFnUCA9IFRBR0dFRF9IQVNIX1BSRUZJWEVTW3RhZ107XG4gICAgaWYgKHRhZ1AgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCB0YWdIID0gKDAsIHNoYTJfMS5zaGEyNTYpKFVpbnQ4QXJyYXkuZnJvbSh0YWcsIChjKSA9PiBjLmNoYXJDb2RlQXQoMCkpKTtcbiAgICAgICAgdGFnUCA9ICgwLCB1dGlsc190c18xLmNvbmNhdEJ5dGVzKSh0YWdILCB0YWdIKTtcbiAgICAgICAgVEFHR0VEX0hBU0hfUFJFRklYRVNbdGFnXSA9IHRhZ1A7XG4gICAgfVxuICAgIHJldHVybiAoMCwgc2hhMl8xLnNoYTI1NikoKDAsIHV0aWxzX3RzXzEuY29uY2F0Qnl0ZXMpKHRhZ1AsIC4uLm1lc3NhZ2VzKSk7XG59XG4vLyBFQ0RTQSBjb21wYWN0IHBvaW50cyBhcmUgMzMtYnl0ZS4gU2Nobm9yciBpcyAzMjogd2Ugc3RyaXAgZmlyc3QgYnl0ZSAweDAyIG9yIDB4MDNcbmNvbnN0IHBvaW50VG9CeXRlcyA9IChwb2ludCkgPT4gcG9pbnQudG9SYXdCeXRlcyh0cnVlKS5zbGljZSgxKTtcbmNvbnN0IG51bVRvMzJiID0gKG4pID0+ICgwLCB1dGlsc190c18xLm51bWJlclRvQnl0ZXNCRSkobiwgMzIpO1xuY29uc3QgbW9kUCA9ICh4KSA9PiAoMCwgbW9kdWxhcl90c18xLm1vZCkoeCwgc2VjcDI1NmsxUCk7XG5jb25zdCBtb2ROID0gKHgpID0+ICgwLCBtb2R1bGFyX3RzXzEubW9kKSh4LCBzZWNwMjU2azFOKTtcbmNvbnN0IFBvaW50ID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBleHBvcnRzLnNlY3AyNTZrMS5Qcm9qZWN0aXZlUG9pbnQpKCk7XG5jb25zdCBHbXVsQWRkID0gKFEsIGEsIGIpID0+IFBvaW50LkJBU0UubXVsdGlwbHlBbmRBZGRVbnNhZmUoUSwgYSwgYik7XG4vLyBDYWxjdWxhdGUgcG9pbnQsIHNjYWxhciBhbmQgYnl0ZXNcbmZ1bmN0aW9uIHNjaG5vcnJHZXRFeHRQdWJLZXkocHJpdikge1xuICAgIGxldCBkXyA9IGV4cG9ydHMuc2VjcDI1NmsxLnV0aWxzLm5vcm1Qcml2YXRlS2V5VG9TY2FsYXIocHJpdik7IC8vIHNhbWUgbWV0aG9kIGV4ZWN1dGVkIGluIGZyb21Qcml2YXRlS2V5XG4gICAgbGV0IHAgPSBQb2ludC5mcm9tUHJpdmF0ZUtleShkXyk7IC8vIFAgPSBkJ+KLhUc7IDAgPCBkJyA8IG4gY2hlY2sgaXMgZG9uZSBpbnNpZGVcbiAgICBjb25zdCBzY2FsYXIgPSBwLmhhc0V2ZW5ZKCkgPyBkXyA6IG1vZE4oLWRfKTtcbiAgICByZXR1cm4geyBzY2FsYXI6IHNjYWxhciwgYnl0ZXM6IHBvaW50VG9CeXRlcyhwKSB9O1xufVxuLyoqXG4gKiBsaWZ0X3ggZnJvbSBCSVAzNDAuIENvbnZlcnQgMzItYnl0ZSB4IGNvb3JkaW5hdGUgdG8gZWxsaXB0aWMgY3VydmUgcG9pbnQuXG4gKiBAcmV0dXJucyB2YWxpZCBwb2ludCBjaGVja2VkIGZvciBiZWluZyBvbi1jdXJ2ZVxuICovXG5mdW5jdGlvbiBsaWZ0X3goeCkge1xuICAgICgwLCB1dGlsc190c18xLmFJblJhbmdlKSgneCcsIHgsIF8xbiwgc2VjcDI1NmsxUCk7IC8vIEZhaWwgaWYgeCDiiaUgcC5cbiAgICBjb25zdCB4eCA9IG1vZFAoeCAqIHgpO1xuICAgIGNvbnN0IGMgPSBtb2RQKHh4ICogeCArIEJpZ0ludCg3KSk7IC8vIExldCBjID0geMKzICsgNyBtb2QgcC5cbiAgICBsZXQgeSA9IHNxcnRNb2QoYyk7IC8vIExldCB5ID0gY14ocCsxKS80IG1vZCBwLlxuICAgIGlmICh5ICUgXzJuICE9PSBfMG4pXG4gICAgICAgIHkgPSBtb2RQKC15KTsgLy8gUmV0dXJuIHRoZSB1bmlxdWUgcG9pbnQgUCBzdWNoIHRoYXQgeChQKSA9IHggYW5kXG4gICAgY29uc3QgcCA9IG5ldyBQb2ludCh4LCB5LCBfMW4pOyAvLyB5KFApID0geSBpZiB5IG1vZCAyID0gMCBvciB5KFApID0gcC15IG90aGVyd2lzZS5cbiAgICBwLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgcmV0dXJuIHA7XG59XG5jb25zdCBudW0gPSB1dGlsc190c18xLmJ5dGVzVG9OdW1iZXJCRTtcbi8qKlxuICogQ3JlYXRlIHRhZ2dlZCBoYXNoLCBjb252ZXJ0IGl0IHRvIGJpZ2ludCwgcmVkdWNlIG1vZHVsby1uLlxuICovXG5mdW5jdGlvbiBjaGFsbGVuZ2UoLi4uYXJncykge1xuICAgIHJldHVybiBtb2ROKG51bSh0YWdnZWRIYXNoKCdCSVAwMzQwL2NoYWxsZW5nZScsIC4uLmFyZ3MpKSk7XG59XG4vKipcbiAqIFNjaG5vcnIgcHVibGljIGtleSBpcyBqdXN0IGB4YCBjb29yZGluYXRlIG9mIFBvaW50IGFzIHBlciBCSVAzNDAuXG4gKi9cbmZ1bmN0aW9uIHNjaG5vcnJHZXRQdWJsaWNLZXkocHJpdmF0ZUtleSkge1xuICAgIHJldHVybiBzY2hub3JyR2V0RXh0UHViS2V5KHByaXZhdGVLZXkpLmJ5dGVzOyAvLyBkJz1pbnQoc2spLiBGYWlsIGlmIGQnPTAgb3IgZCfiiaVuLiBSZXQgYnl0ZXMoZCfii4VHKVxufVxuLyoqXG4gKiBDcmVhdGVzIFNjaG5vcnIgc2lnbmF0dXJlIGFzIHBlciBCSVAzNDAuIFZlcmlmaWVzIGl0c2VsZiBiZWZvcmUgcmV0dXJuaW5nIGFueXRoaW5nLlxuICogYXV4UmFuZCBpcyBvcHRpb25hbCBhbmQgaXMgbm90IHRoZSBzb2xlIHNvdXJjZSBvZiBrIGdlbmVyYXRpb246IGJhZCBDU1BSTkcgd29uJ3QgYmUgZGFuZ2Vyb3VzLlxuICovXG5mdW5jdGlvbiBzY2hub3JyU2lnbihtZXNzYWdlLCBwcml2YXRlS2V5LCBhdXhSYW5kID0gKDAsIHV0aWxzXzEucmFuZG9tQnl0ZXMpKDMyKSkge1xuICAgIGNvbnN0IG0gPSAoMCwgdXRpbHNfdHNfMS5lbnN1cmVCeXRlcykoJ21lc3NhZ2UnLCBtZXNzYWdlKTtcbiAgICBjb25zdCB7IGJ5dGVzOiBweCwgc2NhbGFyOiBkIH0gPSBzY2hub3JyR2V0RXh0UHViS2V5KHByaXZhdGVLZXkpOyAvLyBjaGVja3MgZm9yIGlzV2l0aGluQ3VydmVPcmRlclxuICAgIGNvbnN0IGEgPSAoMCwgdXRpbHNfdHNfMS5lbnN1cmVCeXRlcykoJ2F1eFJhbmQnLCBhdXhSYW5kLCAzMik7IC8vIEF1eGlsaWFyeSByYW5kb20gZGF0YSBhOiBhIDMyLWJ5dGUgYXJyYXlcbiAgICBjb25zdCB0ID0gbnVtVG8zMmIoZCBeIG51bSh0YWdnZWRIYXNoKCdCSVAwMzQwL2F1eCcsIGEpKSk7IC8vIExldCB0IGJlIHRoZSBieXRlLXdpc2UgeG9yIG9mIGJ5dGVzKGQpIGFuZCBoYXNoL2F1eChhKVxuICAgIGNvbnN0IHJhbmQgPSB0YWdnZWRIYXNoKCdCSVAwMzQwL25vbmNlJywgdCwgcHgsIG0pOyAvLyBMZXQgcmFuZCA9IGhhc2gvbm9uY2UodCB8fCBieXRlcyhQKSB8fCBtKVxuICAgIGNvbnN0IGtfID0gbW9kTihudW0ocmFuZCkpOyAvLyBMZXQgaycgPSBpbnQocmFuZCkgbW9kIG5cbiAgICBpZiAoa18gPT09IF8wbilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaWduIGZhaWxlZDogayBpcyB6ZXJvJyk7IC8vIEZhaWwgaWYgaycgPSAwLlxuICAgIGNvbnN0IHsgYnl0ZXM6IHJ4LCBzY2FsYXI6IGsgfSA9IHNjaG5vcnJHZXRFeHRQdWJLZXkoa18pOyAvLyBMZXQgUiA9IGsn4ouFRy5cbiAgICBjb25zdCBlID0gY2hhbGxlbmdlKHJ4LCBweCwgbSk7IC8vIExldCBlID0gaW50KGhhc2gvY2hhbGxlbmdlKGJ5dGVzKFIpIHx8IGJ5dGVzKFApIHx8IG0pKSBtb2Qgbi5cbiAgICBjb25zdCBzaWcgPSBuZXcgVWludDhBcnJheSg2NCk7IC8vIExldCBzaWcgPSBieXRlcyhSKSB8fCBieXRlcygoayArIGVkKSBtb2QgbikuXG4gICAgc2lnLnNldChyeCwgMCk7XG4gICAgc2lnLnNldChudW1UbzMyYihtb2ROKGsgKyBlICogZCkpLCAzMik7XG4gICAgLy8gSWYgVmVyaWZ5KGJ5dGVzKFApLCBtLCBzaWcpIChzZWUgYmVsb3cpIHJldHVybnMgZmFpbHVyZSwgYWJvcnRcbiAgICBpZiAoIXNjaG5vcnJWZXJpZnkoc2lnLCBtLCBweCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc2lnbjogSW52YWxpZCBzaWduYXR1cmUgcHJvZHVjZWQnKTtcbiAgICByZXR1cm4gc2lnO1xufVxuLyoqXG4gKiBWZXJpZmllcyBTY2hub3JyIHNpZ25hdHVyZS5cbiAqIFdpbGwgc3dhbGxvdyBlcnJvcnMgJiByZXR1cm4gZmFsc2UgZXhjZXB0IGZvciBpbml0aWFsIHR5cGUgdmFsaWRhdGlvbiBvZiBhcmd1bWVudHMuXG4gKi9cbmZ1bmN0aW9uIHNjaG5vcnJWZXJpZnkoc2lnbmF0dXJlLCBtZXNzYWdlLCBwdWJsaWNLZXkpIHtcbiAgICBjb25zdCBzaWcgPSAoMCwgdXRpbHNfdHNfMS5lbnN1cmVCeXRlcykoJ3NpZ25hdHVyZScsIHNpZ25hdHVyZSwgNjQpO1xuICAgIGNvbnN0IG0gPSAoMCwgdXRpbHNfdHNfMS5lbnN1cmVCeXRlcykoJ21lc3NhZ2UnLCBtZXNzYWdlKTtcbiAgICBjb25zdCBwdWIgPSAoMCwgdXRpbHNfdHNfMS5lbnN1cmVCeXRlcykoJ3B1YmxpY0tleScsIHB1YmxpY0tleSwgMzIpO1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IFAgPSBsaWZ0X3gobnVtKHB1YikpOyAvLyBQID0gbGlmdF94KGludChwaykpOyBmYWlsIGlmIHRoYXQgZmFpbHNcbiAgICAgICAgY29uc3QgciA9IG51bShzaWcuc3ViYXJyYXkoMCwgMzIpKTsgLy8gTGV0IHIgPSBpbnQoc2lnWzA6MzJdKTsgZmFpbCBpZiByIOKJpSBwLlxuICAgICAgICBpZiAoISgwLCB1dGlsc190c18xLmluUmFuZ2UpKHIsIF8xbiwgc2VjcDI1NmsxUCkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGNvbnN0IHMgPSBudW0oc2lnLnN1YmFycmF5KDMyLCA2NCkpOyAvLyBMZXQgcyA9IGludChzaWdbMzI6NjRdKTsgZmFpbCBpZiBzIOKJpSBuLlxuICAgICAgICBpZiAoISgwLCB1dGlsc190c18xLmluUmFuZ2UpKHMsIF8xbiwgc2VjcDI1NmsxTikpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGNvbnN0IGUgPSBjaGFsbGVuZ2UobnVtVG8zMmIociksIHBvaW50VG9CeXRlcyhQKSwgbSk7IC8vIGludChjaGFsbGVuZ2UoYnl0ZXMocil8fGJ5dGVzKFApfHxtKSklblxuICAgICAgICBjb25zdCBSID0gR211bEFkZChQLCBzLCBtb2ROKC1lKSk7IC8vIFIgPSBz4ouFRyAtIGXii4VQXG4gICAgICAgIGlmICghUiB8fCAhUi5oYXNFdmVuWSgpIHx8IFIudG9BZmZpbmUoKS54ICE9PSByKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyAtZVAgPT0gKG4tZSlQXG4gICAgICAgIHJldHVybiB0cnVlOyAvLyBGYWlsIGlmIGlzX2luZmluaXRlKFIpIC8gbm90IGhhc19ldmVuX3koUikgLyB4KFIpIOKJoCByLlxuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbi8qKlxuICogU2Nobm9yciBzaWduYXR1cmVzIG92ZXIgc2VjcDI1NmsxLlxuICogaHR0cHM6Ly9naXRodWIuY29tL2JpdGNvaW4vYmlwcy9ibG9iL21hc3Rlci9iaXAtMDM0MC5tZWRpYXdpa2lcbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICogaW1wb3J0IHsgc2Nobm9yciB9IGZyb20gJ0Bub2JsZS9jdXJ2ZXMvc2VjcDI1NmsxJztcbiAqIGNvbnN0IHByaXYgPSBzY2hub3JyLnV0aWxzLnJhbmRvbVByaXZhdGVLZXkoKTtcbiAqIGNvbnN0IHB1YiA9IHNjaG5vcnIuZ2V0UHVibGljS2V5KHByaXYpO1xuICogY29uc3QgbXNnID0gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKCdoZWxsbycpO1xuICogY29uc3Qgc2lnID0gc2Nobm9yci5zaWduKG1zZywgcHJpdik7XG4gKiBjb25zdCBpc1ZhbGlkID0gc2Nobm9yci52ZXJpZnkoc2lnLCBtc2csIHB1Yik7XG4gKiBgYGBcbiAqL1xuZXhwb3J0cy5zY2hub3JyID0gKCgpID0+ICh7XG4gICAgZ2V0UHVibGljS2V5OiBzY2hub3JyR2V0UHVibGljS2V5LFxuICAgIHNpZ246IHNjaG5vcnJTaWduLFxuICAgIHZlcmlmeTogc2Nobm9yclZlcmlmeSxcbiAgICB1dGlsczoge1xuICAgICAgICByYW5kb21Qcml2YXRlS2V5OiBleHBvcnRzLnNlY3AyNTZrMS51dGlscy5yYW5kb21Qcml2YXRlS2V5LFxuICAgICAgICBsaWZ0X3gsXG4gICAgICAgIHBvaW50VG9CeXRlcyxcbiAgICAgICAgbnVtYmVyVG9CeXRlc0JFOiB1dGlsc190c18xLm51bWJlclRvQnl0ZXNCRSxcbiAgICAgICAgYnl0ZXNUb051bWJlckJFOiB1dGlsc190c18xLmJ5dGVzVG9OdW1iZXJCRSxcbiAgICAgICAgdGFnZ2VkSGFzaCxcbiAgICAgICAgbW9kOiBtb2R1bGFyX3RzXzEubW9kLFxuICAgIH0sXG59KSkoKTtcbmNvbnN0IGlzb01hcCA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gKDAsIGhhc2hfdG9fY3VydmVfdHNfMS5pc29nZW55TWFwKShGcGsxLCBbXG4gICAgLy8geE51bVxuICAgIFtcbiAgICAgICAgJzB4OGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGRhYWFhYThjNycsXG4gICAgICAgICcweDdkM2Q0YzgwYmMzMjFkNWI5ZjMxNWNlYTdmZDQ0YzVkNTk1ZDJmYzBiZjYzYjkyZGZmZjEwNDRmMTdjNjU4MScsXG4gICAgICAgICcweDUzNGMzMjhkMjNmMjM0ZTZlMmE0MTNkZWNhMjVjYWVjZTQ1MDYxNDQwMzdjNDAzMTRlY2JkMGI1M2Q5ZGQyNjInLFxuICAgICAgICAnMHg4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZGFhYWFhODhjJyxcbiAgICBdLFxuICAgIC8vIHhEZW5cbiAgICBbXG4gICAgICAgICcweGQzNTc3MTE5M2Q5NDkxOGE5Y2EzNGNjYmI3YjY0MGRkODZjZDQwOTU0MmY4NDg3ZDlmZTZiNzQ1NzgxZWI0OWInLFxuICAgICAgICAnMHhlZGFkYzZmNjQzODNkYzFkZjdjNGIyZDUxYjU0MjI1NDA2ZDM2YjY0MWY1ZTQxYmJjNTJhNTY2MTJhOGM2ZDE0JyxcbiAgICAgICAgJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMScsIC8vIExBU1QgMVxuICAgIF0sXG4gICAgLy8geU51bVxuICAgIFtcbiAgICAgICAgJzB4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGI4ZTM4ZTIzYycsXG4gICAgICAgICcweGM3NWUwYzMyZDVjYjdjMGZhOWQwYTU0YjEyYTBhNmQ1NjQ3YWIwNDZkNjg2ZGE2ZmRmZmM5MGZjMjAxZDcxYTMnLFxuICAgICAgICAnMHgyOWE2MTk0NjkxZjkxYTczNzE1MjA5ZWY2NTEyZTU3NjcyMjgzMGEyMDFiZTIwMThhNzY1ZTg1YTllY2VlOTMxJyxcbiAgICAgICAgJzB4MmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmYzOGUzOGQ4NCcsXG4gICAgXSxcbiAgICAvLyB5RGVuXG4gICAgW1xuICAgICAgICAnMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZWZmZmZmOTNiJyxcbiAgICAgICAgJzB4N2EwNjUzNGJiOGJkYjQ5ZmQ1ZTllNjYzMjcyMmMyOTg5NDY3YzFiZmM4ZThkOTc4ZGZiNDI1ZDI2ODVjMjU3MycsXG4gICAgICAgICcweDY0ODRhYTcxNjU0NWNhMmNmM2E3MGMzZmE4ZmUzMzdlMGEzZDIxMTYyZjBkNjI5OWE3YmY4MTkyYmZkMmE3NmYnLFxuICAgICAgICAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxJywgLy8gTEFTVCAxXG4gICAgXSxcbl0ubWFwKChpKSA9PiBpLm1hcCgoaikgPT4gQmlnSW50KGopKSkpKSgpO1xuY29uc3QgbWFwU1dVID0gLyogQF9fUFVSRV9fICovICgoKSA9PiAoMCwgd2VpZXJzdHJhc3NfdHNfMS5tYXBUb0N1cnZlU2ltcGxlU1dVKShGcGsxLCB7XG4gICAgQTogQmlnSW50KCcweDNmODczMWFiZGQ2NjFhZGNhMDhhNTU1OGYwZjVkMjcyZTk1M2QzNjNjYjZmMGU1ZDQwNTQ0N2MwMWE0NDQ1MzMnKSxcbiAgICBCOiBCaWdJbnQoJzE3NzEnKSxcbiAgICBaOiBGcGsxLmNyZWF0ZShCaWdJbnQoJy0xMScpKSxcbn0pKSgpO1xuLyoqIEhhc2hpbmcgLyBlbmNvZGluZyB0byBzZWNwMjU2azEgcG9pbnRzIC8gZmllbGQuIFJGQyA5MzgwIG1ldGhvZHMuICovXG5leHBvcnRzLnNlY3AyNTZrMV9oYXNoZXIgPSAoKCkgPT4gKDAsIGhhc2hfdG9fY3VydmVfdHNfMS5jcmVhdGVIYXNoZXIpKGV4cG9ydHMuc2VjcDI1NmsxLlByb2plY3RpdmVQb2ludCwgKHNjYWxhcnMpID0+IHtcbiAgICBjb25zdCB7IHgsIHkgfSA9IG1hcFNXVShGcGsxLmNyZWF0ZShzY2FsYXJzWzBdKSk7XG4gICAgcmV0dXJuIGlzb01hcCh4LCB5KTtcbn0sIHtcbiAgICBEU1Q6ICdzZWNwMjU2azFfWE1EOlNIQS0yNTZfU1NXVV9ST18nLFxuICAgIGVuY29kZURTVDogJ3NlY3AyNTZrMV9YTUQ6U0hBLTI1Nl9TU1dVX05VXycsXG4gICAgcDogRnBrMS5PUkRFUixcbiAgICBtOiAxLFxuICAgIGs6IDEyOCxcbiAgICBleHBhbmQ6ICd4bWQnLFxuICAgIGhhc2g6IHNoYTJfMS5zaGEyNTYsXG59KSkoKTtcbmV4cG9ydHMuaGFzaFRvQ3VydmUgPSAoKCkgPT4gZXhwb3J0cy5zZWNwMjU2azFfaGFzaGVyLmhhc2hUb0N1cnZlKSgpO1xuZXhwb3J0cy5lbmNvZGVUb0N1cnZlID0gKCgpID0+IGV4cG9ydHMuc2VjcDI1NmsxX2hhc2hlci5lbmNvZGVUb0N1cnZlKSgpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VjcDI1NmsxLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImVuY29kZVRvQ3VydmUiLCJoYXNoVG9DdXJ2ZSIsInNlY3AyNTZrMV9oYXNoZXIiLCJzY2hub3JyIiwic2VjcDI1NmsxIiwic2hhMl8xIiwicmVxdWlyZSIsInV0aWxzXzEiLCJfc2hvcnR3X3V0aWxzX3RzXzEiLCJoYXNoX3RvX2N1cnZlX3RzXzEiLCJtb2R1bGFyX3RzXzEiLCJ1dGlsc190c18xIiwid2VpZXJzdHJhc3NfdHNfMSIsInNlY3AyNTZrMVAiLCJCaWdJbnQiLCJzZWNwMjU2azFOIiwiXzBuIiwiXzFuIiwiXzJuIiwiZGl2TmVhcmVzdCIsImEiLCJiIiwic3FydE1vZCIsInkiLCJQIiwiXzNuIiwiXzZuIiwiXzExbiIsIl8yMm4iLCJfMjNuIiwiXzQ0biIsIl84OG4iLCJiMiIsImIzIiwiYjYiLCJwb3cyIiwiYjkiLCJiMTEiLCJiMjIiLCJiNDQiLCJiODgiLCJiMTc2IiwiYjIyMCIsImIyMjMiLCJ0MSIsInQyIiwicm9vdCIsIkZwazEiLCJlcWwiLCJzcXIiLCJFcnJvciIsIkZpZWxkIiwidW5kZWZpbmVkIiwic3FydCIsImNyZWF0ZUN1cnZlIiwiRnAiLCJuIiwiR3giLCJHeSIsImgiLCJsb3dTIiwiZW5kbyIsImJldGEiLCJzcGxpdFNjYWxhciIsImsiLCJhMSIsImIxIiwiYTIiLCJQT1dfMl8xMjgiLCJjMSIsImMyIiwiazEiLCJtb2QiLCJrMiIsImsxbmVnIiwiazJuZWciLCJzaGEyNTYiLCJUQUdHRURfSEFTSF9QUkVGSVhFUyIsInRhZ2dlZEhhc2giLCJ0YWciLCJtZXNzYWdlcyIsInRhZ1AiLCJ0YWdIIiwiVWludDhBcnJheSIsImZyb20iLCJjIiwiY2hhckNvZGVBdCIsImNvbmNhdEJ5dGVzIiwicG9pbnRUb0J5dGVzIiwicG9pbnQiLCJ0b1Jhd0J5dGVzIiwic2xpY2UiLCJudW1UbzMyYiIsIm51bWJlclRvQnl0ZXNCRSIsIm1vZFAiLCJ4IiwibW9kTiIsIlBvaW50IiwiUHJvamVjdGl2ZVBvaW50IiwiR211bEFkZCIsIlEiLCJCQVNFIiwibXVsdGlwbHlBbmRBZGRVbnNhZmUiLCJzY2hub3JyR2V0RXh0UHViS2V5IiwicHJpdiIsImRfIiwidXRpbHMiLCJub3JtUHJpdmF0ZUtleVRvU2NhbGFyIiwicCIsImZyb21Qcml2YXRlS2V5Iiwic2NhbGFyIiwiaGFzRXZlblkiLCJieXRlcyIsImxpZnRfeCIsImFJblJhbmdlIiwieHgiLCJhc3NlcnRWYWxpZGl0eSIsIm51bSIsImJ5dGVzVG9OdW1iZXJCRSIsImNoYWxsZW5nZSIsImFyZ3MiLCJzY2hub3JyR2V0UHVibGljS2V5IiwicHJpdmF0ZUtleSIsInNjaG5vcnJTaWduIiwibWVzc2FnZSIsImF1eFJhbmQiLCJyYW5kb21CeXRlcyIsIm0iLCJlbnN1cmVCeXRlcyIsInB4IiwiZCIsInQiLCJyYW5kIiwia18iLCJyeCIsImUiLCJzaWciLCJzZXQiLCJzY2hub3JyVmVyaWZ5Iiwic2lnbmF0dXJlIiwicHVibGljS2V5IiwicHViIiwiciIsInN1YmFycmF5IiwiaW5SYW5nZSIsInMiLCJSIiwidG9BZmZpbmUiLCJlcnJvciIsImdldFB1YmxpY0tleSIsInNpZ24iLCJ2ZXJpZnkiLCJyYW5kb21Qcml2YXRlS2V5IiwiaXNvTWFwIiwiaXNvZ2VueU1hcCIsIm1hcCIsImkiLCJqIiwibWFwU1dVIiwibWFwVG9DdXJ2ZVNpbXBsZVNXVSIsIkEiLCJCIiwiWiIsImNyZWF0ZSIsImNyZWF0ZUhhc2hlciIsInNjYWxhcnMiLCJEU1QiLCJlbmNvZGVEU1QiLCJPUkRFUiIsImV4cGFuZCIsImhhc2giXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@noble/curves/secp256k1.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@noble/hashes/_md.js":
/*!*******************************************!*\
  !*** ./node_modules/@noble/hashes/_md.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.SHA512_IV = exports.SHA384_IV = exports.SHA224_IV = exports.SHA256_IV = exports.HashMD = void 0;\nexports.setBigUint64 = setBigUint64;\nexports.Chi = Chi;\nexports.Maj = Maj;\n/**\n * Internal Merkle-Damgard hash utils.\n * @module\n */ const utils_ts_1 = __webpack_require__(/*! ./utils.js */ \"(rsc)/./node_modules/@noble/hashes/utils.js\");\n/** Polyfill for Safari 14. https://caniuse.com/mdn-javascript_builtins_dataview_setbiguint64 */ function setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === \"function\") return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number(value >> _32n & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n/** Choice: a ? b : c */ function Chi(a, b, c) {\n    return a & b ^ ~a & c;\n}\n/** Majority function, true if any two inputs is true. */ function Maj(a, b, c) {\n    return a & b ^ a & c ^ b & c;\n}\n/**\n * Merkle-Damgard hash construction base class.\n * Could be used to create MD5, RIPEMD, SHA1, SHA2.\n */ class HashMD extends utils_ts_1.Hash {\n    constructor(blockLen, outputLen, padOffset, isLE){\n        super();\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = (0, utils_ts_1.createView)(this.buffer);\n    }\n    update(data) {\n        (0, utils_ts_1.aexists)(this);\n        data = (0, utils_ts_1.toBytes)(data);\n        (0, utils_ts_1.abytes)(data);\n        const { view, buffer, blockLen } = this;\n        const len = data.length;\n        for(let pos = 0; pos < len;){\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = (0, utils_ts_1.createView)(data);\n                for(; blockLen <= len - pos; pos += blockLen)this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        (0, utils_ts_1.aexists)(this);\n        (0, utils_ts_1.aoutput)(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 128;\n        (0, utils_ts_1.clean)(this.buffer.subarray(pos));\n        // we have less than padOffset left in buffer, so we cannot put length in\n        // current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for(let i = pos; i < blockLen; i++)buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = (0, utils_ts_1.createView)(out);\n        const len = this.outputLen;\n        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n        if (len % 4) throw new Error(\"_sha2: outputLen should be aligned to 32bit\");\n        const outLen = len / 4;\n        const state = this.get();\n        if (outLen > state.length) throw new Error(\"_sha2: outputLen bigger than state\");\n        for(let i = 0; i < outLen; i++)oview.setUint32(4 * i, state[i], isLE);\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.destroyed = destroyed;\n        to.finished = finished;\n        to.length = length;\n        to.pos = pos;\n        if (length % blockLen) to.buffer.set(buffer);\n        return to;\n    }\n    clone() {\n        return this._cloneInto();\n    }\n}\nexports.HashMD = HashMD;\n/**\n * Initial SHA-2 state: fractional parts of square roots of first 16 primes 2..53.\n * Check out `test/misc/sha2-gen-iv.js` for recomputation guide.\n */ /** Initial SHA256 state. Bits 0..32 of frac part of sqrt of primes 2..19 */ exports.SHA256_IV = Uint32Array.from([\n    0x6a09e667,\n    0xbb67ae85,\n    0x3c6ef372,\n    0xa54ff53a,\n    0x510e527f,\n    0x9b05688c,\n    0x1f83d9ab,\n    0x5be0cd19\n]);\n/** Initial SHA224 state. Bits 32..64 of frac part of sqrt of primes 23..53 */ exports.SHA224_IV = Uint32Array.from([\n    0xc1059ed8,\n    0x367cd507,\n    0x3070dd17,\n    0xf70e5939,\n    0xffc00b31,\n    0x68581511,\n    0x64f98fa7,\n    0xbefa4fa4\n]);\n/** Initial SHA384 state. Bits 0..64 of frac part of sqrt of primes 23..53 */ exports.SHA384_IV = Uint32Array.from([\n    0xcbbb9d5d,\n    0xc1059ed8,\n    0x629a292a,\n    0x367cd507,\n    0x9159015a,\n    0x3070dd17,\n    0x152fecd8,\n    0xf70e5939,\n    0x67332667,\n    0xffc00b31,\n    0x8eb44a87,\n    0x68581511,\n    0xdb0c2e0d,\n    0x64f98fa7,\n    0x47b5481d,\n    0xbefa4fa4\n]);\n/** Initial SHA512 state. Bits 0..64 of frac part of sqrt of primes 2..19 */ exports.SHA512_IV = Uint32Array.from([\n    0x6a09e667,\n    0xf3bcc908,\n    0xbb67ae85,\n    0x84caa73b,\n    0x3c6ef372,\n    0xfe94f82b,\n    0xa54ff53a,\n    0x5f1d36f1,\n    0x510e527f,\n    0xade682d1,\n    0x9b05688c,\n    0x2b3e6c1f,\n    0x1f83d9ab,\n    0xfb41bd6b,\n    0x5be0cd19,\n    0x137e2179\n]); //# sourceMappingURL=_md.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9fbWQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGlCQUFpQixHQUFHQSxpQkFBaUIsR0FBR0EsaUJBQWlCLEdBQUdBLGlCQUFpQixHQUFHQSxjQUFjLEdBQUcsS0FBSztBQUN0R0Esb0JBQW9CLEdBQUdPO0FBQ3ZCUCxXQUFXLEdBQUdRO0FBQ2RSLFdBQVcsR0FBR1M7QUFDZDs7O0NBR0MsR0FDRCxNQUFNQyxhQUFhQyxtQkFBT0EsQ0FBQywrREFBWTtBQUN2Qyw4RkFBOEYsR0FDOUYsU0FBU0osYUFBYUssSUFBSSxFQUFFQyxVQUFVLEVBQUVaLEtBQUssRUFBRWEsSUFBSTtJQUMvQyxJQUFJLE9BQU9GLEtBQUtMLFlBQVksS0FBSyxZQUM3QixPQUFPSyxLQUFLTCxZQUFZLENBQUNNLFlBQVlaLE9BQU9hO0lBQ2hELE1BQU1DLE9BQU9DLE9BQU87SUFDcEIsTUFBTUMsV0FBV0QsT0FBTztJQUN4QixNQUFNRSxLQUFLQyxPQUFPLFNBQVVKLE9BQVFFO0lBQ3BDLE1BQU1HLEtBQUtELE9BQU9sQixRQUFRZ0I7SUFDMUIsTUFBTUksSUFBSVAsT0FBTyxJQUFJO0lBQ3JCLE1BQU1RLElBQUlSLE9BQU8sSUFBSTtJQUNyQkYsS0FBS1csU0FBUyxDQUFDVixhQUFhUSxHQUFHSCxJQUFJSjtJQUNuQ0YsS0FBS1csU0FBUyxDQUFDVixhQUFhUyxHQUFHRixJQUFJTjtBQUN2QztBQUNBLHNCQUFzQixHQUN0QixTQUFTTixJQUFJZ0IsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLENBQUM7SUFDaEIsT0FBTyxJQUFLRCxJQUFNLENBQUNELElBQUlFO0FBQzNCO0FBQ0EsdURBQXVELEdBQ3ZELFNBQVNqQixJQUFJZSxDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBQztJQUNoQixPQUFPLElBQUtELElBQU1ELElBQUlFLElBQU1ELElBQUlDO0FBQ3BDO0FBQ0E7OztDQUdDLEdBQ0QsTUFBTXBCLGVBQWVJLFdBQVdpQixJQUFJO0lBQ2hDQyxZQUFZQyxRQUFRLEVBQUVDLFNBQVMsRUFBRUMsU0FBUyxFQUFFakIsSUFBSSxDQUFFO1FBQzlDLEtBQUs7UUFDTCxJQUFJLENBQUNrQixRQUFRLEdBQUc7UUFDaEIsSUFBSSxDQUFDQyxNQUFNLEdBQUc7UUFDZCxJQUFJLENBQUNDLEdBQUcsR0FBRztRQUNYLElBQUksQ0FBQ0MsU0FBUyxHQUFHO1FBQ2pCLElBQUksQ0FBQ04sUUFBUSxHQUFHQTtRQUNoQixJQUFJLENBQUNDLFNBQVMsR0FBR0E7UUFDakIsSUFBSSxDQUFDQyxTQUFTLEdBQUdBO1FBQ2pCLElBQUksQ0FBQ2pCLElBQUksR0FBR0E7UUFDWixJQUFJLENBQUNzQixNQUFNLEdBQUcsSUFBSUMsV0FBV1I7UUFDN0IsSUFBSSxDQUFDakIsSUFBSSxHQUFHLENBQUMsR0FBR0YsV0FBVzRCLFVBQVUsRUFBRSxJQUFJLENBQUNGLE1BQU07SUFDdEQ7SUFDQUcsT0FBT0MsSUFBSSxFQUFFO1FBQ1IsSUFBRzlCLFdBQVcrQixPQUFPLEVBQUUsSUFBSTtRQUM1QkQsT0FBTyxDQUFDLEdBQUc5QixXQUFXZ0MsT0FBTyxFQUFFRjtRQUM5QixJQUFHOUIsV0FBV2lDLE1BQU0sRUFBRUg7UUFDdkIsTUFBTSxFQUFFNUIsSUFBSSxFQUFFd0IsTUFBTSxFQUFFUCxRQUFRLEVBQUUsR0FBRyxJQUFJO1FBQ3ZDLE1BQU1lLE1BQU1KLEtBQUtQLE1BQU07UUFDdkIsSUFBSyxJQUFJQyxNQUFNLEdBQUdBLE1BQU1VLEtBQU07WUFDMUIsTUFBTUMsT0FBT0MsS0FBS0MsR0FBRyxDQUFDbEIsV0FBVyxJQUFJLENBQUNLLEdBQUcsRUFBRVUsTUFBTVY7WUFDakQsOEVBQThFO1lBQzlFLElBQUlXLFNBQVNoQixVQUFVO2dCQUNuQixNQUFNbUIsV0FBVyxDQUFDLEdBQUd0QyxXQUFXNEIsVUFBVSxFQUFFRTtnQkFDNUMsTUFBT1gsWUFBWWUsTUFBTVYsS0FBS0EsT0FBT0wsU0FDakMsSUFBSSxDQUFDb0IsT0FBTyxDQUFDRCxVQUFVZDtnQkFDM0I7WUFDSjtZQUNBRSxPQUFPYyxHQUFHLENBQUNWLEtBQUtXLFFBQVEsQ0FBQ2pCLEtBQUtBLE1BQU1XLE9BQU8sSUFBSSxDQUFDWCxHQUFHO1lBQ25ELElBQUksQ0FBQ0EsR0FBRyxJQUFJVztZQUNaWCxPQUFPVztZQUNQLElBQUksSUFBSSxDQUFDWCxHQUFHLEtBQUtMLFVBQVU7Z0JBQ3ZCLElBQUksQ0FBQ29CLE9BQU8sQ0FBQ3JDLE1BQU07Z0JBQ25CLElBQUksQ0FBQ3NCLEdBQUcsR0FBRztZQUNmO1FBQ0o7UUFDQSxJQUFJLENBQUNELE1BQU0sSUFBSU8sS0FBS1AsTUFBTTtRQUMxQixJQUFJLENBQUNtQixVQUFVO1FBQ2YsT0FBTyxJQUFJO0lBQ2Y7SUFDQUMsV0FBV0MsR0FBRyxFQUFFO1FBQ1gsSUFBRzVDLFdBQVcrQixPQUFPLEVBQUUsSUFBSTtRQUMzQixJQUFHL0IsV0FBVzZDLE9BQU8sRUFBRUQsS0FBSyxJQUFJO1FBQ2pDLElBQUksQ0FBQ3RCLFFBQVEsR0FBRztRQUNoQixVQUFVO1FBQ1YsaUVBQWlFO1FBQ2pFLHNFQUFzRTtRQUN0RSxNQUFNLEVBQUVJLE1BQU0sRUFBRXhCLElBQUksRUFBRWlCLFFBQVEsRUFBRWYsSUFBSSxFQUFFLEdBQUcsSUFBSTtRQUM3QyxJQUFJLEVBQUVvQixHQUFHLEVBQUUsR0FBRyxJQUFJO1FBQ2xCLG9DQUFvQztRQUNwQ0UsTUFBTSxDQUFDRixNQUFNLEdBQUc7UUFDZixJQUFHeEIsV0FBVzhDLEtBQUssRUFBRSxJQUFJLENBQUNwQixNQUFNLENBQUNlLFFBQVEsQ0FBQ2pCO1FBQzNDLHlFQUF5RTtRQUN6RSwrQ0FBK0M7UUFDL0MsSUFBSSxJQUFJLENBQUNILFNBQVMsR0FBR0YsV0FBV0ssS0FBSztZQUNqQyxJQUFJLENBQUNlLE9BQU8sQ0FBQ3JDLE1BQU07WUFDbkJzQixNQUFNO1FBQ1Y7UUFDQSx1Q0FBdUM7UUFDdkMsSUFBSyxJQUFJdUIsSUFBSXZCLEtBQUt1QixJQUFJNUIsVUFBVTRCLElBQzVCckIsTUFBTSxDQUFDcUIsRUFBRSxHQUFHO1FBQ2hCLGdHQUFnRztRQUNoRyxvRkFBb0Y7UUFDcEYsaURBQWlEO1FBQ2pEbEQsYUFBYUssTUFBTWlCLFdBQVcsR0FBR2IsT0FBTyxJQUFJLENBQUNpQixNQUFNLEdBQUcsSUFBSW5CO1FBQzFELElBQUksQ0FBQ21DLE9BQU8sQ0FBQ3JDLE1BQU07UUFDbkIsTUFBTThDLFFBQVEsQ0FBQyxHQUFHaEQsV0FBVzRCLFVBQVUsRUFBRWdCO1FBQ3pDLE1BQU1WLE1BQU0sSUFBSSxDQUFDZCxTQUFTO1FBQzFCLHlGQUF5RjtRQUN6RixJQUFJYyxNQUFNLEdBQ04sTUFBTSxJQUFJZSxNQUFNO1FBQ3BCLE1BQU1DLFNBQVNoQixNQUFNO1FBQ3JCLE1BQU1pQixRQUFRLElBQUksQ0FBQ0MsR0FBRztRQUN0QixJQUFJRixTQUFTQyxNQUFNNUIsTUFBTSxFQUNyQixNQUFNLElBQUkwQixNQUFNO1FBQ3BCLElBQUssSUFBSUYsSUFBSSxHQUFHQSxJQUFJRyxRQUFRSCxJQUN4QkMsTUFBTW5DLFNBQVMsQ0FBQyxJQUFJa0MsR0FBR0ksS0FBSyxDQUFDSixFQUFFLEVBQUUzQztJQUN6QztJQUNBaUQsU0FBUztRQUNMLE1BQU0sRUFBRTNCLE1BQU0sRUFBRU4sU0FBUyxFQUFFLEdBQUcsSUFBSTtRQUNsQyxJQUFJLENBQUN1QixVQUFVLENBQUNqQjtRQUNoQixNQUFNNEIsTUFBTTVCLE9BQU82QixLQUFLLENBQUMsR0FBR25DO1FBQzVCLElBQUksQ0FBQ29DLE9BQU87UUFDWixPQUFPRjtJQUNYO0lBQ0FHLFdBQVdDLEVBQUUsRUFBRTtRQUNYQSxNQUFPQSxDQUFBQSxLQUFLLElBQUksSUFBSSxDQUFDeEMsV0FBVyxFQUFDO1FBQ2pDd0MsR0FBR2xCLEdBQUcsSUFBSSxJQUFJLENBQUNZLEdBQUc7UUFDbEIsTUFBTSxFQUFFakMsUUFBUSxFQUFFTyxNQUFNLEVBQUVILE1BQU0sRUFBRUQsUUFBUSxFQUFFRyxTQUFTLEVBQUVELEdBQUcsRUFBRSxHQUFHLElBQUk7UUFDbkVrQyxHQUFHakMsU0FBUyxHQUFHQTtRQUNmaUMsR0FBR3BDLFFBQVEsR0FBR0E7UUFDZG9DLEdBQUduQyxNQUFNLEdBQUdBO1FBQ1ptQyxHQUFHbEMsR0FBRyxHQUFHQTtRQUNULElBQUlELFNBQVNKLFVBQ1R1QyxHQUFHaEMsTUFBTSxDQUFDYyxHQUFHLENBQUNkO1FBQ2xCLE9BQU9nQztJQUNYO0lBQ0FDLFFBQVE7UUFDSixPQUFPLElBQUksQ0FBQ0YsVUFBVTtJQUMxQjtBQUNKO0FBQ0FuRSxjQUFjLEdBQUdNO0FBQ2pCOzs7Q0FHQyxHQUNELDBFQUEwRSxHQUMxRU4saUJBQWlCLEdBQUdzRSxZQUFZQyxJQUFJLENBQUM7SUFDakM7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtDQUN2RjtBQUNELDRFQUE0RSxHQUM1RXZFLGlCQUFpQixHQUFHc0UsWUFBWUMsSUFBSSxDQUFDO0lBQ2pDO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7Q0FDdkY7QUFDRCwyRUFBMkUsR0FDM0V2RSxpQkFBaUIsR0FBR3NFLFlBQVlDLElBQUksQ0FBQztJQUNqQztJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQ3BGO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7Q0FDdkY7QUFDRCwwRUFBMEUsR0FDMUV2RSxpQkFBaUIsR0FBR3NFLFlBQVlDLElBQUksQ0FBQztJQUNqQztJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQ3BGO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7Q0FDdkYsR0FDRCwrQkFBK0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mYXJjYXN0ZXJzdGF0cy8uL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL19tZC5qcz83MDE2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TSEE1MTJfSVYgPSBleHBvcnRzLlNIQTM4NF9JViA9IGV4cG9ydHMuU0hBMjI0X0lWID0gZXhwb3J0cy5TSEEyNTZfSVYgPSBleHBvcnRzLkhhc2hNRCA9IHZvaWQgMDtcbmV4cG9ydHMuc2V0QmlnVWludDY0ID0gc2V0QmlnVWludDY0O1xuZXhwb3J0cy5DaGkgPSBDaGk7XG5leHBvcnRzLk1haiA9IE1hajtcbi8qKlxuICogSW50ZXJuYWwgTWVya2xlLURhbWdhcmQgaGFzaCB1dGlscy5cbiAqIEBtb2R1bGVcbiAqL1xuY29uc3QgdXRpbHNfdHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzLmpzXCIpO1xuLyoqIFBvbHlmaWxsIGZvciBTYWZhcmkgMTQuIGh0dHBzOi8vY2FuaXVzZS5jb20vbWRuLWphdmFzY3JpcHRfYnVpbHRpbnNfZGF0YXZpZXdfc2V0YmlndWludDY0ICovXG5mdW5jdGlvbiBzZXRCaWdVaW50NjQodmlldywgYnl0ZU9mZnNldCwgdmFsdWUsIGlzTEUpIHtcbiAgICBpZiAodHlwZW9mIHZpZXcuc2V0QmlnVWludDY0ID09PSAnZnVuY3Rpb24nKVxuICAgICAgICByZXR1cm4gdmlldy5zZXRCaWdVaW50NjQoYnl0ZU9mZnNldCwgdmFsdWUsIGlzTEUpO1xuICAgIGNvbnN0IF8zMm4gPSBCaWdJbnQoMzIpO1xuICAgIGNvbnN0IF91MzJfbWF4ID0gQmlnSW50KDB4ZmZmZmZmZmYpO1xuICAgIGNvbnN0IHdoID0gTnVtYmVyKCh2YWx1ZSA+PiBfMzJuKSAmIF91MzJfbWF4KTtcbiAgICBjb25zdCB3bCA9IE51bWJlcih2YWx1ZSAmIF91MzJfbWF4KTtcbiAgICBjb25zdCBoID0gaXNMRSA/IDQgOiAwO1xuICAgIGNvbnN0IGwgPSBpc0xFID8gMCA6IDQ7XG4gICAgdmlldy5zZXRVaW50MzIoYnl0ZU9mZnNldCArIGgsIHdoLCBpc0xFKTtcbiAgICB2aWV3LnNldFVpbnQzMihieXRlT2Zmc2V0ICsgbCwgd2wsIGlzTEUpO1xufVxuLyoqIENob2ljZTogYSA/IGIgOiBjICovXG5mdW5jdGlvbiBDaGkoYSwgYiwgYykge1xuICAgIHJldHVybiAoYSAmIGIpIF4gKH5hICYgYyk7XG59XG4vKiogTWFqb3JpdHkgZnVuY3Rpb24sIHRydWUgaWYgYW55IHR3byBpbnB1dHMgaXMgdHJ1ZS4gKi9cbmZ1bmN0aW9uIE1haihhLCBiLCBjKSB7XG4gICAgcmV0dXJuIChhICYgYikgXiAoYSAmIGMpIF4gKGIgJiBjKTtcbn1cbi8qKlxuICogTWVya2xlLURhbWdhcmQgaGFzaCBjb25zdHJ1Y3Rpb24gYmFzZSBjbGFzcy5cbiAqIENvdWxkIGJlIHVzZWQgdG8gY3JlYXRlIE1ENSwgUklQRU1ELCBTSEExLCBTSEEyLlxuICovXG5jbGFzcyBIYXNoTUQgZXh0ZW5kcyB1dGlsc190c18xLkhhc2gge1xuICAgIGNvbnN0cnVjdG9yKGJsb2NrTGVuLCBvdXRwdXRMZW4sIHBhZE9mZnNldCwgaXNMRSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmJsb2NrTGVuID0gYmxvY2tMZW47XG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gb3V0cHV0TGVuO1xuICAgICAgICB0aGlzLnBhZE9mZnNldCA9IHBhZE9mZnNldDtcbiAgICAgICAgdGhpcy5pc0xFID0gaXNMRTtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBuZXcgVWludDhBcnJheShibG9ja0xlbik7XG4gICAgICAgIHRoaXMudmlldyA9ICgwLCB1dGlsc190c18xLmNyZWF0ZVZpZXcpKHRoaXMuYnVmZmVyKTtcbiAgICB9XG4gICAgdXBkYXRlKGRhdGEpIHtcbiAgICAgICAgKDAsIHV0aWxzX3RzXzEuYWV4aXN0cykodGhpcyk7XG4gICAgICAgIGRhdGEgPSAoMCwgdXRpbHNfdHNfMS50b0J5dGVzKShkYXRhKTtcbiAgICAgICAgKDAsIHV0aWxzX3RzXzEuYWJ5dGVzKShkYXRhKTtcbiAgICAgICAgY29uc3QgeyB2aWV3LCBidWZmZXIsIGJsb2NrTGVuIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBsZW4gPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gMDsgcG9zIDwgbGVuOykge1xuICAgICAgICAgICAgY29uc3QgdGFrZSA9IE1hdGgubWluKGJsb2NrTGVuIC0gdGhpcy5wb3MsIGxlbiAtIHBvcyk7XG4gICAgICAgICAgICAvLyBGYXN0IHBhdGg6IHdlIGhhdmUgYXQgbGVhc3Qgb25lIGJsb2NrIGluIGlucHV0LCBjYXN0IGl0IHRvIHZpZXcgYW5kIHByb2Nlc3NcbiAgICAgICAgICAgIGlmICh0YWtlID09PSBibG9ja0xlbikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGFWaWV3ID0gKDAsIHV0aWxzX3RzXzEuY3JlYXRlVmlldykoZGF0YSk7XG4gICAgICAgICAgICAgICAgZm9yICg7IGJsb2NrTGVuIDw9IGxlbiAtIHBvczsgcG9zICs9IGJsb2NrTGVuKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3MoZGF0YVZpZXcsIHBvcyk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBidWZmZXIuc2V0KGRhdGEuc3ViYXJyYXkocG9zLCBwb3MgKyB0YWtlKSwgdGhpcy5wb3MpO1xuICAgICAgICAgICAgdGhpcy5wb3MgKz0gdGFrZTtcbiAgICAgICAgICAgIHBvcyArPSB0YWtlO1xuICAgICAgICAgICAgaWYgKHRoaXMucG9zID09PSBibG9ja0xlbikge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzcyh2aWV3LCAwKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sZW5ndGggKz0gZGF0YS5sZW5ndGg7XG4gICAgICAgIHRoaXMucm91bmRDbGVhbigpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGlnZXN0SW50byhvdXQpIHtcbiAgICAgICAgKDAsIHV0aWxzX3RzXzEuYWV4aXN0cykodGhpcyk7XG4gICAgICAgICgwLCB1dGlsc190c18xLmFvdXRwdXQpKG91dCwgdGhpcyk7XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgICAvLyBQYWRkaW5nXG4gICAgICAgIC8vIFdlIGNhbiBhdm9pZCBhbGxvY2F0aW9uIG9mIGJ1ZmZlciBmb3IgcGFkZGluZyBjb21wbGV0ZWx5IGlmIGl0XG4gICAgICAgIC8vIHdhcyBwcmV2aW91c2x5IG5vdCBhbGxvY2F0ZWQgaGVyZS4gQnV0IGl0IHdvbid0IGNoYW5nZSBwZXJmb3JtYW5jZS5cbiAgICAgICAgY29uc3QgeyBidWZmZXIsIHZpZXcsIGJsb2NrTGVuLCBpc0xFIH0gPSB0aGlzO1xuICAgICAgICBsZXQgeyBwb3MgfSA9IHRoaXM7XG4gICAgICAgIC8vIGFwcGVuZCB0aGUgYml0ICcxJyB0byB0aGUgbWVzc2FnZVxuICAgICAgICBidWZmZXJbcG9zKytdID0gMGIxMDAwMDAwMDtcbiAgICAgICAgKDAsIHV0aWxzX3RzXzEuY2xlYW4pKHRoaXMuYnVmZmVyLnN1YmFycmF5KHBvcykpO1xuICAgICAgICAvLyB3ZSBoYXZlIGxlc3MgdGhhbiBwYWRPZmZzZXQgbGVmdCBpbiBidWZmZXIsIHNvIHdlIGNhbm5vdCBwdXQgbGVuZ3RoIGluXG4gICAgICAgIC8vIGN1cnJlbnQgYmxvY2ssIG5lZWQgcHJvY2VzcyBpdCBhbmQgcGFkIGFnYWluXG4gICAgICAgIGlmICh0aGlzLnBhZE9mZnNldCA+IGJsb2NrTGVuIC0gcG9zKSB7XG4gICAgICAgICAgICB0aGlzLnByb2Nlc3ModmlldywgMCk7XG4gICAgICAgICAgICBwb3MgPSAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIFBhZCB1bnRpbCBmdWxsIGJsb2NrIGJ5dGUgd2l0aCB6ZXJvc1xuICAgICAgICBmb3IgKGxldCBpID0gcG9zOyBpIDwgYmxvY2tMZW47IGkrKylcbiAgICAgICAgICAgIGJ1ZmZlcltpXSA9IDA7XG4gICAgICAgIC8vIE5vdGU6IHNoYTUxMiByZXF1aXJlcyBsZW5ndGggdG8gYmUgMTI4Yml0IGludGVnZXIsIGJ1dCBsZW5ndGggaW4gSlMgd2lsbCBvdmVyZmxvdyBiZWZvcmUgdGhhdFxuICAgICAgICAvLyBZb3UgbmVlZCB0byB3cml0ZSBhcm91bmQgMiBleGFieXRlcyAodTY0X21heCAvIDggLyAoMTAyNCoqNikpIGZvciB0aGlzIHRvIGhhcHBlbi5cbiAgICAgICAgLy8gU28gd2UganVzdCB3cml0ZSBsb3dlc3QgNjQgYml0cyBvZiB0aGF0IHZhbHVlLlxuICAgICAgICBzZXRCaWdVaW50NjQodmlldywgYmxvY2tMZW4gLSA4LCBCaWdJbnQodGhpcy5sZW5ndGggKiA4KSwgaXNMRSk7XG4gICAgICAgIHRoaXMucHJvY2Vzcyh2aWV3LCAwKTtcbiAgICAgICAgY29uc3Qgb3ZpZXcgPSAoMCwgdXRpbHNfdHNfMS5jcmVhdGVWaWV3KShvdXQpO1xuICAgICAgICBjb25zdCBsZW4gPSB0aGlzLm91dHB1dExlbjtcbiAgICAgICAgLy8gTk9URTogd2UgZG8gZGl2aXNpb24gYnkgNCBsYXRlciwgd2hpY2ggc2hvdWxkIGJlIGZ1c2VkIGluIHNpbmdsZSBvcCB3aXRoIG1vZHVsbyBieSBKSVRcbiAgICAgICAgaWYgKGxlbiAlIDQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ19zaGEyOiBvdXRwdXRMZW4gc2hvdWxkIGJlIGFsaWduZWQgdG8gMzJiaXQnKTtcbiAgICAgICAgY29uc3Qgb3V0TGVuID0gbGVuIC8gNDtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLmdldCgpO1xuICAgICAgICBpZiAob3V0TGVuID4gc3RhdGUubGVuZ3RoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdfc2hhMjogb3V0cHV0TGVuIGJpZ2dlciB0aGFuIHN0YXRlJyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0TGVuOyBpKyspXG4gICAgICAgICAgICBvdmlldy5zZXRVaW50MzIoNCAqIGksIHN0YXRlW2ldLCBpc0xFKTtcbiAgICB9XG4gICAgZGlnZXN0KCkge1xuICAgICAgICBjb25zdCB7IGJ1ZmZlciwgb3V0cHV0TGVuIH0gPSB0aGlzO1xuICAgICAgICB0aGlzLmRpZ2VzdEludG8oYnVmZmVyKTtcbiAgICAgICAgY29uc3QgcmVzID0gYnVmZmVyLnNsaWNlKDAsIG91dHB1dExlbik7XG4gICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICBfY2xvbmVJbnRvKHRvKSB7XG4gICAgICAgIHRvIHx8ICh0byA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkpO1xuICAgICAgICB0by5zZXQoLi4udGhpcy5nZXQoKSk7XG4gICAgICAgIGNvbnN0IHsgYmxvY2tMZW4sIGJ1ZmZlciwgbGVuZ3RoLCBmaW5pc2hlZCwgZGVzdHJveWVkLCBwb3MgfSA9IHRoaXM7XG4gICAgICAgIHRvLmRlc3Ryb3llZCA9IGRlc3Ryb3llZDtcbiAgICAgICAgdG8uZmluaXNoZWQgPSBmaW5pc2hlZDtcbiAgICAgICAgdG8ubGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICB0by5wb3MgPSBwb3M7XG4gICAgICAgIGlmIChsZW5ndGggJSBibG9ja0xlbilcbiAgICAgICAgICAgIHRvLmJ1ZmZlci5zZXQoYnVmZmVyKTtcbiAgICAgICAgcmV0dXJuIHRvO1xuICAgIH1cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Nsb25lSW50bygpO1xuICAgIH1cbn1cbmV4cG9ydHMuSGFzaE1EID0gSGFzaE1EO1xuLyoqXG4gKiBJbml0aWFsIFNIQS0yIHN0YXRlOiBmcmFjdGlvbmFsIHBhcnRzIG9mIHNxdWFyZSByb290cyBvZiBmaXJzdCAxNiBwcmltZXMgMi4uNTMuXG4gKiBDaGVjayBvdXQgYHRlc3QvbWlzYy9zaGEyLWdlbi1pdi5qc2AgZm9yIHJlY29tcHV0YXRpb24gZ3VpZGUuXG4gKi9cbi8qKiBJbml0aWFsIFNIQTI1NiBzdGF0ZS4gQml0cyAwLi4zMiBvZiBmcmFjIHBhcnQgb2Ygc3FydCBvZiBwcmltZXMgMi4uMTkgKi9cbmV4cG9ydHMuU0hBMjU2X0lWID0gVWludDMyQXJyYXkuZnJvbShbXG4gICAgMHg2YTA5ZTY2NywgMHhiYjY3YWU4NSwgMHgzYzZlZjM3MiwgMHhhNTRmZjUzYSwgMHg1MTBlNTI3ZiwgMHg5YjA1Njg4YywgMHgxZjgzZDlhYiwgMHg1YmUwY2QxOSxcbl0pO1xuLyoqIEluaXRpYWwgU0hBMjI0IHN0YXRlLiBCaXRzIDMyLi42NCBvZiBmcmFjIHBhcnQgb2Ygc3FydCBvZiBwcmltZXMgMjMuLjUzICovXG5leHBvcnRzLlNIQTIyNF9JViA9IFVpbnQzMkFycmF5LmZyb20oW1xuICAgIDB4YzEwNTllZDgsIDB4MzY3Y2Q1MDcsIDB4MzA3MGRkMTcsIDB4ZjcwZTU5MzksIDB4ZmZjMDBiMzEsIDB4Njg1ODE1MTEsIDB4NjRmOThmYTcsIDB4YmVmYTRmYTQsXG5dKTtcbi8qKiBJbml0aWFsIFNIQTM4NCBzdGF0ZS4gQml0cyAwLi42NCBvZiBmcmFjIHBhcnQgb2Ygc3FydCBvZiBwcmltZXMgMjMuLjUzICovXG5leHBvcnRzLlNIQTM4NF9JViA9IFVpbnQzMkFycmF5LmZyb20oW1xuICAgIDB4Y2JiYjlkNWQsIDB4YzEwNTllZDgsIDB4NjI5YTI5MmEsIDB4MzY3Y2Q1MDcsIDB4OTE1OTAxNWEsIDB4MzA3MGRkMTcsIDB4MTUyZmVjZDgsIDB4ZjcwZTU5MzksXG4gICAgMHg2NzMzMjY2NywgMHhmZmMwMGIzMSwgMHg4ZWI0NGE4NywgMHg2ODU4MTUxMSwgMHhkYjBjMmUwZCwgMHg2NGY5OGZhNywgMHg0N2I1NDgxZCwgMHhiZWZhNGZhNCxcbl0pO1xuLyoqIEluaXRpYWwgU0hBNTEyIHN0YXRlLiBCaXRzIDAuLjY0IG9mIGZyYWMgcGFydCBvZiBzcXJ0IG9mIHByaW1lcyAyLi4xOSAqL1xuZXhwb3J0cy5TSEE1MTJfSVYgPSBVaW50MzJBcnJheS5mcm9tKFtcbiAgICAweDZhMDllNjY3LCAweGYzYmNjOTA4LCAweGJiNjdhZTg1LCAweDg0Y2FhNzNiLCAweDNjNmVmMzcyLCAweGZlOTRmODJiLCAweGE1NGZmNTNhLCAweDVmMWQzNmYxLFxuICAgIDB4NTEwZTUyN2YsIDB4YWRlNjgyZDEsIDB4OWIwNTY4OGMsIDB4MmIzZTZjMWYsIDB4MWY4M2Q5YWIsIDB4ZmI0MWJkNmIsIDB4NWJlMGNkMTksIDB4MTM3ZTIxNzksXG5dKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV9tZC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJTSEE1MTJfSVYiLCJTSEEzODRfSVYiLCJTSEEyMjRfSVYiLCJTSEEyNTZfSVYiLCJIYXNoTUQiLCJzZXRCaWdVaW50NjQiLCJDaGkiLCJNYWoiLCJ1dGlsc190c18xIiwicmVxdWlyZSIsInZpZXciLCJieXRlT2Zmc2V0IiwiaXNMRSIsIl8zMm4iLCJCaWdJbnQiLCJfdTMyX21heCIsIndoIiwiTnVtYmVyIiwid2wiLCJoIiwibCIsInNldFVpbnQzMiIsImEiLCJiIiwiYyIsIkhhc2giLCJjb25zdHJ1Y3RvciIsImJsb2NrTGVuIiwib3V0cHV0TGVuIiwicGFkT2Zmc2V0IiwiZmluaXNoZWQiLCJsZW5ndGgiLCJwb3MiLCJkZXN0cm95ZWQiLCJidWZmZXIiLCJVaW50OEFycmF5IiwiY3JlYXRlVmlldyIsInVwZGF0ZSIsImRhdGEiLCJhZXhpc3RzIiwidG9CeXRlcyIsImFieXRlcyIsImxlbiIsInRha2UiLCJNYXRoIiwibWluIiwiZGF0YVZpZXciLCJwcm9jZXNzIiwic2V0Iiwic3ViYXJyYXkiLCJyb3VuZENsZWFuIiwiZGlnZXN0SW50byIsIm91dCIsImFvdXRwdXQiLCJjbGVhbiIsImkiLCJvdmlldyIsIkVycm9yIiwib3V0TGVuIiwic3RhdGUiLCJnZXQiLCJkaWdlc3QiLCJyZXMiLCJzbGljZSIsImRlc3Ryb3kiLCJfY2xvbmVJbnRvIiwidG8iLCJjbG9uZSIsIlVpbnQzMkFycmF5IiwiZnJvbSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@noble/hashes/_md.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@noble/hashes/_u64.js":
/*!********************************************!*\
  !*** ./node_modules/@noble/hashes/_u64.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.toBig = exports.shrSL = exports.shrSH = exports.rotrSL = exports.rotrSH = exports.rotrBL = exports.rotrBH = exports.rotr32L = exports.rotr32H = exports.rotlSL = exports.rotlSH = exports.rotlBL = exports.rotlBH = exports.add5L = exports.add5H = exports.add4L = exports.add4H = exports.add3L = exports.add3H = void 0;\nexports.add = add;\nexports.fromBig = fromBig;\nexports.split = split;\n/**\n * Internal helpers for u64. BigUint64Array is too slow as per 2025, so we implement it using Uint32Array.\n * @todo re-check https://issues.chromium.org/issues/42212588\n * @module\n */ const U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\nfunction fromBig(n, le = false) {\n    if (le) return {\n        h: Number(n & U32_MASK64),\n        l: Number(n >> _32n & U32_MASK64)\n    };\n    return {\n        h: Number(n >> _32n & U32_MASK64) | 0,\n        l: Number(n & U32_MASK64) | 0\n    };\n}\nfunction split(lst, le = false) {\n    const len = lst.length;\n    let Ah = new Uint32Array(len);\n    let Al = new Uint32Array(len);\n    for(let i = 0; i < len; i++){\n        const { h, l } = fromBig(lst[i], le);\n        [Ah[i], Al[i]] = [\n            h,\n            l\n        ];\n    }\n    return [\n        Ah,\n        Al\n    ];\n}\nconst toBig = (h, l)=>BigInt(h >>> 0) << _32n | BigInt(l >>> 0);\nexports.toBig = toBig;\n// for Shift in [0, 32)\nconst shrSH = (h, _l, s)=>h >>> s;\nexports.shrSH = shrSH;\nconst shrSL = (h, l, s)=>h << 32 - s | l >>> s;\nexports.shrSL = shrSL;\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h, l, s)=>h >>> s | l << 32 - s;\nexports.rotrSH = rotrSH;\nconst rotrSL = (h, l, s)=>h << 32 - s | l >>> s;\nexports.rotrSL = rotrSL;\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h, l, s)=>h << 64 - s | l >>> s - 32;\nexports.rotrBH = rotrBH;\nconst rotrBL = (h, l, s)=>h >>> s - 32 | l << 64 - s;\nexports.rotrBL = rotrBL;\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h, l)=>l;\nexports.rotr32H = rotr32H;\nconst rotr32L = (h, _l)=>h;\nexports.rotr32L = rotr32L;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h, l, s)=>h << s | l >>> 32 - s;\nexports.rotlSH = rotlSH;\nconst rotlSL = (h, l, s)=>l << s | h >>> 32 - s;\nexports.rotlSL = rotlSL;\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h, l, s)=>l << s - 32 | h >>> 64 - s;\nexports.rotlBH = rotlBH;\nconst rotlBL = (h, l, s)=>h << s - 32 | l >>> 64 - s;\nexports.rotlBL = rotlBL;\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(Ah, Al, Bh, Bl) {\n    const l = (Al >>> 0) + (Bl >>> 0);\n    return {\n        h: Ah + Bh + (l / 2 ** 32 | 0) | 0,\n        l: l | 0\n    };\n}\n// Addition with more than 2 elements\nconst add3L = (Al, Bl, Cl)=>(Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nexports.add3L = add3L;\nconst add3H = (low, Ah, Bh, Ch)=>Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;\nexports.add3H = add3H;\nconst add4L = (Al, Bl, Cl, Dl)=>(Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nexports.add4L = add4L;\nconst add4H = (low, Ah, Bh, Ch, Dh)=>Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;\nexports.add4H = add4H;\nconst add5L = (Al, Bl, Cl, Dl, El)=>(Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nexports.add5L = add5L;\nconst add5H = (low, Ah, Bh, Ch, Dh, Eh)=>Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;\nexports.add5H = add5H;\n// prettier-ignore\nconst u64 = {\n    fromBig,\n    split,\n    toBig,\n    shrSH,\n    shrSL,\n    rotrSH,\n    rotrSL,\n    rotrBH,\n    rotrBL,\n    rotr32H,\n    rotr32L,\n    rotlSH,\n    rotlSL,\n    rotlBH,\n    rotlBL,\n    add,\n    add3L,\n    add3H,\n    add4L,\n    add4H,\n    add5H,\n    add5L\n};\nexports[\"default\"] = u64; //# sourceMappingURL=_u64.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9fdTY0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxhQUFhLEdBQUdBLGFBQWEsR0FBR0EsYUFBYSxHQUFHQSxjQUFjLEdBQUdBLGNBQWMsR0FBR0EsY0FBYyxHQUFHQSxjQUFjLEdBQUdBLGVBQWUsR0FBR0EsZUFBZSxHQUFHQSxjQUFjLEdBQUdBLGNBQWMsR0FBR0EsY0FBYyxHQUFHQSxjQUFjLEdBQUdBLGFBQWEsR0FBR0EsYUFBYSxHQUFHQSxhQUFhLEdBQUdBLGFBQWEsR0FBR0EsYUFBYSxHQUFHQSxhQUFhLEdBQUcsS0FBSztBQUNqVUEsV0FBVyxHQUFHcUI7QUFDZHJCLGVBQWUsR0FBR3NCO0FBQ2xCdEIsYUFBYSxHQUFHdUI7QUFDaEI7Ozs7Q0FJQyxHQUNELE1BQU1DLGFBQWEsYUFBYSxHQUFHQyxPQUFPLEtBQUssS0FBSztBQUNwRCxNQUFNQyxPQUFPLGFBQWEsR0FBR0QsT0FBTztBQUNwQyxTQUFTSCxRQUFRSyxDQUFDLEVBQUVDLEtBQUssS0FBSztJQUMxQixJQUFJQSxJQUNBLE9BQU87UUFBRUMsR0FBR0MsT0FBT0gsSUFBSUg7UUFBYU8sR0FBR0QsT0FBTyxLQUFNSixPQUFRRjtJQUFZO0lBQzVFLE9BQU87UUFBRUssR0FBR0MsT0FBTyxLQUFNSixPQUFRRixjQUFjO1FBQUdPLEdBQUdELE9BQU9ILElBQUlILGNBQWM7SUFBRTtBQUNwRjtBQUNBLFNBQVNELE1BQU1TLEdBQUcsRUFBRUosS0FBSyxLQUFLO0lBQzFCLE1BQU1LLE1BQU1ELElBQUlFLE1BQU07SUFDdEIsSUFBSUMsS0FBSyxJQUFJQyxZQUFZSDtJQUN6QixJQUFJSSxLQUFLLElBQUlELFlBQVlIO0lBQ3pCLElBQUssSUFBSUssSUFBSSxHQUFHQSxJQUFJTCxLQUFLSyxJQUFLO1FBQzFCLE1BQU0sRUFBRVQsQ0FBQyxFQUFFRSxDQUFDLEVBQUUs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Q2pGL0MsYUFBYSxHQUFHaUI7QUFDaEIsTUFBTUMsUUFBUSxDQUFDMkIsS0FBS1YsSUFBSU8sSUFBSUksSUFBSUUsS0FBTyxLQUFNTixLQUFLSSxLQUFLRSxLQUFNLE9BQU8sS0FBSyxLQUFNLEtBQU07QUFDckZoRCxhQUFhLEdBQUdrQjtBQUNoQixNQUFNSCxRQUFRLENBQUNzQixJQUFJTSxJQUFJQyxJQUFJRyxJQUFJRSxLQUFPLENBQUNaLE9BQU8sS0FBTU0sQ0FBQUEsT0FBTyxLQUFNQyxDQUFBQSxPQUFPLEtBQU1HLENBQUFBLE9BQU8sS0FBTUUsQ0FBQUEsT0FBTztBQUNsR2pELGFBQWEsR0FBR2U7QUFDaEIsTUFBTUMsUUFBUSxDQUFDNkIsS0FBS1YsSUFBSU8sSUFBSUksSUFBSUUsSUFBSUUsS0FBTyxLQUFNUixLQUFLSSxLQUFLRSxLQUFLRSxLQUFNLE9BQU8sS0FBSyxLQUFNLEtBQU07QUFDOUZsRCxhQUFhLEdBQUdnQjtBQUNoQixrQkFBa0I7QUFDbEIsTUFBTW1DLE1BQU07SUFDUjdCO0lBQVNDO0lBQU9yQjtJQUNoQkU7SUFBT0Q7SUFDUEc7SUFBUUQ7SUFBUUc7SUFBUUQ7SUFDeEJHO0lBQVNEO0lBQ1RHO0lBQVFEO0lBQVFHO0lBQVFEO0lBQ3hCUTtJQUFLRjtJQUFPQztJQUFPSDtJQUFPQztJQUFPRjtJQUFPRDtBQUM1QztBQUNBZixrQkFBZSxHQUFHbUQsS0FDbEIsZ0NBQWdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZmFyY2FzdGVyc3RhdHMvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9fdTY0LmpzP2QyNzIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnRvQmlnID0gZXhwb3J0cy5zaHJTTCA9IGV4cG9ydHMuc2hyU0ggPSBleHBvcnRzLnJvdHJTTCA9IGV4cG9ydHMucm90clNIID0gZXhwb3J0cy5yb3RyQkwgPSBleHBvcnRzLnJvdHJCSCA9IGV4cG9ydHMucm90cjMyTCA9IGV4cG9ydHMucm90cjMySCA9IGV4cG9ydHMucm90bFNMID0gZXhwb3J0cy5yb3RsU0ggPSBleHBvcnRzLnJvdGxCTCA9IGV4cG9ydHMucm90bEJIID0gZXhwb3J0cy5hZGQ1TCA9IGV4cG9ydHMuYWRkNUggPSBleHBvcnRzLmFkZDRMID0gZXhwb3J0cy5hZGQ0SCA9IGV4cG9ydHMuYWRkM0wgPSBleHBvcnRzLmFkZDNIID0gdm9pZCAwO1xuZXhwb3J0cy5hZGQgPSBhZGQ7XG5leHBvcnRzLmZyb21CaWcgPSBmcm9tQmlnO1xuZXhwb3J0cy5zcGxpdCA9IHNwbGl0O1xuLyoqXG4gKiBJbnRlcm5hbCBoZWxwZXJzIGZvciB1NjQuIEJpZ1VpbnQ2NEFycmF5IGlzIHRvbyBzbG93IGFzIHBlciAyMDI1LCBzbyB3ZSBpbXBsZW1lbnQgaXQgdXNpbmcgVWludDMyQXJyYXkuXG4gKiBAdG9kbyByZS1jaGVjayBodHRwczovL2lzc3Vlcy5jaHJvbWl1bS5vcmcvaXNzdWVzLzQyMjEyNTg4XG4gKiBAbW9kdWxlXG4gKi9cbmNvbnN0IFUzMl9NQVNLNjQgPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDIgKiogMzIgLSAxKTtcbmNvbnN0IF8zMm4gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDMyKTtcbmZ1bmN0aW9uIGZyb21CaWcobiwgbGUgPSBmYWxzZSkge1xuICAgIGlmIChsZSlcbiAgICAgICAgcmV0dXJuIHsgaDogTnVtYmVyKG4gJiBVMzJfTUFTSzY0KSwgbDogTnVtYmVyKChuID4+IF8zMm4pICYgVTMyX01BU0s2NCkgfTtcbiAgICByZXR1cm4geyBoOiBOdW1iZXIoKG4gPj4gXzMybikgJiBVMzJfTUFTSzY0KSB8IDAsIGw6IE51bWJlcihuICYgVTMyX01BU0s2NCkgfCAwIH07XG59XG5mdW5jdGlvbiBzcGxpdChsc3QsIGxlID0gZmFsc2UpIHtcbiAgICBjb25zdCBsZW4gPSBsc3QubGVuZ3RoO1xuICAgIGxldCBBaCA9IG5ldyBVaW50MzJBcnJheShsZW4pO1xuICAgIGxldCBBbCA9IG5ldyBVaW50MzJBcnJheShsZW4pO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgY29uc3QgeyBoLCBsIH0gPSBmcm9tQmlnKGxzdFtpXSwgbGUpO1xuICAgICAgICBbQWhbaV0sIEFsW2ldXSA9IFtoLCBsXTtcbiAgICB9XG4gICAgcmV0dXJuIFtBaCwgQWxdO1xufVxuY29uc3QgdG9CaWcgPSAoaCwgbCkgPT4gKEJpZ0ludChoID4+PiAwKSA8PCBfMzJuKSB8IEJpZ0ludChsID4+PiAwKTtcbmV4cG9ydHMudG9CaWcgPSB0b0JpZztcbi8vIGZvciBTaGlmdCBpbiBbMCwgMzIpXG5jb25zdCBzaHJTSCA9IChoLCBfbCwgcykgPT4gaCA+Pj4gcztcbmV4cG9ydHMuc2hyU0ggPSBzaHJTSDtcbmNvbnN0IHNoclNMID0gKGgsIGwsIHMpID0+IChoIDw8ICgzMiAtIHMpKSB8IChsID4+PiBzKTtcbmV4cG9ydHMuc2hyU0wgPSBzaHJTTDtcbi8vIFJpZ2h0IHJvdGF0ZSBmb3IgU2hpZnQgaW4gWzEsIDMyKVxuY29uc3Qgcm90clNIID0gKGgsIGwsIHMpID0+IChoID4+PiBzKSB8IChsIDw8ICgzMiAtIHMpKTtcbmV4cG9ydHMucm90clNIID0gcm90clNIO1xuY29uc3Qgcm90clNMID0gKGgsIGwsIHMpID0+IChoIDw8ICgzMiAtIHMpKSB8IChsID4+PiBzKTtcbmV4cG9ydHMucm90clNMID0gcm90clNMO1xuLy8gUmlnaHQgcm90YXRlIGZvciBTaGlmdCBpbiAoMzIsIDY0KSwgTk9URTogMzIgaXMgc3BlY2lhbCBjYXNlLlxuY29uc3Qgcm90ckJIID0gKGgsIGwsIHMpID0+IChoIDw8ICg2NCAtIHMpKSB8IChsID4+PiAocyAtIDMyKSk7XG5leHBvcnRzLnJvdHJCSCA9IHJvdHJCSDtcbmNvbnN0IHJvdHJCTCA9IChoLCBsLCBzKSA9PiAoaCA+Pj4gKHMgLSAzMikpIHwgKGwgPDwgKDY0IC0gcykpO1xuZXhwb3J0cy5yb3RyQkwgPSByb3RyQkw7XG4vLyBSaWdodCByb3RhdGUgZm9yIHNoaWZ0PT09MzIgKGp1c3Qgc3dhcHMgbCZoKVxuY29uc3Qgcm90cjMySCA9IChfaCwgbCkgPT4gbDtcbmV4cG9ydHMucm90cjMySCA9IHJvdHIzMkg7XG5jb25zdCByb3RyMzJMID0gKGgsIF9sKSA9PiBoO1xuZXhwb3J0cy5yb3RyMzJMID0gcm90cjMyTDtcbi8vIExlZnQgcm90YXRlIGZvciBTaGlmdCBpbiBbMSwgMzIpXG5jb25zdCByb3RsU0ggPSAoaCwgbCwgcykgPT4gKGggPDwgcykgfCAobCA+Pj4gKDMyIC0gcykpO1xuZXhwb3J0cy5yb3RsU0ggPSByb3RsU0g7XG5jb25zdCByb3RsU0wgPSAoaCwgbCwgcykgPT4gKGwgPDwgcykgfCAoaCA+Pj4gKDMyIC0gcykpO1xuZXhwb3J0cy5yb3RsU0wgPSByb3RsU0w7XG4vLyBMZWZ0IHJvdGF0ZSBmb3IgU2hpZnQgaW4gKDMyLCA2NCksIE5PVEU6IDMyIGlzIHNwZWNpYWwgY2FzZS5cbmNvbnN0IHJvdGxCSCA9IChoLCBsLCBzKSA9PiAobCA8PCAocyAtIDMyKSkgfCAoaCA+Pj4gKDY0IC0gcykpO1xuZXhwb3J0cy5yb3RsQkggPSByb3RsQkg7XG5jb25zdCByb3RsQkwgPSAoaCwgbCwgcykgPT4gKGggPDwgKHMgLSAzMikpIHwgKGwgPj4+ICg2NCAtIHMpKTtcbmV4cG9ydHMucm90bEJMID0gcm90bEJMO1xuLy8gSlMgdXNlcyAzMi1iaXQgc2lnbmVkIGludGVnZXJzIGZvciBiaXR3aXNlIG9wZXJhdGlvbnMgd2hpY2ggbWVhbnMgd2UgY2Fubm90XG4vLyBzaW1wbGUgdGFrZSBjYXJyeSBvdXQgb2YgbG93IGJpdCBzdW0gYnkgc2hpZnQsIHdlIG5lZWQgdG8gdXNlIGRpdmlzaW9uLlxuZnVuY3Rpb24gYWRkKEFoLCBBbCwgQmgsIEJsKSB7XG4gICAgY29uc3QgbCA9IChBbCA+Pj4gMCkgKyAoQmwgPj4+IDApO1xuICAgIHJldHVybiB7IGg6IChBaCArIEJoICsgKChsIC8gMiAqKiAzMikgfCAwKSkgfCAwLCBsOiBsIHwgMCB9O1xufVxuLy8gQWRkaXRpb24gd2l0aCBtb3JlIHRoYW4gMiBlbGVtZW50c1xuY29uc3QgYWRkM0wgPSAoQWwsIEJsLCBDbCkgPT4gKEFsID4+PiAwKSArIChCbCA+Pj4gMCkgKyAoQ2wgPj4+IDApO1xuZXhwb3J0cy5hZGQzTCA9IGFkZDNMO1xuY29uc3QgYWRkM0ggPSAobG93LCBBaCwgQmgsIENoKSA9PiAoQWggKyBCaCArIENoICsgKChsb3cgLyAyICoqIDMyKSB8IDApKSB8IDA7XG5leHBvcnRzLmFkZDNIID0gYWRkM0g7XG5jb25zdCBhZGQ0TCA9IChBbCwgQmwsIENsLCBEbCkgPT4gKEFsID4+PiAwKSArIChCbCA+Pj4gMCkgKyAoQ2wgPj4+IDApICsgKERsID4+PiAwKTtcbmV4cG9ydHMuYWRkNEwgPSBhZGQ0TDtcbmNvbnN0IGFkZDRIID0gKGxvdywgQWgsIEJoLCBDaCwgRGgpID0+IChBaCArIEJoICsgQ2ggKyBEaCArICgobG93IC8gMiAqKiAzMikgfCAwKSkgfCAwO1xuZXhwb3J0cy5hZGQ0SCA9IGFkZDRIO1xuY29uc3QgYWRkNUwgPSAoQWwsIEJsLCBDbCwgRGwsIEVsKSA9PiAoQWwgPj4+IDApICsgKEJsID4+PiAwKSArIChDbCA+Pj4gMCkgKyAoRGwgPj4+IDApICsgKEVsID4+PiAwKTtcbmV4cG9ydHMuYWRkNUwgPSBhZGQ1TDtcbmNvbnN0IGFkZDVIID0gKGxvdywgQWgsIEJoLCBDaCwgRGgsIEVoKSA9PiAoQWggKyBCaCArIENoICsgRGggKyBFaCArICgobG93IC8gMiAqKiAzMikgfCAwKSkgfCAwO1xuZXhwb3J0cy5hZGQ1SCA9IGFkZDVIO1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCB1NjQgPSB7XG4gICAgZnJvbUJpZywgc3BsaXQsIHRvQmlnLFxuICAgIHNoclNILCBzaHJTTCxcbiAgICByb3RyU0gsIHJvdHJTTCwgcm90ckJILCByb3RyQkwsXG4gICAgcm90cjMySCwgcm90cjMyTCxcbiAgICByb3RsU0gsIHJvdGxTTCwgcm90bEJILCByb3RsQkwsXG4gICAgYWRkLCBhZGQzTCwgYWRkM0gsIGFkZDRMLCBhZGQ0SCwgYWRkNUgsIGFkZDVMLFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IHU2NDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV91NjQuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwidG9CaWciLCJzaHJTTCIsInNoclNIIiwicm90clNMIiwicm90clNIIiwicm90ckJMIiwicm90ckJIIiwicm90cjMyTCIsInJvdHIzMkgiLCJyb3RsU0wiLCJyb3RsU0giLCJyb3RsQkwiLCJyb3RsQkgiLCJhZGQ1TCIsImFkZDVIIiwiYWRkNEwiLCJhZGQ0SCIsImFkZDNMIiwiYWRkM0giLCJhZGQiLCJmcm9tQmlnIiwic3BsaXQiLCJVMzJfTUFTSzY0IiwiQmlnSW50IiwiXzMybiIsIm4iLCJsZSIsImgiLCJOdW1iZXIiLCJsIiwibHN0IiwibGVuIiwibGVuZ3RoIiwiQWgiLCJVaW50MzJBcnJheSIsIkFsIiwiaSIsIl9sIiwicyIsIl9oIiwiQmgiLCJCbCIsIkNsIiwibG93IiwiQ2giLCJEbCIsIkRoIiwiRWwiLCJFaCIsInU2NCIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@noble/hashes/_u64.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@noble/hashes/cryptoNode.js":
/*!**************************************************!*\
  !*** ./node_modules/@noble/hashes/cryptoNode.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.crypto = void 0;\n/**\n * Internal webcrypto alias.\n * We prefer WebCrypto aka globalThis.crypto, which exists in node.js 16+.\n * Falls back to Node.js built-in crypto for Node.js <=v14.\n * See utils.ts for details.\n * @module\n */ // @ts-ignore\nconst nc = __webpack_require__(/*! node:crypto */ \"node:crypto\");\nexports.crypto = nc && typeof nc === \"object\" && \"webcrypto\" in nc ? nc.webcrypto : nc && typeof nc === \"object\" && \"randomBytes\" in nc ? nc : undefined; //# sourceMappingURL=cryptoNode.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9jcnlwdG9Ob2RlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxjQUFjLEdBQUcsS0FBSztBQUN0Qjs7Ozs7O0NBTUMsR0FDRCxhQUFhO0FBQ2IsTUFBTUcsS0FBS0MsbUJBQU9BLENBQUMsZ0NBQWE7QUFDaENKLGNBQWMsR0FBR0csTUFBTSxPQUFPQSxPQUFPLFlBQVksZUFBZUEsS0FDMURBLEdBQUdFLFNBQVMsR0FDWkYsTUFBTSxPQUFPQSxPQUFPLFlBQVksaUJBQWlCQSxLQUM3Q0EsS0FDQUcsV0FDVixzQ0FBc0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mYXJjYXN0ZXJzdGF0cy8uL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2NyeXB0b05vZGUuanM/ZGUwNSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY3J5cHRvID0gdm9pZCAwO1xuLyoqXG4gKiBJbnRlcm5hbCB3ZWJjcnlwdG8gYWxpYXMuXG4gKiBXZSBwcmVmZXIgV2ViQ3J5cHRvIGFrYSBnbG9iYWxUaGlzLmNyeXB0bywgd2hpY2ggZXhpc3RzIGluIG5vZGUuanMgMTYrLlxuICogRmFsbHMgYmFjayB0byBOb2RlLmpzIGJ1aWx0LWluIGNyeXB0byBmb3IgTm9kZS5qcyA8PXYxNC5cbiAqIFNlZSB1dGlscy50cyBmb3IgZGV0YWlscy5cbiAqIEBtb2R1bGVcbiAqL1xuLy8gQHRzLWlnbm9yZVxuY29uc3QgbmMgPSByZXF1aXJlKFwibm9kZTpjcnlwdG9cIik7XG5leHBvcnRzLmNyeXB0byA9IG5jICYmIHR5cGVvZiBuYyA9PT0gJ29iamVjdCcgJiYgJ3dlYmNyeXB0bycgaW4gbmNcbiAgICA/IG5jLndlYmNyeXB0b1xuICAgIDogbmMgJiYgdHlwZW9mIG5jID09PSAnb2JqZWN0JyAmJiAncmFuZG9tQnl0ZXMnIGluIG5jXG4gICAgICAgID8gbmNcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jcnlwdG9Ob2RlLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImNyeXB0byIsIm5jIiwicmVxdWlyZSIsIndlYmNyeXB0byIsInVuZGVmaW5lZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@noble/hashes/cryptoNode.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@noble/hashes/hmac.js":
/*!********************************************!*\
  !*** ./node_modules/@noble/hashes/hmac.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.hmac = exports.HMAC = void 0;\n/**\n * HMAC: RFC2104 message authentication code.\n * @module\n */ const utils_ts_1 = __webpack_require__(/*! ./utils.js */ \"(rsc)/./node_modules/@noble/hashes/utils.js\");\nclass HMAC extends utils_ts_1.Hash {\n    constructor(hash, _key){\n        super();\n        this.finished = false;\n        this.destroyed = false;\n        (0, utils_ts_1.ahash)(hash);\n        const key = (0, utils_ts_1.toBytes)(_key);\n        this.iHash = hash.create();\n        if (typeof this.iHash.update !== \"function\") throw new Error(\"Expected instance of class which extends utils.Hash\");\n        this.blockLen = this.iHash.blockLen;\n        this.outputLen = this.iHash.outputLen;\n        const blockLen = this.blockLen;\n        const pad = new Uint8Array(blockLen);\n        // blockLen can be bigger than outputLen\n        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\n        for(let i = 0; i < pad.length; i++)pad[i] ^= 0x36;\n        this.iHash.update(pad);\n        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n        this.oHash = hash.create();\n        // Undo internal XOR && apply outer XOR\n        for(let i = 0; i < pad.length; i++)pad[i] ^= 0x36 ^ 0x5c;\n        this.oHash.update(pad);\n        (0, utils_ts_1.clean)(pad);\n    }\n    update(buf) {\n        (0, utils_ts_1.aexists)(this);\n        this.iHash.update(buf);\n        return this;\n    }\n    digestInto(out) {\n        (0, utils_ts_1.aexists)(this);\n        (0, utils_ts_1.abytes)(out, this.outputLen);\n        this.finished = true;\n        this.iHash.digestInto(out);\n        this.oHash.update(out);\n        this.oHash.digestInto(out);\n        this.destroy();\n    }\n    digest() {\n        const out = new Uint8Array(this.oHash.outputLen);\n        this.digestInto(out);\n        return out;\n    }\n    _cloneInto(to) {\n        // Create new instance without calling constructor since key already in state and we don't know it.\n        to || (to = Object.create(Object.getPrototypeOf(this), {}));\n        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n        to = to;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        to.blockLen = blockLen;\n        to.outputLen = outputLen;\n        to.oHash = oHash._cloneInto(to.oHash);\n        to.iHash = iHash._cloneInto(to.iHash);\n        return to;\n    }\n    clone() {\n        return this._cloneInto();\n    }\n    destroy() {\n        this.destroyed = true;\n        this.oHash.destroy();\n        this.iHash.destroy();\n    }\n}\nexports.HMAC = HMAC;\n/**\n * HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256\n * @param key - message key\n * @param message - message data\n * @example\n * import { hmac } from '@noble/hashes/hmac';\n * import { sha256 } from '@noble/hashes/sha2';\n * const mac1 = hmac(sha256, 'key', 'message');\n */ const hmac = (hash, key, message)=>new HMAC(hash, key).update(message).digest();\nexports.hmac = hmac;\nexports.hmac.create = (hash, key)=>new HMAC(hash, key); //# sourceMappingURL=hmac.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9obWFjLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxZQUFZLEdBQUdBLFlBQVksR0FBRyxLQUFLO0FBQ25DOzs7Q0FHQyxHQUNELE1BQU1JLGFBQWFDLG1CQUFPQSxDQUFDLCtEQUFZO0FBQ3ZDLE1BQU1GLGFBQWFDLFdBQVdFLElBQUk7SUFDOUJDLFlBQVlDLElBQUksRUFBRUMsSUFBSSxDQUFFO1FBQ3BCLEtBQUs7UUFDTCxJQUFJLENBQUNDLFFBQVEsR0FBRztRQUNoQixJQUFJLENBQUNDLFNBQVMsR0FBRztRQUNoQixJQUFHUCxXQUFXUSxLQUFLLEVBQUVKO1FBQ3RCLE1BQU1LLE1BQU0sQ0FBQyxHQUFHVCxXQUFXVSxPQUFPLEVBQUVMO1FBQ3BDLElBQUksQ0FBQ00sS0FBSyxHQUFHUCxLQUFLUSxNQUFNO1FBQ3hCLElBQUksT0FBTyxJQUFJLENBQUNELEtBQUssQ0FBQ0UsTUFBTSxLQUFLLFlBQzdCLE1BQU0sSUFBSUMsTUFBTTtRQUNwQixJQUFJLENBQUNDLFFBQVEsR0FBRyxJQUFJLENBQUNKLEtBQUssQ0FBQ0ksUUFBUTtRQUNuQyxJQUFJLENBQUNDLFNBQVMsR0FBRyxJQUFJLENBQUNMLEtBQUssQ0FBQ0ssU0FBUztRQUNyQyxNQUFNRCxXQUFXLElBQUksQ0FBQ0EsUUFBUTtRQUM5QixNQUFNRSxNQUFNLElBQUlDLFdBQVdIO1FBQzNCLHdDQUF3QztRQUN4Q0UsSUFBSUUsR0FBRyxDQUFDVixJQUFJVyxNQUFNLEdBQUdMLFdBQVdYLEtBQUtRLE1BQU0sR0FBR0MsTUFBTSxDQUFDSixLQUFLWSxNQUFNLEtBQUtaO1FBQ3JFLElBQUssSUFBSWEsSUFBSSxHQUFHQSxJQUFJTCxJQUFJRyxNQUFNLEVBQUVFLElBQzVCTCxHQUFHLENBQUNLLEVBQUUsSUFBSTtRQUNkLElBQUksQ0FBQ1gsS0FBSyxDQUFDRSxNQUFNLENBQUNJO1FBQ2xCLG1IQUFtSDtRQUNuSCxJQUFJLENBQUNNLEtBQUssR0FBR25CLEtBQUtRLE1BQU07UUFDeEIsdUNBQXVDO1FBQ3ZDLElBQUssSUFBSVUsSUFBSSxHQUFHQSxJQUFJTCxJQUFJRyxNQUFNLEVBQUVFLElBQzVCTCxHQUFHLENBQUNLLEVBQUUsSUFBSSxPQUFPO1FBQ3JCLElBQUksQ0FBQ0MsS0FBSyxDQUFDVixNQUFNLENBQUNJO1FBQ2pCLElBQUdqQixXQUFXd0IsS0FBSyxFQUFFUDtJQUMxQjtJQUNBSixPQUFPWSxHQUFHLEVBQUU7UUFDUCxJQUFHekIsV0FBVzBCLE9BQU8sRUFBRSxJQUFJO1FBQzVCLElBQUksQ0FBQ2YsS0FBSyxDQUFDRSxNQUFNLENBQUNZO1FBQ2xCLE9BQU8sSUFBSTtJQUNmO0lBQ0FFLFdBQVdDLEdBQUcsRUFBRTtRQUNYLElBQUc1QixXQUFXMEIsT0FBTyxFQUFFLElBQUk7UUFDM0IsSUFBRzFCLFdBQVc2QixNQUFNLEVBQUVELEtBQUssSUFBSSxDQUFDWixTQUFTO1FBQzFDLElBQUksQ0FBQ1YsUUFBUSxHQUFHO1FBQ2hCLElBQUksQ0FBQ0ssS0FBSyxDQUFDZ0IsVUFBVSxDQUFDQztRQUN0QixJQUFJLENBQUNMLEtBQUssQ0FBQ1YsTUFBTSxDQUFDZTtRQUNsQixJQUFJLENBQUNMLEtBQUssQ0FBQ0ksVUFBVSxDQUFDQztRQUN0QixJQUFJLENBQUNFLE9BQU87SUFDaEI7SUFDQVQsU0FBUztRQUNMLE1BQU1PLE1BQU0sSUFBSVYsV0FBVyxJQUFJLENBQUNLLEtBQUssQ0FBQ1AsU0FBUztRQUMvQyxJQUFJLENBQUNXLFVBQVUsQ0FBQ0M7UUFDaEIsT0FBT0E7SUFDWDtJQUNBRyxXQUFXQyxFQUFFLEVBQUU7UUFDWCxtR0FBbUc7UUFDbkdBLE1BQU9BLENBQUFBLEtBQUt0QyxPQUFPa0IsTUFBTSxDQUFDbEIsT0FBT3VDLGNBQWMsQ0FBQyxJQUFJLEdBQUcsQ0FBQyxFQUFDO1FBQ3pELE1BQU0sRUFBRVYsS0FBSyxFQUFFWixLQUFLLEVBQUVMLFFBQVEsRUFBRUMsU0FBUyxFQUFFUSxRQUFRLEVBQUVDLFNBQVMsRUFBRSxHQUFHLElBQUk7UUFDdkVnQixLQUFLQTtRQUNMQSxHQUFHMUIsUUFBUSxHQUFHQTtRQUNkMEIsR0FBR3pCLFNBQVMsR0FBR0E7UUFDZnlCLEdBQUdqQixRQUFRLEdBQUdBO1FBQ2RpQixHQUFHaEIsU0FBUyxHQUFHQTtRQUNmZ0IsR0FBR1QsS0FBSyxHQUFHQSxNQUFNUSxVQUFVLENBQUNDLEdBQUdULEtBQUs7UUFDcENTLEdBQUdyQixLQUFLLEdBQUdBLE1BQU1vQixVQUFVLENBQUNDLEdBQUdyQixLQUFLO1FBQ3BDLE9BQU9xQjtJQUNYO0lBQ0FFLFFBQVE7UUFDSixPQUFPLElBQUksQ0FBQ0gsVUFBVTtJQUMxQjtJQUNBRCxVQUFVO1FBQ04sSUFBSSxDQUFDdkIsU0FBUyxHQUFHO1FBQ2pCLElBQUksQ0FBQ2dCLEtBQUssQ0FBQ08sT0FBTztRQUNsQixJQUFJLENBQUNuQixLQUFLLENBQUNtQixPQUFPO0lBQ3RCO0FBQ0o7QUFDQWxDLFlBQVksR0FBR0c7QUFDZjs7Ozs7Ozs7O0NBU0MsR0FDRCxNQUFNRCxPQUFPLENBQUNNLE1BQU1LLEtBQUswQixVQUFZLElBQUlwQyxLQUFLSyxNQUFNSyxLQUFLSSxNQUFNLENBQUNzQixTQUFTZCxNQUFNO0FBQy9FekIsWUFBWSxHQUFHRTtBQUNmRixtQkFBbUIsR0FBRyxDQUFDUSxNQUFNSyxNQUFRLElBQUlWLEtBQUtLLE1BQU1LLE1BQ3BELGdDQUFnQyIsInNvdXJjZXMiOlsid2VicGFjazovL2ZhcmNhc3RlcnN0YXRzLy4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvaG1hYy5qcz9lNDIzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5obWFjID0gZXhwb3J0cy5ITUFDID0gdm9pZCAwO1xuLyoqXG4gKiBITUFDOiBSRkMyMTA0IG1lc3NhZ2UgYXV0aGVudGljYXRpb24gY29kZS5cbiAqIEBtb2R1bGVcbiAqL1xuY29uc3QgdXRpbHNfdHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzLmpzXCIpO1xuY2xhc3MgSE1BQyBleHRlbmRzIHV0aWxzX3RzXzEuSGFzaCB7XG4gICAgY29uc3RydWN0b3IoaGFzaCwgX2tleSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgICAgICgwLCB1dGlsc190c18xLmFoYXNoKShoYXNoKTtcbiAgICAgICAgY29uc3Qga2V5ID0gKDAsIHV0aWxzX3RzXzEudG9CeXRlcykoX2tleSk7XG4gICAgICAgIHRoaXMuaUhhc2ggPSBoYXNoLmNyZWF0ZSgpO1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuaUhhc2gudXBkYXRlICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBpbnN0YW5jZSBvZiBjbGFzcyB3aGljaCBleHRlbmRzIHV0aWxzLkhhc2gnKTtcbiAgICAgICAgdGhpcy5ibG9ja0xlbiA9IHRoaXMuaUhhc2guYmxvY2tMZW47XG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gdGhpcy5pSGFzaC5vdXRwdXRMZW47XG4gICAgICAgIGNvbnN0IGJsb2NrTGVuID0gdGhpcy5ibG9ja0xlbjtcbiAgICAgICAgY29uc3QgcGFkID0gbmV3IFVpbnQ4QXJyYXkoYmxvY2tMZW4pO1xuICAgICAgICAvLyBibG9ja0xlbiBjYW4gYmUgYmlnZ2VyIHRoYW4gb3V0cHV0TGVuXG4gICAgICAgIHBhZC5zZXQoa2V5Lmxlbmd0aCA+IGJsb2NrTGVuID8gaGFzaC5jcmVhdGUoKS51cGRhdGUoa2V5KS5kaWdlc3QoKSA6IGtleSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFkLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgcGFkW2ldIF49IDB4MzY7XG4gICAgICAgIHRoaXMuaUhhc2gudXBkYXRlKHBhZCk7XG4gICAgICAgIC8vIEJ5IGRvaW5nIHVwZGF0ZSAocHJvY2Vzc2luZyBvZiBmaXJzdCBibG9jaykgb2Ygb3V0ZXIgaGFzaCBoZXJlIHdlIGNhbiByZS11c2UgaXQgYmV0d2VlbiBtdWx0aXBsZSBjYWxscyB2aWEgY2xvbmVcbiAgICAgICAgdGhpcy5vSGFzaCA9IGhhc2guY3JlYXRlKCk7XG4gICAgICAgIC8vIFVuZG8gaW50ZXJuYWwgWE9SICYmIGFwcGx5IG91dGVyIFhPUlxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhZC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHBhZFtpXSBePSAweDM2IF4gMHg1YztcbiAgICAgICAgdGhpcy5vSGFzaC51cGRhdGUocGFkKTtcbiAgICAgICAgKDAsIHV0aWxzX3RzXzEuY2xlYW4pKHBhZCk7XG4gICAgfVxuICAgIHVwZGF0ZShidWYpIHtcbiAgICAgICAgKDAsIHV0aWxzX3RzXzEuYWV4aXN0cykodGhpcyk7XG4gICAgICAgIHRoaXMuaUhhc2gudXBkYXRlKGJ1Zik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkaWdlc3RJbnRvKG91dCkge1xuICAgICAgICAoMCwgdXRpbHNfdHNfMS5hZXhpc3RzKSh0aGlzKTtcbiAgICAgICAgKDAsIHV0aWxzX3RzXzEuYWJ5dGVzKShvdXQsIHRoaXMub3V0cHV0TGVuKTtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuaUhhc2guZGlnZXN0SW50byhvdXQpO1xuICAgICAgICB0aGlzLm9IYXNoLnVwZGF0ZShvdXQpO1xuICAgICAgICB0aGlzLm9IYXNoLmRpZ2VzdEludG8ob3V0KTtcbiAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgfVxuICAgIGRpZ2VzdCgpIHtcbiAgICAgICAgY29uc3Qgb3V0ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5vSGFzaC5vdXRwdXRMZW4pO1xuICAgICAgICB0aGlzLmRpZ2VzdEludG8ob3V0KTtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgX2Nsb25lSW50byh0bykge1xuICAgICAgICAvLyBDcmVhdGUgbmV3IGluc3RhbmNlIHdpdGhvdXQgY2FsbGluZyBjb25zdHJ1Y3RvciBzaW5jZSBrZXkgYWxyZWFkeSBpbiBzdGF0ZSBhbmQgd2UgZG9uJ3Qga25vdyBpdC5cbiAgICAgICAgdG8gfHwgKHRvID0gT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcyksIHt9KSk7XG4gICAgICAgIGNvbnN0IHsgb0hhc2gsIGlIYXNoLCBmaW5pc2hlZCwgZGVzdHJveWVkLCBibG9ja0xlbiwgb3V0cHV0TGVuIH0gPSB0aGlzO1xuICAgICAgICB0byA9IHRvO1xuICAgICAgICB0by5maW5pc2hlZCA9IGZpbmlzaGVkO1xuICAgICAgICB0by5kZXN0cm95ZWQgPSBkZXN0cm95ZWQ7XG4gICAgICAgIHRvLmJsb2NrTGVuID0gYmxvY2tMZW47XG4gICAgICAgIHRvLm91dHB1dExlbiA9IG91dHB1dExlbjtcbiAgICAgICAgdG8ub0hhc2ggPSBvSGFzaC5fY2xvbmVJbnRvKHRvLm9IYXNoKTtcbiAgICAgICAgdG8uaUhhc2ggPSBpSGFzaC5fY2xvbmVJbnRvKHRvLmlIYXNoKTtcbiAgICAgICAgcmV0dXJuIHRvO1xuICAgIH1cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Nsb25lSW50bygpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgICAgIHRoaXMub0hhc2guZGVzdHJveSgpO1xuICAgICAgICB0aGlzLmlIYXNoLmRlc3Ryb3koKTtcbiAgICB9XG59XG5leHBvcnRzLkhNQUMgPSBITUFDO1xuLyoqXG4gKiBITUFDOiBSRkMyMTA0IG1lc3NhZ2UgYXV0aGVudGljYXRpb24gY29kZS5cbiAqIEBwYXJhbSBoYXNoIC0gZnVuY3Rpb24gdGhhdCB3b3VsZCBiZSB1c2VkIGUuZy4gc2hhMjU2XG4gKiBAcGFyYW0ga2V5IC0gbWVzc2FnZSBrZXlcbiAqIEBwYXJhbSBtZXNzYWdlIC0gbWVzc2FnZSBkYXRhXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgaG1hYyB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvaG1hYyc7XG4gKiBpbXBvcnQgeyBzaGEyNTYgfSBmcm9tICdAbm9ibGUvaGFzaGVzL3NoYTInO1xuICogY29uc3QgbWFjMSA9IGhtYWMoc2hhMjU2LCAna2V5JywgJ21lc3NhZ2UnKTtcbiAqL1xuY29uc3QgaG1hYyA9IChoYXNoLCBrZXksIG1lc3NhZ2UpID0+IG5ldyBITUFDKGhhc2gsIGtleSkudXBkYXRlKG1lc3NhZ2UpLmRpZ2VzdCgpO1xuZXhwb3J0cy5obWFjID0gaG1hYztcbmV4cG9ydHMuaG1hYy5jcmVhdGUgPSAoaGFzaCwga2V5KSA9PiBuZXcgSE1BQyhoYXNoLCBrZXkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aG1hYy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJobWFjIiwiSE1BQyIsInV0aWxzX3RzXzEiLCJyZXF1aXJlIiwiSGFzaCIsImNvbnN0cnVjdG9yIiwiaGFzaCIsIl9rZXkiLCJmaW5pc2hlZCIsImRlc3Ryb3llZCIsImFoYXNoIiwia2V5IiwidG9CeXRlcyIsImlIYXNoIiwiY3JlYXRlIiwidXBkYXRlIiwiRXJyb3IiLCJibG9ja0xlbiIsIm91dHB1dExlbiIsInBhZCIsIlVpbnQ4QXJyYXkiLCJzZXQiLCJsZW5ndGgiLCJkaWdlc3QiLCJpIiwib0hhc2giLCJjbGVhbiIsImJ1ZiIsImFleGlzdHMiLCJkaWdlc3RJbnRvIiwib3V0IiwiYWJ5dGVzIiwiZGVzdHJveSIsIl9jbG9uZUludG8iLCJ0byIsImdldFByb3RvdHlwZU9mIiwiY2xvbmUiLCJtZXNzYWdlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@noble/hashes/hmac.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@noble/hashes/legacy.js":
/*!**********************************************!*\
  !*** ./node_modules/@noble/hashes/legacy.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.ripemd160 = exports.RIPEMD160 = exports.md5 = exports.MD5 = exports.sha1 = exports.SHA1 = void 0;\n/**\n\nSHA1 (RFC 3174), MD5 (RFC 1321) and RIPEMD160 (RFC 2286) legacy, weak hash functions.\nDon't use them in a new protocol. What \"weak\" means:\n\n- Collisions can be made with 2^18 effort in MD5, 2^60 in SHA1, 2^80 in RIPEMD160.\n- No practical pre-image attacks (only theoretical, 2^123.4)\n- HMAC seems kinda ok: https://datatracker.ietf.org/doc/html/rfc6151\n * @module\n */ const _md_ts_1 = __webpack_require__(/*! ./_md.js */ \"(rsc)/./node_modules/@noble/hashes/_md.js\");\nconst utils_ts_1 = __webpack_require__(/*! ./utils.js */ \"(rsc)/./node_modules/@noble/hashes/utils.js\");\n/** Initial SHA1 state */ const SHA1_IV = /* @__PURE__ */ Uint32Array.from([\n    0x67452301,\n    0xefcdab89,\n    0x98badcfe,\n    0x10325476,\n    0xc3d2e1f0\n]);\n// Reusable temporary buffer\nconst SHA1_W = /* @__PURE__ */ new Uint32Array(80);\n/** SHA1 legacy hash class. */ class SHA1 extends _md_ts_1.HashMD {\n    constructor(){\n        super(64, 20, 8, false);\n        this.A = SHA1_IV[0] | 0;\n        this.B = SHA1_IV[1] | 0;\n        this.C = SHA1_IV[2] | 0;\n        this.D = SHA1_IV[3] | 0;\n        this.E = SHA1_IV[4] | 0;\n    }\n    get() {\n        const { A, B, C, D, E } = this;\n        return [\n            A,\n            B,\n            C,\n            D,\n            E\n        ];\n    }\n    set(A, B, C, D, E) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n    }\n    process(view, offset) {\n        for(let i = 0; i < 16; i++, offset += 4)SHA1_W[i] = view.getUint32(offset, false);\n        for(let i = 16; i < 80; i++)SHA1_W[i] = (0, utils_ts_1.rotl)(SHA1_W[i - 3] ^ SHA1_W[i - 8] ^ SHA1_W[i - 14] ^ SHA1_W[i - 16], 1);\n        // Compression function main loop, 80 rounds\n        let { A, B, C, D, E } = this;\n        for(let i = 0; i < 80; i++){\n            let F, K;\n            if (i < 20) {\n                F = (0, _md_ts_1.Chi)(B, C, D);\n                K = 0x5a827999;\n            } else if (i < 40) {\n                F = B ^ C ^ D;\n                K = 0x6ed9eba1;\n            } else if (i < 60) {\n                F = (0, _md_ts_1.Maj)(B, C, D);\n                K = 0x8f1bbcdc;\n            } else {\n                F = B ^ C ^ D;\n                K = 0xca62c1d6;\n            }\n            const T = (0, utils_ts_1.rotl)(A, 5) + F + E + K + SHA1_W[i] | 0;\n            E = D;\n            D = C;\n            C = (0, utils_ts_1.rotl)(B, 30);\n            B = A;\n            A = T;\n        }\n        // Add the compressed chunk to the current hash value\n        A = A + this.A | 0;\n        B = B + this.B | 0;\n        C = C + this.C | 0;\n        D = D + this.D | 0;\n        E = E + this.E | 0;\n        this.set(A, B, C, D, E);\n    }\n    roundClean() {\n        (0, utils_ts_1.clean)(SHA1_W);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0);\n        (0, utils_ts_1.clean)(this.buffer);\n    }\n}\nexports.SHA1 = SHA1;\n/** SHA1 (RFC 3174) legacy hash function. It was cryptographically broken. */ exports.sha1 = (0, utils_ts_1.createHasher)(()=>new SHA1());\n/** Per-round constants */ const p32 = /* @__PURE__ */ Math.pow(2, 32);\nconst K = /* @__PURE__ */ Array.from({\n    length: 64\n}, (_, i)=>Math.floor(p32 * Math.abs(Math.sin(i + 1))));\n/** md5 initial state: same as sha1, but 4 u32 instead of 5. */ const MD5_IV = /* @__PURE__ */ SHA1_IV.slice(0, 4);\n// Reusable temporary buffer\nconst MD5_W = /* @__PURE__ */ new Uint32Array(16);\n/** MD5 legacy hash class. */ class MD5 extends _md_ts_1.HashMD {\n    constructor(){\n        super(64, 16, 8, true);\n        this.A = MD5_IV[0] | 0;\n        this.B = MD5_IV[1] | 0;\n        this.C = MD5_IV[2] | 0;\n        this.D = MD5_IV[3] | 0;\n    }\n    get() {\n        const { A, B, C, D } = this;\n        return [\n            A,\n            B,\n            C,\n            D\n        ];\n    }\n    set(A, B, C, D) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n    }\n    process(view, offset) {\n        for(let i = 0; i < 16; i++, offset += 4)MD5_W[i] = view.getUint32(offset, true);\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D } = this;\n        for(let i = 0; i < 64; i++){\n            let F, g, s;\n            if (i < 16) {\n                F = (0, _md_ts_1.Chi)(B, C, D);\n                g = i;\n                s = [\n                    7,\n                    12,\n                    17,\n                    22\n                ];\n            } else if (i < 32) {\n                F = (0, _md_ts_1.Chi)(D, B, C);\n                g = (5 * i + 1) % 16;\n                s = [\n                    5,\n                    9,\n                    14,\n                    20\n                ];\n            } else if (i < 48) {\n                F = B ^ C ^ D;\n                g = (3 * i + 5) % 16;\n                s = [\n                    4,\n                    11,\n                    16,\n                    23\n                ];\n            } else {\n                F = C ^ (B | ~D);\n                g = 7 * i % 16;\n                s = [\n                    6,\n                    10,\n                    15,\n                    21\n                ];\n            }\n            F = F + A + K[i] + MD5_W[g];\n            A = D;\n            D = C;\n            C = B;\n            B = B + (0, utils_ts_1.rotl)(F, s[i % 4]);\n        }\n        // Add the compressed chunk to the current hash value\n        A = A + this.A | 0;\n        B = B + this.B | 0;\n        C = C + this.C | 0;\n        D = D + this.D | 0;\n        this.set(A, B, C, D);\n    }\n    roundClean() {\n        (0, utils_ts_1.clean)(MD5_W);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0);\n        (0, utils_ts_1.clean)(this.buffer);\n    }\n}\nexports.MD5 = MD5;\n/**\n * MD5 (RFC 1321) legacy hash function. It was cryptographically broken.\n * MD5 architecture is similar to SHA1, with some differences:\n * - Reduced output length: 16 bytes (128 bit) instead of 20\n * - 64 rounds, instead of 80\n * - Little-endian: could be faster, but will require more code\n * - Non-linear index selection: huge speed-up for unroll\n * - Per round constants: more memory accesses, additional speed-up for unroll\n */ exports.md5 = (0, utils_ts_1.createHasher)(()=>new MD5());\n// RIPEMD-160\nconst Rho160 = /* @__PURE__ */ Uint8Array.from([\n    7,\n    4,\n    13,\n    1,\n    10,\n    6,\n    15,\n    3,\n    12,\n    0,\n    9,\n    5,\n    2,\n    14,\n    11,\n    8\n]);\nconst Id160 = /* @__PURE__ */ (()=>Uint8Array.from(new Array(16).fill(0).map((_, i)=>i)))();\nconst Pi160 = /* @__PURE__ */ (()=>Id160.map((i)=>(9 * i + 5) % 16))();\nconst idxLR = /* @__PURE__ */ (()=>{\n    const L = [\n        Id160\n    ];\n    const R = [\n        Pi160\n    ];\n    const res = [\n        L,\n        R\n    ];\n    for(let i = 0; i < 4; i++)for (let j of res)j.push(j[i].map((k)=>Rho160[k]));\n    return res;\n})();\nconst idxL = /* @__PURE__ */ (()=>idxLR[0])();\nconst idxR = /* @__PURE__ */ (()=>idxLR[1])();\n// const [idxL, idxR] = idxLR;\nconst shifts160 = /* @__PURE__ */ [\n    [\n        11,\n        14,\n        15,\n        12,\n        5,\n        8,\n        7,\n        9,\n        11,\n        13,\n        14,\n        15,\n        6,\n        7,\n        9,\n        8\n    ],\n    [\n        12,\n        13,\n        11,\n        15,\n        6,\n        9,\n        9,\n        7,\n        12,\n        15,\n        11,\n        13,\n        7,\n        8,\n        7,\n        7\n    ],\n    [\n        13,\n        15,\n        14,\n        11,\n        7,\n        7,\n        6,\n        8,\n        13,\n        14,\n        13,\n        12,\n        5,\n        5,\n        6,\n        9\n    ],\n    [\n        14,\n        11,\n        12,\n        14,\n        8,\n        6,\n        5,\n        5,\n        15,\n        12,\n        15,\n        14,\n        9,\n        9,\n        8,\n        6\n    ],\n    [\n        15,\n        12,\n        13,\n        13,\n        9,\n        5,\n        8,\n        6,\n        14,\n        11,\n        12,\n        11,\n        8,\n        6,\n        5,\n        5\n    ]\n].map((i)=>Uint8Array.from(i));\nconst shiftsL160 = /* @__PURE__ */ idxL.map((idx, i)=>idx.map((j)=>shifts160[i][j]));\nconst shiftsR160 = /* @__PURE__ */ idxR.map((idx, i)=>idx.map((j)=>shifts160[i][j]));\nconst Kl160 = /* @__PURE__ */ Uint32Array.from([\n    0x00000000,\n    0x5a827999,\n    0x6ed9eba1,\n    0x8f1bbcdc,\n    0xa953fd4e\n]);\nconst Kr160 = /* @__PURE__ */ Uint32Array.from([\n    0x50a28be6,\n    0x5c4dd124,\n    0x6d703ef3,\n    0x7a6d76e9,\n    0x00000000\n]);\n// It's called f() in spec.\nfunction ripemd_f(group, x, y, z) {\n    if (group === 0) return x ^ y ^ z;\n    if (group === 1) return x & y | ~x & z;\n    if (group === 2) return (x | ~y) ^ z;\n    if (group === 3) return x & z | y & ~z;\n    return x ^ (y | ~z);\n}\n// Reusable temporary buffer\nconst BUF_160 = /* @__PURE__ */ new Uint32Array(16);\nclass RIPEMD160 extends _md_ts_1.HashMD {\n    constructor(){\n        super(64, 20, 8, true);\n        this.h0 = 0x67452301 | 0;\n        this.h1 = 0xefcdab89 | 0;\n        this.h2 = 0x98badcfe | 0;\n        this.h3 = 0x10325476 | 0;\n        this.h4 = 0xc3d2e1f0 | 0;\n    }\n    get() {\n        const { h0, h1, h2, h3, h4 } = this;\n        return [\n            h0,\n            h1,\n            h2,\n            h3,\n            h4\n        ];\n    }\n    set(h0, h1, h2, h3, h4) {\n        this.h0 = h0 | 0;\n        this.h1 = h1 | 0;\n        this.h2 = h2 | 0;\n        this.h3 = h3 | 0;\n        this.h4 = h4 | 0;\n    }\n    process(view, offset) {\n        for(let i = 0; i < 16; i++, offset += 4)BUF_160[i] = view.getUint32(offset, true);\n        // prettier-ignore\n        let al = this.h0 | 0, ar = al, bl = this.h1 | 0, br = bl, cl = this.h2 | 0, cr = cl, dl = this.h3 | 0, dr = dl, el = this.h4 | 0, er = el;\n        // Instead of iterating 0 to 80, we split it into 5 groups\n        // And use the groups in constants, functions, etc. Much simpler\n        for(let group = 0; group < 5; group++){\n            const rGroup = 4 - group;\n            const hbl = Kl160[group], hbr = Kr160[group]; // prettier-ignore\n            const rl = idxL[group], rr = idxR[group]; // prettier-ignore\n            const sl = shiftsL160[group], sr = shiftsR160[group]; // prettier-ignore\n            for(let i = 0; i < 16; i++){\n                const tl = (0, utils_ts_1.rotl)(al + ripemd_f(group, bl, cl, dl) + BUF_160[rl[i]] + hbl, sl[i]) + el | 0;\n                al = el, el = dl, dl = (0, utils_ts_1.rotl)(cl, 10) | 0, cl = bl, bl = tl; // prettier-ignore\n            }\n            // 2 loops are 10% faster\n            for(let i = 0; i < 16; i++){\n                const tr = (0, utils_ts_1.rotl)(ar + ripemd_f(rGroup, br, cr, dr) + BUF_160[rr[i]] + hbr, sr[i]) + er | 0;\n                ar = er, er = dr, dr = (0, utils_ts_1.rotl)(cr, 10) | 0, cr = br, br = tr; // prettier-ignore\n            }\n        }\n        // Add the compressed chunk to the current hash value\n        this.set(this.h1 + cl + dr | 0, this.h2 + dl + er | 0, this.h3 + el + ar | 0, this.h4 + al + br | 0, this.h0 + bl + cr | 0);\n    }\n    roundClean() {\n        (0, utils_ts_1.clean)(BUF_160);\n    }\n    destroy() {\n        this.destroyed = true;\n        (0, utils_ts_1.clean)(this.buffer);\n        this.set(0, 0, 0, 0, 0);\n    }\n}\nexports.RIPEMD160 = RIPEMD160;\n/**\n * RIPEMD-160 - a legacy hash function from 1990s.\n * * https://homes.esat.kuleuven.be/~bosselae/ripemd160.html\n * * https://homes.esat.kuleuven.be/~bosselae/ripemd160/pdf/AB-9601/AB-9601.pdf\n */ exports.ripemd160 = (0, utils_ts_1.createHasher)(()=>new RIPEMD160()); //# sourceMappingURL=legacy.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9sZWdhY3kuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGlCQUFpQixHQUFHQSxpQkFBaUIsR0FBR0EsV0FBVyxHQUFHQSxXQUFXLEdBQUdBLFlBQVksR0FBR0EsWUFBWSxHQUFHLEtBQUs7QUFDdkc7Ozs7Ozs7OztDQVNDLEdBQ0QsTUFBTVEsV0FBV0MsbUJBQU9BLENBQUMsMkRBQVU7QUFDbkMsTUFBTUMsYUFBYUQsbUJBQU9BLENBQUMsK0RBQVk7QUFDdkMsdUJBQXVCLEdBQ3ZCLE1BQU1FLFVBQVUsYUFBYSxHQUFHQyxZQUFZQyxJQUFJLENBQUM7SUFDN0M7SUFBWTtJQUFZO0lBQVk7SUFBWTtDQUNuRDtBQUNELDRCQUE0QjtBQUM1QixNQUFNQyxTQUFTLGFBQWEsR0FBRyxJQUFJRixZQUFZO0FBQy9DLDRCQUE0QixHQUM1QixNQUFNTCxhQUFhQyxTQUFTTyxNQUFNO0lBQzlCQyxhQUFjO1FBQ1YsS0FBSyxDQUFDLElBQUksSUFBSSxHQUFHO1FBQ2pCLElBQUksQ0FBQ0MsQ0FBQyxHQUFHTixPQUFPLENBQUMsRUFBRSxHQUFHO1FBQ3RCLElBQUksQ0FBQ08sQ0FBQyxHQUFHUCxPQUFPLENBQUMsRUFBRSxHQUFHO1FBQ3RCLElBQUksQ0FBQ1EsQ0FBQyxHQUFHUixPQUFPLENBQUMsRUFBRSxHQUFHO1FBQ3RCLElBQUksQ0FBQ1MsQ0FBQyxHQUFHVCxPQUFPLENBQUMsRUFBRSxHQUFHO1FBQ3RCLElBQUksQ0FBQ1UsQ0FBQyxHQUFHVixPQUFPLENBQUMsRUFBRSxHQUFHO0lBQzFCO0lBQ0FXLE1BQU07UUFDRixNQUFNLEVBQUVMLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBQyxFQUFFLEdBQUcsSUFBSTtRQUM5QixPQUFPO1lBQUNKO1lBQUdDO1lBQUdDO1lBQUdDO1lBQUdDO1NBQUU7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RixJQUFJQSxLQUFLLENBQUMsR0FBR25GLFdBQVdtQixJQUFJLEVBQUU4RCxJQUFJLE1BQU0sR0FBR0EsS0FBS0YsSUFBSUEsS0FBS2UsSUFBSSxrQkFBa0I7WUFDakc7UUFDSjtRQUNBLHFEQUFxRDtRQUNyRCxJQUFJLENBQUNqRixHQUFHLENBQUMsSUFBSyxDQUFDMkQsRUFBRSxHQUFHUSxLQUFLRyxLQUFNLEdBQUcsSUFBSyxDQUFDVixFQUFFLEdBQUdTLEtBQUtHLEtBQU0sR0FBRyxJQUFLLENBQUNYLEVBQUUsR0FBR1UsS0FBS1AsS0FBTSxHQUFHLElBQUssQ0FBQ0YsRUFBRSxHQUFHQyxLQUFLRyxLQUFNLEdBQUcsSUFBSyxDQUFDUixFQUFFLEdBQUdPLEtBQUtHLEtBQU07SUFDdkk7SUFDQXhELGFBQWE7UUFDUixJQUFHekIsV0FBVzBCLEtBQUssRUFBRTRDO0lBQzFCO0lBQ0EzQyxVQUFVO1FBQ04sSUFBSSxDQUFDb0UsU0FBUyxHQUFHO1FBQ2hCLElBQUcvRixXQUFXMEIsS0FBSyxFQUFFLElBQUksQ0FBQ0UsTUFBTTtRQUNqQyxJQUFJLENBQUNmLEdBQUcsQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHO0lBQ3pCO0FBQ0o7QUFDQXZCLGlCQUFpQixHQUFHRztBQUNwQjs7OztDQUlDLEdBQ0RILGlCQUFpQixHQUFHLENBQUMsR0FBR1UsV0FBVzZCLFlBQVksRUFBRSxJQUFNLElBQUlwQyxjQUMzRCxrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mYXJjYXN0ZXJzdGF0cy8uL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2xlZ2FjeS5qcz9hMDM0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5yaXBlbWQxNjAgPSBleHBvcnRzLlJJUEVNRDE2MCA9IGV4cG9ydHMubWQ1ID0gZXhwb3J0cy5NRDUgPSBleHBvcnRzLnNoYTEgPSBleHBvcnRzLlNIQTEgPSB2b2lkIDA7XG4vKipcblxuU0hBMSAoUkZDIDMxNzQpLCBNRDUgKFJGQyAxMzIxKSBhbmQgUklQRU1EMTYwIChSRkMgMjI4NikgbGVnYWN5LCB3ZWFrIGhhc2ggZnVuY3Rpb25zLlxuRG9uJ3QgdXNlIHRoZW0gaW4gYSBuZXcgcHJvdG9jb2wuIFdoYXQgXCJ3ZWFrXCIgbWVhbnM6XG5cbi0gQ29sbGlzaW9ucyBjYW4gYmUgbWFkZSB3aXRoIDJeMTggZWZmb3J0IGluIE1ENSwgMl42MCBpbiBTSEExLCAyXjgwIGluIFJJUEVNRDE2MC5cbi0gTm8gcHJhY3RpY2FsIHByZS1pbWFnZSBhdHRhY2tzIChvbmx5IHRoZW9yZXRpY2FsLCAyXjEyMy40KVxuLSBITUFDIHNlZW1zIGtpbmRhIG9rOiBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL3JmYzYxNTFcbiAqIEBtb2R1bGVcbiAqL1xuY29uc3QgX21kX3RzXzEgPSByZXF1aXJlKFwiLi9fbWQuanNcIik7XG5jb25zdCB1dGlsc190c18xID0gcmVxdWlyZShcIi4vdXRpbHMuanNcIik7XG4vKiogSW5pdGlhbCBTSEExIHN0YXRlICovXG5jb25zdCBTSEExX0lWID0gLyogQF9fUFVSRV9fICovIFVpbnQzMkFycmF5LmZyb20oW1xuICAgIDB4Njc0NTIzMDEsIDB4ZWZjZGFiODksIDB4OThiYWRjZmUsIDB4MTAzMjU0NzYsIDB4YzNkMmUxZjAsXG5dKTtcbi8vIFJldXNhYmxlIHRlbXBvcmFyeSBidWZmZXJcbmNvbnN0IFNIQTFfVyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDMyQXJyYXkoODApO1xuLyoqIFNIQTEgbGVnYWN5IGhhc2ggY2xhc3MuICovXG5jbGFzcyBTSEExIGV4dGVuZHMgX21kX3RzXzEuSGFzaE1EIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoNjQsIDIwLCA4LCBmYWxzZSk7XG4gICAgICAgIHRoaXMuQSA9IFNIQTFfSVZbMF0gfCAwO1xuICAgICAgICB0aGlzLkIgPSBTSEExX0lWWzFdIHwgMDtcbiAgICAgICAgdGhpcy5DID0gU0hBMV9JVlsyXSB8IDA7XG4gICAgICAgIHRoaXMuRCA9IFNIQTFfSVZbM10gfCAwO1xuICAgICAgICB0aGlzLkUgPSBTSEExX0lWWzRdIHwgMDtcbiAgICB9XG4gICAgZ2V0KCkge1xuICAgICAgICBjb25zdCB7IEEsIEIsIEMsIEQsIEUgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBbQSwgQiwgQywgRCwgRV07XG4gICAgfVxuICAgIHNldChBLCBCLCBDLCBELCBFKSB7XG4gICAgICAgIHRoaXMuQSA9IEEgfCAwO1xuICAgICAgICB0aGlzLkIgPSBCIHwgMDtcbiAgICAgICAgdGhpcy5DID0gQyB8IDA7XG4gICAgICAgIHRoaXMuRCA9IEQgfCAwO1xuICAgICAgICB0aGlzLkUgPSBFIHwgMDtcbiAgICB9XG4gICAgcHJvY2Vzcyh2aWV3LCBvZmZzZXQpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrLCBvZmZzZXQgKz0gNClcbiAgICAgICAgICAgIFNIQTFfV1tpXSA9IHZpZXcuZ2V0VWludDMyKG9mZnNldCwgZmFsc2UpO1xuICAgICAgICBmb3IgKGxldCBpID0gMTY7IGkgPCA4MDsgaSsrKVxuICAgICAgICAgICAgU0hBMV9XW2ldID0gKDAsIHV0aWxzX3RzXzEucm90bCkoU0hBMV9XW2kgLSAzXSBeIFNIQTFfV1tpIC0gOF0gXiBTSEExX1dbaSAtIDE0XSBeIFNIQTFfV1tpIC0gMTZdLCAxKTtcbiAgICAgICAgLy8gQ29tcHJlc3Npb24gZnVuY3Rpb24gbWFpbiBsb29wLCA4MCByb3VuZHNcbiAgICAgICAgbGV0IHsgQSwgQiwgQywgRCwgRSB9ID0gdGhpcztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA4MDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgRiwgSztcbiAgICAgICAgICAgIGlmIChpIDwgMjApIHtcbiAgICAgICAgICAgICAgICBGID0gKDAsIF9tZF90c18xLkNoaSkoQiwgQywgRCk7XG4gICAgICAgICAgICAgICAgSyA9IDB4NWE4Mjc5OTk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpIDwgNDApIHtcbiAgICAgICAgICAgICAgICBGID0gQiBeIEMgXiBEO1xuICAgICAgICAgICAgICAgIEsgPSAweDZlZDllYmExO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaSA8IDYwKSB7XG4gICAgICAgICAgICAgICAgRiA9ICgwLCBfbWRfdHNfMS5NYWopKEIsIEMsIEQpO1xuICAgICAgICAgICAgICAgIEsgPSAweDhmMWJiY2RjO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgRiA9IEIgXiBDIF4gRDtcbiAgICAgICAgICAgICAgICBLID0gMHhjYTYyYzFkNjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IFQgPSAoKDAsIHV0aWxzX3RzXzEucm90bCkoQSwgNSkgKyBGICsgRSArIEsgKyBTSEExX1dbaV0pIHwgMDtcbiAgICAgICAgICAgIEUgPSBEO1xuICAgICAgICAgICAgRCA9IEM7XG4gICAgICAgICAgICBDID0gKDAsIHV0aWxzX3RzXzEucm90bCkoQiwgMzApO1xuICAgICAgICAgICAgQiA9IEE7XG4gICAgICAgICAgICBBID0gVDtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgdGhlIGNvbXByZXNzZWQgY2h1bmsgdG8gdGhlIGN1cnJlbnQgaGFzaCB2YWx1ZVxuICAgICAgICBBID0gKEEgKyB0aGlzLkEpIHwgMDtcbiAgICAgICAgQiA9IChCICsgdGhpcy5CKSB8IDA7XG4gICAgICAgIEMgPSAoQyArIHRoaXMuQykgfCAwO1xuICAgICAgICBEID0gKEQgKyB0aGlzLkQpIHwgMDtcbiAgICAgICAgRSA9IChFICsgdGhpcy5FKSB8IDA7XG4gICAgICAgIHRoaXMuc2V0KEEsIEIsIEMsIEQsIEUpO1xuICAgIH1cbiAgICByb3VuZENsZWFuKCkge1xuICAgICAgICAoMCwgdXRpbHNfdHNfMS5jbGVhbikoU0hBMV9XKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5zZXQoMCwgMCwgMCwgMCwgMCk7XG4gICAgICAgICgwLCB1dGlsc190c18xLmNsZWFuKSh0aGlzLmJ1ZmZlcik7XG4gICAgfVxufVxuZXhwb3J0cy5TSEExID0gU0hBMTtcbi8qKiBTSEExIChSRkMgMzE3NCkgbGVnYWN5IGhhc2ggZnVuY3Rpb24uIEl0IHdhcyBjcnlwdG9ncmFwaGljYWxseSBicm9rZW4uICovXG5leHBvcnRzLnNoYTEgPSAoMCwgdXRpbHNfdHNfMS5jcmVhdGVIYXNoZXIpKCgpID0+IG5ldyBTSEExKCkpO1xuLyoqIFBlci1yb3VuZCBjb25zdGFudHMgKi9cbmNvbnN0IHAzMiA9IC8qIEBfX1BVUkVfXyAqLyBNYXRoLnBvdygyLCAzMik7XG5jb25zdCBLID0gLyogQF9fUFVSRV9fICovIEFycmF5LmZyb20oeyBsZW5ndGg6IDY0IH0sIChfLCBpKSA9PiBNYXRoLmZsb29yKHAzMiAqIE1hdGguYWJzKE1hdGguc2luKGkgKyAxKSkpKTtcbi8qKiBtZDUgaW5pdGlhbCBzdGF0ZTogc2FtZSBhcyBzaGExLCBidXQgNCB1MzIgaW5zdGVhZCBvZiA1LiAqL1xuY29uc3QgTUQ1X0lWID0gLyogQF9fUFVSRV9fICovIFNIQTFfSVYuc2xpY2UoMCwgNCk7XG4vLyBSZXVzYWJsZSB0ZW1wb3JhcnkgYnVmZmVyXG5jb25zdCBNRDVfVyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDMyQXJyYXkoMTYpO1xuLyoqIE1ENSBsZWdhY3kgaGFzaCBjbGFzcy4gKi9cbmNsYXNzIE1ENSBleHRlbmRzIF9tZF90c18xLkhhc2hNRCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKDY0LCAxNiwgOCwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuQSA9IE1ENV9JVlswXSB8IDA7XG4gICAgICAgIHRoaXMuQiA9IE1ENV9JVlsxXSB8IDA7XG4gICAgICAgIHRoaXMuQyA9IE1ENV9JVlsyXSB8IDA7XG4gICAgICAgIHRoaXMuRCA9IE1ENV9JVlszXSB8IDA7XG4gICAgfVxuICAgIGdldCgpIHtcbiAgICAgICAgY29uc3QgeyBBLCBCLCBDLCBEIH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gW0EsIEIsIEMsIERdO1xuICAgIH1cbiAgICBzZXQoQSwgQiwgQywgRCkge1xuICAgICAgICB0aGlzLkEgPSBBIHwgMDtcbiAgICAgICAgdGhpcy5CID0gQiB8IDA7XG4gICAgICAgIHRoaXMuQyA9IEMgfCAwO1xuICAgICAgICB0aGlzLkQgPSBEIHwgMDtcbiAgICB9XG4gICAgcHJvY2Vzcyh2aWV3LCBvZmZzZXQpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrLCBvZmZzZXQgKz0gNClcbiAgICAgICAgICAgIE1ENV9XW2ldID0gdmlldy5nZXRVaW50MzIob2Zmc2V0LCB0cnVlKTtcbiAgICAgICAgLy8gQ29tcHJlc3Npb24gZnVuY3Rpb24gbWFpbiBsb29wLCA2NCByb3VuZHNcbiAgICAgICAgbGV0IHsgQSwgQiwgQywgRCB9ID0gdGhpcztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA2NDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgRiwgZywgcztcbiAgICAgICAgICAgIGlmIChpIDwgMTYpIHtcbiAgICAgICAgICAgICAgICBGID0gKDAsIF9tZF90c18xLkNoaSkoQiwgQywgRCk7XG4gICAgICAgICAgICAgICAgZyA9IGk7XG4gICAgICAgICAgICAgICAgcyA9IFs3LCAxMiwgMTcsIDIyXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGkgPCAzMikge1xuICAgICAgICAgICAgICAgIEYgPSAoMCwgX21kX3RzXzEuQ2hpKShELCBCLCBDKTtcbiAgICAgICAgICAgICAgICBnID0gKDUgKiBpICsgMSkgJSAxNjtcbiAgICAgICAgICAgICAgICBzID0gWzUsIDksIDE0LCAyMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpIDwgNDgpIHtcbiAgICAgICAgICAgICAgICBGID0gQiBeIEMgXiBEO1xuICAgICAgICAgICAgICAgIGcgPSAoMyAqIGkgKyA1KSAlIDE2O1xuICAgICAgICAgICAgICAgIHMgPSBbNCwgMTEsIDE2LCAyM107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBGID0gQyBeIChCIHwgfkQpO1xuICAgICAgICAgICAgICAgIGcgPSAoNyAqIGkpICUgMTY7XG4gICAgICAgICAgICAgICAgcyA9IFs2LCAxMCwgMTUsIDIxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIEYgPSBGICsgQSArIEtbaV0gKyBNRDVfV1tnXTtcbiAgICAgICAgICAgIEEgPSBEO1xuICAgICAgICAgICAgRCA9IEM7XG4gICAgICAgICAgICBDID0gQjtcbiAgICAgICAgICAgIEIgPSBCICsgKDAsIHV0aWxzX3RzXzEucm90bCkoRiwgc1tpICUgNF0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFkZCB0aGUgY29tcHJlc3NlZCBjaHVuayB0byB0aGUgY3VycmVudCBoYXNoIHZhbHVlXG4gICAgICAgIEEgPSAoQSArIHRoaXMuQSkgfCAwO1xuICAgICAgICBCID0gKEIgKyB0aGlzLkIpIHwgMDtcbiAgICAgICAgQyA9IChDICsgdGhpcy5DKSB8IDA7XG4gICAgICAgIEQgPSAoRCArIHRoaXMuRCkgfCAwO1xuICAgICAgICB0aGlzLnNldChBLCBCLCBDLCBEKTtcbiAgICB9XG4gICAgcm91bmRDbGVhbigpIHtcbiAgICAgICAgKDAsIHV0aWxzX3RzXzEuY2xlYW4pKE1ENV9XKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5zZXQoMCwgMCwgMCwgMCk7XG4gICAgICAgICgwLCB1dGlsc190c18xLmNsZWFuKSh0aGlzLmJ1ZmZlcik7XG4gICAgfVxufVxuZXhwb3J0cy5NRDUgPSBNRDU7XG4vKipcbiAqIE1ENSAoUkZDIDEzMjEpIGxlZ2FjeSBoYXNoIGZ1bmN0aW9uLiBJdCB3YXMgY3J5cHRvZ3JhcGhpY2FsbHkgYnJva2VuLlxuICogTUQ1IGFyY2hpdGVjdHVyZSBpcyBzaW1pbGFyIHRvIFNIQTEsIHdpdGggc29tZSBkaWZmZXJlbmNlczpcbiAqIC0gUmVkdWNlZCBvdXRwdXQgbGVuZ3RoOiAxNiBieXRlcyAoMTI4IGJpdCkgaW5zdGVhZCBvZiAyMFxuICogLSA2NCByb3VuZHMsIGluc3RlYWQgb2YgODBcbiAqIC0gTGl0dGxlLWVuZGlhbjogY291bGQgYmUgZmFzdGVyLCBidXQgd2lsbCByZXF1aXJlIG1vcmUgY29kZVxuICogLSBOb24tbGluZWFyIGluZGV4IHNlbGVjdGlvbjogaHVnZSBzcGVlZC11cCBmb3IgdW5yb2xsXG4gKiAtIFBlciByb3VuZCBjb25zdGFudHM6IG1vcmUgbWVtb3J5IGFjY2Vzc2VzLCBhZGRpdGlvbmFsIHNwZWVkLXVwIGZvciB1bnJvbGxcbiAqL1xuZXhwb3J0cy5tZDUgPSAoMCwgdXRpbHNfdHNfMS5jcmVhdGVIYXNoZXIpKCgpID0+IG5ldyBNRDUoKSk7XG4vLyBSSVBFTUQtMTYwXG5jb25zdCBSaG8xNjAgPSAvKiBAX19QVVJFX18gKi8gVWludDhBcnJheS5mcm9tKFtcbiAgICA3LCA0LCAxMywgMSwgMTAsIDYsIDE1LCAzLCAxMiwgMCwgOSwgNSwgMiwgMTQsIDExLCA4LFxuXSk7XG5jb25zdCBJZDE2MCA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gVWludDhBcnJheS5mcm9tKG5ldyBBcnJheSgxNikuZmlsbCgwKS5tYXAoKF8sIGkpID0+IGkpKSkoKTtcbmNvbnN0IFBpMTYwID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBJZDE2MC5tYXAoKGkpID0+ICg5ICogaSArIDUpICUgMTYpKSgpO1xuY29uc3QgaWR4TFIgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IHtcbiAgICBjb25zdCBMID0gW0lkMTYwXTtcbiAgICBjb25zdCBSID0gW1BpMTYwXTtcbiAgICBjb25zdCByZXMgPSBbTCwgUl07XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpKyspXG4gICAgICAgIGZvciAobGV0IGogb2YgcmVzKVxuICAgICAgICAgICAgai5wdXNoKGpbaV0ubWFwKChrKSA9PiBSaG8xNjBba10pKTtcbiAgICByZXR1cm4gcmVzO1xufSkoKTtcbmNvbnN0IGlkeEwgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IGlkeExSWzBdKSgpO1xuY29uc3QgaWR4UiA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gaWR4TFJbMV0pKCk7XG4vLyBjb25zdCBbaWR4TCwgaWR4Ul0gPSBpZHhMUjtcbmNvbnN0IHNoaWZ0czE2MCA9IC8qIEBfX1BVUkVfXyAqLyBbXG4gICAgWzExLCAxNCwgMTUsIDEyLCA1LCA4LCA3LCA5LCAxMSwgMTMsIDE0LCAxNSwgNiwgNywgOSwgOF0sXG4gICAgWzEyLCAxMywgMTEsIDE1LCA2LCA5LCA5LCA3LCAxMiwgMTUsIDExLCAxMywgNywgOCwgNywgN10sXG4gICAgWzEzLCAxNSwgMTQsIDExLCA3LCA3LCA2LCA4LCAxMywgMTQsIDEzLCAxMiwgNSwgNSwgNiwgOV0sXG4gICAgWzE0LCAxMSwgMTIsIDE0LCA4LCA2LCA1LCA1LCAxNSwgMTIsIDE1LCAxNCwgOSwgOSwgOCwgNl0sXG4gICAgWzE1LCAxMiwgMTMsIDEzLCA5LCA1LCA4LCA2LCAxNCwgMTEsIDEyLCAxMSwgOCwgNiwgNSwgNV0sXG5dLm1hcCgoaSkgPT4gVWludDhBcnJheS5mcm9tKGkpKTtcbmNvbnN0IHNoaWZ0c0wxNjAgPSAvKiBAX19QVVJFX18gKi8gaWR4TC5tYXAoKGlkeCwgaSkgPT4gaWR4Lm1hcCgoaikgPT4gc2hpZnRzMTYwW2ldW2pdKSk7XG5jb25zdCBzaGlmdHNSMTYwID0gLyogQF9fUFVSRV9fICovIGlkeFIubWFwKChpZHgsIGkpID0+IGlkeC5tYXAoKGopID0+IHNoaWZ0czE2MFtpXVtqXSkpO1xuY29uc3QgS2wxNjAgPSAvKiBAX19QVVJFX18gKi8gVWludDMyQXJyYXkuZnJvbShbXG4gICAgMHgwMDAwMDAwMCwgMHg1YTgyNzk5OSwgMHg2ZWQ5ZWJhMSwgMHg4ZjFiYmNkYywgMHhhOTUzZmQ0ZSxcbl0pO1xuY29uc3QgS3IxNjAgPSAvKiBAX19QVVJFX18gKi8gVWludDMyQXJyYXkuZnJvbShbXG4gICAgMHg1MGEyOGJlNiwgMHg1YzRkZDEyNCwgMHg2ZDcwM2VmMywgMHg3YTZkNzZlOSwgMHgwMDAwMDAwMCxcbl0pO1xuLy8gSXQncyBjYWxsZWQgZigpIGluIHNwZWMuXG5mdW5jdGlvbiByaXBlbWRfZihncm91cCwgeCwgeSwgeikge1xuICAgIGlmIChncm91cCA9PT0gMClcbiAgICAgICAgcmV0dXJuIHggXiB5IF4gejtcbiAgICBpZiAoZ3JvdXAgPT09IDEpXG4gICAgICAgIHJldHVybiAoeCAmIHkpIHwgKH54ICYgeik7XG4gICAgaWYgKGdyb3VwID09PSAyKVxuICAgICAgICByZXR1cm4gKHggfCB+eSkgXiB6O1xuICAgIGlmIChncm91cCA9PT0gMylcbiAgICAgICAgcmV0dXJuICh4ICYgeikgfCAoeSAmIH56KTtcbiAgICByZXR1cm4geCBeICh5IHwgfnopO1xufVxuLy8gUmV1c2FibGUgdGVtcG9yYXJ5IGJ1ZmZlclxuY29uc3QgQlVGXzE2MCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDMyQXJyYXkoMTYpO1xuY2xhc3MgUklQRU1EMTYwIGV4dGVuZHMgX21kX3RzXzEuSGFzaE1EIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoNjQsIDIwLCA4LCB0cnVlKTtcbiAgICAgICAgdGhpcy5oMCA9IDB4Njc0NTIzMDEgfCAwO1xuICAgICAgICB0aGlzLmgxID0gMHhlZmNkYWI4OSB8IDA7XG4gICAgICAgIHRoaXMuaDIgPSAweDk4YmFkY2ZlIHwgMDtcbiAgICAgICAgdGhpcy5oMyA9IDB4MTAzMjU0NzYgfCAwO1xuICAgICAgICB0aGlzLmg0ID0gMHhjM2QyZTFmMCB8IDA7XG4gICAgfVxuICAgIGdldCgpIHtcbiAgICAgICAgY29uc3QgeyBoMCwgaDEsIGgyLCBoMywgaDQgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBbaDAsIGgxLCBoMiwgaDMsIGg0XTtcbiAgICB9XG4gICAgc2V0KGgwLCBoMSwgaDIsIGgzLCBoNCkge1xuICAgICAgICB0aGlzLmgwID0gaDAgfCAwO1xuICAgICAgICB0aGlzLmgxID0gaDEgfCAwO1xuICAgICAgICB0aGlzLmgyID0gaDIgfCAwO1xuICAgICAgICB0aGlzLmgzID0gaDMgfCAwO1xuICAgICAgICB0aGlzLmg0ID0gaDQgfCAwO1xuICAgIH1cbiAgICBwcm9jZXNzKHZpZXcsIG9mZnNldCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyssIG9mZnNldCArPSA0KVxuICAgICAgICAgICAgQlVGXzE2MFtpXSA9IHZpZXcuZ2V0VWludDMyKG9mZnNldCwgdHJ1ZSk7XG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICBsZXQgYWwgPSB0aGlzLmgwIHwgMCwgYXIgPSBhbCwgYmwgPSB0aGlzLmgxIHwgMCwgYnIgPSBibCwgY2wgPSB0aGlzLmgyIHwgMCwgY3IgPSBjbCwgZGwgPSB0aGlzLmgzIHwgMCwgZHIgPSBkbCwgZWwgPSB0aGlzLmg0IHwgMCwgZXIgPSBlbDtcbiAgICAgICAgLy8gSW5zdGVhZCBvZiBpdGVyYXRpbmcgMCB0byA4MCwgd2Ugc3BsaXQgaXQgaW50byA1IGdyb3Vwc1xuICAgICAgICAvLyBBbmQgdXNlIHRoZSBncm91cHMgaW4gY29uc3RhbnRzLCBmdW5jdGlvbnMsIGV0Yy4gTXVjaCBzaW1wbGVyXG4gICAgICAgIGZvciAobGV0IGdyb3VwID0gMDsgZ3JvdXAgPCA1OyBncm91cCsrKSB7XG4gICAgICAgICAgICBjb25zdCByR3JvdXAgPSA0IC0gZ3JvdXA7XG4gICAgICAgICAgICBjb25zdCBoYmwgPSBLbDE2MFtncm91cF0sIGhiciA9IEtyMTYwW2dyb3VwXTsgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgICAgICBjb25zdCBybCA9IGlkeExbZ3JvdXBdLCByciA9IGlkeFJbZ3JvdXBdOyAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgICAgIGNvbnN0IHNsID0gc2hpZnRzTDE2MFtncm91cF0sIHNyID0gc2hpZnRzUjE2MFtncm91cF07IC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGwgPSAoKDAsIHV0aWxzX3RzXzEucm90bCkoYWwgKyByaXBlbWRfZihncm91cCwgYmwsIGNsLCBkbCkgKyBCVUZfMTYwW3JsW2ldXSArIGhibCwgc2xbaV0pICsgZWwpIHwgMDtcbiAgICAgICAgICAgICAgICBhbCA9IGVsLCBlbCA9IGRsLCBkbCA9ICgwLCB1dGlsc190c18xLnJvdGwpKGNsLCAxMCkgfCAwLCBjbCA9IGJsLCBibCA9IHRsOyAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIDIgbG9vcHMgYXJlIDEwJSBmYXN0ZXJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRyID0gKCgwLCB1dGlsc190c18xLnJvdGwpKGFyICsgcmlwZW1kX2Yockdyb3VwLCBiciwgY3IsIGRyKSArIEJVRl8xNjBbcnJbaV1dICsgaGJyLCBzcltpXSkgKyBlcikgfCAwO1xuICAgICAgICAgICAgICAgIGFyID0gZXIsIGVyID0gZHIsIGRyID0gKDAsIHV0aWxzX3RzXzEucm90bCkoY3IsIDEwKSB8IDAsIGNyID0gYnIsIGJyID0gdHI7IC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEFkZCB0aGUgY29tcHJlc3NlZCBjaHVuayB0byB0aGUgY3VycmVudCBoYXNoIHZhbHVlXG4gICAgICAgIHRoaXMuc2V0KCh0aGlzLmgxICsgY2wgKyBkcikgfCAwLCAodGhpcy5oMiArIGRsICsgZXIpIHwgMCwgKHRoaXMuaDMgKyBlbCArIGFyKSB8IDAsICh0aGlzLmg0ICsgYWwgKyBicikgfCAwLCAodGhpcy5oMCArIGJsICsgY3IpIHwgMCk7XG4gICAgfVxuICAgIHJvdW5kQ2xlYW4oKSB7XG4gICAgICAgICgwLCB1dGlsc190c18xLmNsZWFuKShCVUZfMTYwKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xuICAgICAgICAoMCwgdXRpbHNfdHNfMS5jbGVhbikodGhpcy5idWZmZXIpO1xuICAgICAgICB0aGlzLnNldCgwLCAwLCAwLCAwLCAwKTtcbiAgICB9XG59XG5leHBvcnRzLlJJUEVNRDE2MCA9IFJJUEVNRDE2MDtcbi8qKlxuICogUklQRU1ELTE2MCAtIGEgbGVnYWN5IGhhc2ggZnVuY3Rpb24gZnJvbSAxOTkwcy5cbiAqICogaHR0cHM6Ly9ob21lcy5lc2F0Lmt1bGV1dmVuLmJlL35ib3NzZWxhZS9yaXBlbWQxNjAuaHRtbFxuICogKiBodHRwczovL2hvbWVzLmVzYXQua3VsZXV2ZW4uYmUvfmJvc3NlbGFlL3JpcGVtZDE2MC9wZGYvQUItOTYwMS9BQi05NjAxLnBkZlxuICovXG5leHBvcnRzLnJpcGVtZDE2MCA9ICgwLCB1dGlsc190c18xLmNyZWF0ZUhhc2hlcikoKCkgPT4gbmV3IFJJUEVNRDE2MCgpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxlZ2FjeS5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJyaXBlbWQxNjAiLCJSSVBFTUQxNjAiLCJtZDUiLCJNRDUiLCJzaGExIiwiU0hBMSIsIl9tZF90c18xIiwicmVxdWlyZSIsInV0aWxzX3RzXzEiLCJTSEExX0lWIiwiVWludDMyQXJyYXkiLCJmcm9tIiwiU0hBMV9XIiwiSGFzaE1EIiwiY29uc3RydWN0b3IiLCJBIiwiQiIsIkMiLCJEIiwiRSIsImdldCIsInNldCIsInByb2Nlc3MiLCJ2aWV3Iiwib2Zmc2V0IiwiaSIsImdldFVpbnQzMiIsInJvdGwiLCJGIiwiSyIsIkNoaSIsIk1haiIsIlQiLCJyb3VuZENsZWFuIiwiY2xlYW4iLCJkZXN0cm95IiwiYnVmZmVyIiwiY3JlYXRlSGFzaGVyIiwicDMyIiwiTWF0aCIsInBvdyIsIkFycmF5IiwibGVuZ3RoIiwiXyIsImZsb29yIiwiYWJzIiwic2luIiwiTUQ1X0lWIiwic2xpY2UiLCJNRDVfVyIsImciLCJzIiwiUmhvMTYwIiwiVWludDhBcnJheSIsIklkMTYwIiwiZmlsbCIsIm1hcCIsIlBpMTYwIiwiaWR4TFIiLCJMIiwiUiIsInJlcyIsImoiLCJwdXNoIiwiayIsImlkeEwiLCJpZHhSIiwic2hpZnRzMTYwIiwic2hpZnRzTDE2MCIsImlkeCIsInNoaWZ0c1IxNjAiLCJLbDE2MCIsIktyMTYwIiwicmlwZW1kX2YiLCJncm91cCIsIngiLCJ5IiwieiIsIkJVRl8xNjAiLCJoMCIsImgxIiwiaDIiLCJoMyIsImg0IiwiYWwiLCJhciIsImJsIiwiYnIiLCJjbCIsImNyIiwiZGwiLCJkciIsImVsIiwiZXIiLCJyR3JvdXAiLCJoYmwiLCJoYnIiLCJybCIsInJyIiwic2wiLCJzciIsInRsIiwidHIiLCJkZXN0cm95ZWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@noble/hashes/legacy.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@noble/hashes/pbkdf2.js":
/*!**********************************************!*\
  !*** ./node_modules/@noble/hashes/pbkdf2.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.pbkdf2 = pbkdf2;\nexports.pbkdf2Async = pbkdf2Async;\n/**\n * PBKDF (RFC 2898). Can be used to create a key from password and salt.\n * @module\n */ const hmac_ts_1 = __webpack_require__(/*! ./hmac.js */ \"(rsc)/./node_modules/@noble/hashes/hmac.js\");\n// prettier-ignore\nconst utils_ts_1 = __webpack_require__(/*! ./utils.js */ \"(rsc)/./node_modules/@noble/hashes/utils.js\");\n// Common prologue and epilogue for sync/async functions\nfunction pbkdf2Init(hash, _password, _salt, _opts) {\n    (0, utils_ts_1.ahash)(hash);\n    const opts = (0, utils_ts_1.checkOpts)({\n        dkLen: 32,\n        asyncTick: 10\n    }, _opts);\n    const { c, dkLen, asyncTick } = opts;\n    (0, utils_ts_1.anumber)(c);\n    (0, utils_ts_1.anumber)(dkLen);\n    (0, utils_ts_1.anumber)(asyncTick);\n    if (c < 1) throw new Error(\"iterations (c) should be >= 1\");\n    const password = (0, utils_ts_1.kdfInputToBytes)(_password);\n    const salt = (0, utils_ts_1.kdfInputToBytes)(_salt);\n    // DK = PBKDF2(PRF, Password, Salt, c, dkLen);\n    const DK = new Uint8Array(dkLen);\n    // U1 = PRF(Password, Salt + INT_32_BE(i))\n    const PRF = hmac_ts_1.hmac.create(hash, password);\n    const PRFSalt = PRF._cloneInto().update(salt);\n    return {\n        c,\n        dkLen,\n        asyncTick,\n        DK,\n        PRF,\n        PRFSalt\n    };\n}\nfunction pbkdf2Output(PRF, PRFSalt, DK, prfW, u) {\n    PRF.destroy();\n    PRFSalt.destroy();\n    if (prfW) prfW.destroy();\n    (0, utils_ts_1.clean)(u);\n    return DK;\n}\n/**\n * PBKDF2-HMAC: RFC 2898 key derivation function\n * @param hash - hash function that would be used e.g. sha256\n * @param password - password from which a derived key is generated\n * @param salt - cryptographic salt\n * @param opts - {c, dkLen} where c is work factor and dkLen is output message size\n * @example\n * const key = pbkdf2(sha256, 'password', 'salt', { dkLen: 32, c: Math.pow(2, 18) });\n */ function pbkdf2(hash, password, salt, opts) {\n    const { c, dkLen, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);\n    let prfW; // Working copy\n    const arr = new Uint8Array(4);\n    const view = (0, utils_ts_1.createView)(arr);\n    const u = new Uint8Array(PRF.outputLen);\n    // DK = T1 + T2 + ‚ãØ + Tdklen/hlen\n    for(let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen){\n        // Ti = F(Password, Salt, c, i)\n        const Ti = DK.subarray(pos, pos + PRF.outputLen);\n        view.setInt32(0, ti, false);\n        // F(Password, Salt, c, i) = U1 ^ U2 ^ ‚ãØ ^ Uc\n        // U1 = PRF(Password, Salt + INT_32_BE(i))\n        (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);\n        Ti.set(u.subarray(0, Ti.length));\n        for(let ui = 1; ui < c; ui++){\n            // Uc = PRF(Password, Uc‚àí1)\n            PRF._cloneInto(prfW).update(u).digestInto(u);\n            for(let i = 0; i < Ti.length; i++)Ti[i] ^= u[i];\n        }\n    }\n    return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);\n}\n/**\n * PBKDF2-HMAC: RFC 2898 key derivation function. Async version.\n * @example\n * await pbkdf2Async(sha256, 'password', 'salt', { dkLen: 32, c: 500_000 });\n */ async function pbkdf2Async(hash, password, salt, opts) {\n    const { c, dkLen, asyncTick, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);\n    let prfW; // Working copy\n    const arr = new Uint8Array(4);\n    const view = (0, utils_ts_1.createView)(arr);\n    const u = new Uint8Array(PRF.outputLen);\n    // DK = T1 + T2 + ‚ãØ + Tdklen/hlen\n    for(let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen){\n        // Ti = F(Password, Salt, c, i)\n        const Ti = DK.subarray(pos, pos + PRF.outputLen);\n        view.setInt32(0, ti, false);\n        // F(Password, Salt, c, i) = U1 ^ U2 ^ ‚ãØ ^ Uc\n        // U1 = PRF(Password, Salt + INT_32_BE(i))\n        (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);\n        Ti.set(u.subarray(0, Ti.length));\n        await (0, utils_ts_1.asyncLoop)(c - 1, asyncTick, ()=>{\n            // Uc = PRF(Password, Uc‚àí1)\n            PRF._cloneInto(prfW).update(u).digestInto(u);\n            for(let i = 0; i < Ti.length; i++)Ti[i] ^= u[i];\n        });\n    }\n    return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);\n} //# sourceMappingURL=pbkdf2.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9wYmtkZjIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGNBQWMsR0FBR0U7QUFDakJGLG1CQUFtQixHQUFHRztBQUN0Qjs7O0NBR0MsR0FDRCxNQUFNQyxZQUFZQyxtQkFBT0EsQ0FBQyw2REFBVztBQUNyQyxrQkFBa0I7QUFDbEIsTUFBTUMsYUFBYUQsbUJBQU9BLENBQUMsK0RBQVk7QUFDdkMsd0RBQXdEO0FBQ3hELFNBQVNFLFdBQVdDLElBQUksRUFBRUMsU0FBUyxFQUFFQyxLQUFLLEVBQUVDLEtBQUs7SUFDNUMsSUFBR0wsV0FBV00sS0FBSyxFQUFFSjtJQUN0QixNQUFNSyxPQUFPLENBQUMsR0FBR1AsV0FBV1EsU0FBUyxFQUFFO1FBQUVDLE9BQU87UUFBSUMsV0FBVztJQUFHLEdBQUdMO0lBQ3JFLE1BQU0sRUFBRU0sQ0FBQyxFQUFFRixLQUFLLEVBQUVDLFNBQVMsRUFBRSxHQUFHSDtJQUMvQixJQUFHUCxXQUFXWSxPQUFPLEVBQUVEO0lBQ3ZCLElBQUdYLFdBQVdZLE9BQU8sRUFBRUg7SUFDdkIsSUFBR1QsV0FBV1ksT0FBTyxFQUFFRjtJQUN4QixJQUFJQyxJQUFJLEdBQ0osTUFBTSxJQUFJRSxNQUFNO0lBQ3BCLE1BQU1DLFdBQVcsQ0FBQyxHQUFHZCxXQUFXZSxlQUFlLEVBQUVaO0lBQ2pELE1BQU1hLE9BQU8sQ0FBQyxHQUFHaEIsV0FBV2UsZUFBZSxFQUFFWDtJQUM3Qyw4Q0FBOEM7SUFDOUMsTUFBTWEsS0FBSyxJQUFJQyxXQUFXVDtJQUMxQiwwQ0FBMEM7SUFDMUMsTUFBTVUsTUFBTXJCLFVBQVVzQixJQUFJLENBQUNDLE1BQU0sQ0FBQ25CLE1BQU1ZO0lBQ3hDLE1BQU1RLFVBQVVILElBQUlJLFVBQVUsR0FBR0MsTUFBTSxDQUFDUjtJQUN4QyxPQUFPO1FBQUVMO1FBQUdGO1FBQU9DO1FBQVdPO1FBQUlF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QUFRLENBQUMsR0FBR0QsR0FBR0ssTUFBTTtRQUM5QixNQUFNLENBQUMsR0FBR3pDLFdBQVc0QyxTQUFTLEVBQUVqQyxJQUFJLEdBQUdELFdBQVc7WUFDOUMsMkJBQTJCO1lBQzNCUyxJQUFJSSxVQUFVLENBQUNHLE1BQU1GLE1BQU0sQ0FBQ0csR0FBR1ksVUFBVSxDQUFDWjtZQUMxQyxJQUFLLElBQUlnQixJQUFJLEdBQUdBLElBQUlQLEdBQUdLLE1BQU0sRUFBRUUsSUFDM0JQLEVBQUUsQ0FBQ08sRUFBRSxJQUFJaEIsQ0FBQyxDQUFDZ0IsRUFBRTtRQUNyQjtJQUNKO0lBQ0EsT0FBT2xCLGFBQWFOLEtBQUtHLFNBQVNMLElBQUlTLE1BQU1DO0FBQ2hELEVBQ0Esa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZmFyY2FzdGVyc3RhdHMvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9wYmtkZjIuanM/OGJjZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucGJrZGYyID0gcGJrZGYyO1xuZXhwb3J0cy5wYmtkZjJBc3luYyA9IHBia2RmMkFzeW5jO1xuLyoqXG4gKiBQQktERiAoUkZDIDI4OTgpLiBDYW4gYmUgdXNlZCB0byBjcmVhdGUgYSBrZXkgZnJvbSBwYXNzd29yZCBhbmQgc2FsdC5cbiAqIEBtb2R1bGVcbiAqL1xuY29uc3QgaG1hY190c18xID0gcmVxdWlyZShcIi4vaG1hYy5qc1wiKTtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgdXRpbHNfdHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzLmpzXCIpO1xuLy8gQ29tbW9uIHByb2xvZ3VlIGFuZCBlcGlsb2d1ZSBmb3Igc3luYy9hc3luYyBmdW5jdGlvbnNcbmZ1bmN0aW9uIHBia2RmMkluaXQoaGFzaCwgX3Bhc3N3b3JkLCBfc2FsdCwgX29wdHMpIHtcbiAgICAoMCwgdXRpbHNfdHNfMS5haGFzaCkoaGFzaCk7XG4gICAgY29uc3Qgb3B0cyA9ICgwLCB1dGlsc190c18xLmNoZWNrT3B0cykoeyBka0xlbjogMzIsIGFzeW5jVGljazogMTAgfSwgX29wdHMpO1xuICAgIGNvbnN0IHsgYywgZGtMZW4sIGFzeW5jVGljayB9ID0gb3B0cztcbiAgICAoMCwgdXRpbHNfdHNfMS5hbnVtYmVyKShjKTtcbiAgICAoMCwgdXRpbHNfdHNfMS5hbnVtYmVyKShka0xlbik7XG4gICAgKDAsIHV0aWxzX3RzXzEuYW51bWJlcikoYXN5bmNUaWNrKTtcbiAgICBpZiAoYyA8IDEpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaXRlcmF0aW9ucyAoYykgc2hvdWxkIGJlID49IDEnKTtcbiAgICBjb25zdCBwYXNzd29yZCA9ICgwLCB1dGlsc190c18xLmtkZklucHV0VG9CeXRlcykoX3Bhc3N3b3JkKTtcbiAgICBjb25zdCBzYWx0ID0gKDAsIHV0aWxzX3RzXzEua2RmSW5wdXRUb0J5dGVzKShfc2FsdCk7XG4gICAgLy8gREsgPSBQQktERjIoUFJGLCBQYXNzd29yZCwgU2FsdCwgYywgZGtMZW4pO1xuICAgIGNvbnN0IERLID0gbmV3IFVpbnQ4QXJyYXkoZGtMZW4pO1xuICAgIC8vIFUxID0gUFJGKFBhc3N3b3JkLCBTYWx0ICsgSU5UXzMyX0JFKGkpKVxuICAgIGNvbnN0IFBSRiA9IGhtYWNfdHNfMS5obWFjLmNyZWF0ZShoYXNoLCBwYXNzd29yZCk7XG4gICAgY29uc3QgUFJGU2FsdCA9IFBSRi5fY2xvbmVJbnRvKCkudXBkYXRlKHNhbHQpO1xuICAgIHJldHVybiB7IGMsIGRrTGVuLCBhc3luY1RpY2ssIERLLCBQUkYsIFBSRlNhbHQgfTtcbn1cbmZ1bmN0aW9uIHBia2RmMk91dHB1dChQUkYsIFBSRlNhbHQsIERLLCBwcmZXLCB1KSB7XG4gICAgUFJGLmRlc3Ryb3koKTtcbiAgICBQUkZTYWx0LmRlc3Ryb3koKTtcbiAgICBpZiAocHJmVylcbiAgICAgICAgcHJmVy5kZXN0cm95KCk7XG4gICAgKDAsIHV0aWxzX3RzXzEuY2xlYW4pKHUpO1xuICAgIHJldHVybiBESztcbn1cbi8qKlxuICogUEJLREYyLUhNQUM6IFJGQyAyODk4IGtleSBkZXJpdmF0aW9uIGZ1bmN0aW9uXG4gKiBAcGFyYW0gaGFzaCAtIGhhc2ggZnVuY3Rpb24gdGhhdCB3b3VsZCBiZSB1c2VkIGUuZy4gc2hhMjU2XG4gKiBAcGFyYW0gcGFzc3dvcmQgLSBwYXNzd29yZCBmcm9tIHdoaWNoIGEgZGVyaXZlZCBrZXkgaXMgZ2VuZXJhdGVkXG4gKiBAcGFyYW0gc2FsdCAtIGNyeXB0b2dyYXBoaWMgc2FsdFxuICogQHBhcmFtIG9wdHMgLSB7YywgZGtMZW59IHdoZXJlIGMgaXMgd29yayBmYWN0b3IgYW5kIGRrTGVuIGlzIG91dHB1dCBtZXNzYWdlIHNpemVcbiAqIEBleGFtcGxlXG4gKiBjb25zdCBrZXkgPSBwYmtkZjIoc2hhMjU2LCAncGFzc3dvcmQnLCAnc2FsdCcsIHsgZGtMZW46IDMyLCBjOiBNYXRoLnBvdygyLCAxOCkgfSk7XG4gKi9cbmZ1bmN0aW9uIHBia2RmMihoYXNoLCBwYXNzd29yZCwgc2FsdCwgb3B0cykge1xuICAgIGNvbnN0IHsgYywgZGtMZW4sIERLLCBQUkYsIFBSRlNhbHQgfSA9IHBia2RmMkluaXQoaGFzaCwgcGFzc3dvcmQsIHNhbHQsIG9wdHMpO1xuICAgIGxldCBwcmZXOyAvLyBXb3JraW5nIGNvcHlcbiAgICBjb25zdCBhcnIgPSBuZXcgVWludDhBcnJheSg0KTtcbiAgICBjb25zdCB2aWV3ID0gKDAsIHV0aWxzX3RzXzEuY3JlYXRlVmlldykoYXJyKTtcbiAgICBjb25zdCB1ID0gbmV3IFVpbnQ4QXJyYXkoUFJGLm91dHB1dExlbik7XG4gICAgLy8gREsgPSBUMSArIFQyICsg4ouvICsgVGRrbGVuL2hsZW5cbiAgICBmb3IgKGxldCB0aSA9IDEsIHBvcyA9IDA7IHBvcyA8IGRrTGVuOyB0aSsrLCBwb3MgKz0gUFJGLm91dHB1dExlbikge1xuICAgICAgICAvLyBUaSA9IEYoUGFzc3dvcmQsIFNhbHQsIGMsIGkpXG4gICAgICAgIGNvbnN0IFRpID0gREsuc3ViYXJyYXkocG9zLCBwb3MgKyBQUkYub3V0cHV0TGVuKTtcbiAgICAgICAgdmlldy5zZXRJbnQzMigwLCB0aSwgZmFsc2UpO1xuICAgICAgICAvLyBGKFBhc3N3b3JkLCBTYWx0LCBjLCBpKSA9IFUxIF4gVTIgXiDii68gXiBVY1xuICAgICAgICAvLyBVMSA9IFBSRihQYXNzd29yZCwgU2FsdCArIElOVF8zMl9CRShpKSlcbiAgICAgICAgKHByZlcgPSBQUkZTYWx0Ll9jbG9uZUludG8ocHJmVykpLnVwZGF0ZShhcnIpLmRpZ2VzdEludG8odSk7XG4gICAgICAgIFRpLnNldCh1LnN1YmFycmF5KDAsIFRpLmxlbmd0aCkpO1xuICAgICAgICBmb3IgKGxldCB1aSA9IDE7IHVpIDwgYzsgdWkrKykge1xuICAgICAgICAgICAgLy8gVWMgPSBQUkYoUGFzc3dvcmQsIFVj4oiSMSlcbiAgICAgICAgICAgIFBSRi5fY2xvbmVJbnRvKHByZlcpLnVwZGF0ZSh1KS5kaWdlc3RJbnRvKHUpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBUaS5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICBUaVtpXSBePSB1W2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwYmtkZjJPdXRwdXQoUFJGLCBQUkZTYWx0LCBESywgcHJmVywgdSk7XG59XG4vKipcbiAqIFBCS0RGMi1ITUFDOiBSRkMgMjg5OCBrZXkgZGVyaXZhdGlvbiBmdW5jdGlvbi4gQXN5bmMgdmVyc2lvbi5cbiAqIEBleGFtcGxlXG4gKiBhd2FpdCBwYmtkZjJBc3luYyhzaGEyNTYsICdwYXNzd29yZCcsICdzYWx0JywgeyBka0xlbjogMzIsIGM6IDUwMF8wMDAgfSk7XG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHBia2RmMkFzeW5jKGhhc2gsIHBhc3N3b3JkLCBzYWx0LCBvcHRzKSB7XG4gICAgY29uc3QgeyBjLCBka0xlbiwgYXN5bmNUaWNrLCBESywgUFJGLCBQUkZTYWx0IH0gPSBwYmtkZjJJbml0KGhhc2gsIHBhc3N3b3JkLCBzYWx0LCBvcHRzKTtcbiAgICBsZXQgcHJmVzsgLy8gV29ya2luZyBjb3B5XG4gICAgY29uc3QgYXJyID0gbmV3IFVpbnQ4QXJyYXkoNCk7XG4gICAgY29uc3QgdmlldyA9ICgwLCB1dGlsc190c18xLmNyZWF0ZVZpZXcpKGFycik7XG4gICAgY29uc3QgdSA9IG5ldyBVaW50OEFycmF5KFBSRi5vdXRwdXRMZW4pO1xuICAgIC8vIERLID0gVDEgKyBUMiArIOKLryArIFRka2xlbi9obGVuXG4gICAgZm9yIChsZXQgdGkgPSAxLCBwb3MgPSAwOyBwb3MgPCBka0xlbjsgdGkrKywgcG9zICs9IFBSRi5vdXRwdXRMZW4pIHtcbiAgICAgICAgLy8gVGkgPSBGKFBhc3N3b3JkLCBTYWx0LCBjLCBpKVxuICAgICAgICBjb25zdCBUaSA9IERLLnN1YmFycmF5KHBvcywgcG9zICsgUFJGLm91dHB1dExlbik7XG4gICAgICAgIHZpZXcuc2V0SW50MzIoMCwgdGksIGZhbHNlKTtcbiAgICAgICAgLy8gRihQYXNzd29yZCwgU2FsdCwgYywgaSkgPSBVMSBeIFUyIF4g4ouvIF4gVWNcbiAgICAgICAgLy8gVTEgPSBQUkYoUGFzc3dvcmQsIFNhbHQgKyBJTlRfMzJfQkUoaSkpXG4gICAgICAgIChwcmZXID0gUFJGU2FsdC5fY2xvbmVJbnRvKHByZlcpKS51cGRhdGUoYXJyKS5kaWdlc3RJbnRvKHUpO1xuICAgICAgICBUaS5zZXQodS5zdWJhcnJheSgwLCBUaS5sZW5ndGgpKTtcbiAgICAgICAgYXdhaXQgKDAsIHV0aWxzX3RzXzEuYXN5bmNMb29wKShjIC0gMSwgYXN5bmNUaWNrLCAoKSA9PiB7XG4gICAgICAgICAgICAvLyBVYyA9IFBSRihQYXNzd29yZCwgVWPiiJIxKVxuICAgICAgICAgICAgUFJGLl9jbG9uZUludG8ocHJmVykudXBkYXRlKHUpLmRpZ2VzdEludG8odSk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IFRpLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgIFRpW2ldIF49IHVbaV07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcGJrZGYyT3V0cHV0KFBSRiwgUFJGU2FsdCwgREssIHByZlcsIHUpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGJrZGYyLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInBia2RmMiIsInBia2RmMkFzeW5jIiwiaG1hY190c18xIiwicmVxdWlyZSIsInV0aWxzX3RzXzEiLCJwYmtkZjJJbml0IiwiaGFzaCIsIl9wYXNzd29yZCIsIl9zYWx0IiwiX29wdHMiLCJhaGFzaCIsIm9wdHMiLCJjaGVja09wdHMiLCJka0xlbiIsImFzeW5jVGljayIsImMiLCJhbnVtYmVyIiwiRXJyb3IiLCJwYXNzd29yZCIsImtkZklucHV0VG9CeXRlcyIsInNhbHQiLCJESyIsIlVpbnQ4QXJyYXkiLCJQUkYiLCJobWFjIiwiY3JlYXRlIiwiUFJGU2FsdCIsIl9jbG9uZUludG8iLCJ1cGRhdGUiLCJwYmtkZjJPdXRwdXQiLCJwcmZXIiwidSIsImRlc3Ryb3kiLCJjbGVhbiIsImFyciIsInZpZXciLCJjcmVhdGVWaWV3Iiwib3V0cHV0TGVuIiwidGkiLCJwb3MiLCJUaSIsInN1YmFycmF5Iiwic2V0SW50MzIiLCJkaWdlc3RJbnRvIiwic2V0IiwibGVuZ3RoIiwidWkiLCJpIiwiYXN5bmNMb29wIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@noble/hashes/pbkdf2.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@noble/hashes/sha2.js":
/*!********************************************!*\
  !*** ./node_modules/@noble/hashes/sha2.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.sha512_224 = exports.sha512_256 = exports.sha384 = exports.sha512 = exports.sha224 = exports.sha256 = exports.SHA512_256 = exports.SHA512_224 = exports.SHA384 = exports.SHA512 = exports.SHA224 = exports.SHA256 = void 0;\n/**\n * SHA2 hash function. A.k.a. sha256, sha384, sha512, sha512_224, sha512_256.\n * SHA256 is the fastest hash implementable in JS, even faster than Blake3.\n * Check out [RFC 4634](https://datatracker.ietf.org/doc/html/rfc4634) and\n * [FIPS 180-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf).\n * @module\n */ const _md_ts_1 = __webpack_require__(/*! ./_md.js */ \"(rsc)/./node_modules/@noble/hashes/_md.js\");\nconst u64 = __webpack_require__(/*! ./_u64.js */ \"(rsc)/./node_modules/@noble/hashes/_u64.js\");\nconst utils_ts_1 = __webpack_require__(/*! ./utils.js */ \"(rsc)/./node_modules/@noble/hashes/utils.js\");\n/**\n * Round constants:\n * First 32 bits of fractional parts of the cube roots of the first 64 primes 2..311)\n */ // prettier-ignore\nconst SHA256_K = /* @__PURE__ */ Uint32Array.from([\n    0x428a2f98,\n    0x71374491,\n    0xb5c0fbcf,\n    0xe9b5dba5,\n    0x3956c25b,\n    0x59f111f1,\n    0x923f82a4,\n    0xab1c5ed5,\n    0xd807aa98,\n    0x12835b01,\n    0x243185be,\n    0x550c7dc3,\n    0x72be5d74,\n    0x80deb1fe,\n    0x9bdc06a7,\n    0xc19bf174,\n    0xe49b69c1,\n    0xefbe4786,\n    0x0fc19dc6,\n    0x240ca1cc,\n    0x2de92c6f,\n    0x4a7484aa,\n    0x5cb0a9dc,\n    0x76f988da,\n    0x983e5152,\n    0xa831c66d,\n    0xb00327c8,\n    0xbf597fc7,\n    0xc6e00bf3,\n    0xd5a79147,\n    0x06ca6351,\n    0x14292967,\n    0x27b70a85,\n    0x2e1b2138,\n    0x4d2c6dfc,\n    0x53380d13,\n    0x650a7354,\n    0x766a0abb,\n    0x81c2c92e,\n    0x92722c85,\n    0xa2bfe8a1,\n    0xa81a664b,\n    0xc24b8b70,\n    0xc76c51a3,\n    0xd192e819,\n    0xd6990624,\n    0xf40e3585,\n    0x106aa070,\n    0x19a4c116,\n    0x1e376c08,\n    0x2748774c,\n    0x34b0bcb5,\n    0x391c0cb3,\n    0x4ed8aa4a,\n    0x5b9cca4f,\n    0x682e6ff3,\n    0x748f82ee,\n    0x78a5636f,\n    0x84c87814,\n    0x8cc70208,\n    0x90befffa,\n    0xa4506ceb,\n    0xbef9a3f7,\n    0xc67178f2\n]);\n/** Reusable temporary buffer. \"W\" comes straight from spec. */ const SHA256_W = /* @__PURE__ */ new Uint32Array(64);\nclass SHA256 extends _md_ts_1.HashMD {\n    constructor(outputLen = 32){\n        super(64, outputLen, 8, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        this.A = _md_ts_1.SHA256_IV[0] | 0;\n        this.B = _md_ts_1.SHA256_IV[1] | 0;\n        this.C = _md_ts_1.SHA256_IV[2] | 0;\n        this.D = _md_ts_1.SHA256_IV[3] | 0;\n        this.E = _md_ts_1.SHA256_IV[4] | 0;\n        this.F = _md_ts_1.SHA256_IV[5] | 0;\n        this.G = _md_ts_1.SHA256_IV[6] | 0;\n        this.H = _md_ts_1.SHA256_IV[7] | 0;\n    }\n    get() {\n        const { A, B, C, D, E, F, G, H } = this;\n        return [\n            A,\n            B,\n            C,\n            D,\n            E,\n            F,\n            G,\n            H\n        ];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n        for(let i = 0; i < 16; i++, offset += 4)SHA256_W[i] = view.getUint32(offset, false);\n        for(let i = 16; i < 64; i++){\n            const W15 = SHA256_W[i - 15];\n            const W2 = SHA256_W[i - 2];\n            const s0 = (0, utils_ts_1.rotr)(W15, 7) ^ (0, utils_ts_1.rotr)(W15, 18) ^ W15 >>> 3;\n            const s1 = (0, utils_ts_1.rotr)(W2, 17) ^ (0, utils_ts_1.rotr)(W2, 19) ^ W2 >>> 10;\n            SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;\n        }\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D, E, F, G, H } = this;\n        for(let i = 0; i < 64; i++){\n            const sigma1 = (0, utils_ts_1.rotr)(E, 6) ^ (0, utils_ts_1.rotr)(E, 11) ^ (0, utils_ts_1.rotr)(E, 25);\n            const T1 = H + sigma1 + (0, _md_ts_1.Chi)(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;\n            const sigma0 = (0, utils_ts_1.rotr)(A, 2) ^ (0, utils_ts_1.rotr)(A, 13) ^ (0, utils_ts_1.rotr)(A, 22);\n            const T2 = sigma0 + (0, _md_ts_1.Maj)(A, B, C) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = D + T1 | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = T1 + T2 | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        A = A + this.A | 0;\n        B = B + this.B | 0;\n        C = C + this.C | 0;\n        D = D + this.D | 0;\n        E = E + this.E | 0;\n        F = F + this.F | 0;\n        G = G + this.G | 0;\n        H = H + this.H | 0;\n        this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n        (0, utils_ts_1.clean)(SHA256_W);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n        (0, utils_ts_1.clean)(this.buffer);\n    }\n}\nexports.SHA256 = SHA256;\nclass SHA224 extends SHA256 {\n    constructor(){\n        super(28);\n        this.A = _md_ts_1.SHA224_IV[0] | 0;\n        this.B = _md_ts_1.SHA224_IV[1] | 0;\n        this.C = _md_ts_1.SHA224_IV[2] | 0;\n        this.D = _md_ts_1.SHA224_IV[3] | 0;\n        this.E = _md_ts_1.SHA224_IV[4] | 0;\n        this.F = _md_ts_1.SHA224_IV[5] | 0;\n        this.G = _md_ts_1.SHA224_IV[6] | 0;\n        this.H = _md_ts_1.SHA224_IV[7] | 0;\n    }\n}\nexports.SHA224 = SHA224;\n// SHA2-512 is slower than sha256 in js because u64 operations are slow.\n// Round contants\n// First 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409\n// prettier-ignore\nconst K512 = /* @__PURE__ */ (()=>u64.split([\n        \"0x428a2f98d728ae22\",\n        \"0x7137449123ef65cd\",\n        \"0xb5c0fbcfec4d3b2f\",\n        \"0xe9b5dba58189dbbc\",\n        \"0x3956c25bf348b538\",\n        \"0x59f111f1b605d019\",\n        \"0x923f82a4af194f9b\",\n        \"0xab1c5ed5da6d8118\",\n        \"0xd807aa98a3030242\",\n        \"0x12835b0145706fbe\",\n        \"0x243185be4ee4b28c\",\n        \"0x550c7dc3d5ffb4e2\",\n        \"0x72be5d74f27b896f\",\n        \"0x80deb1fe3b1696b1\",\n        \"0x9bdc06a725c71235\",\n        \"0xc19bf174cf692694\",\n        \"0xe49b69c19ef14ad2\",\n        \"0xefbe4786384f25e3\",\n        \"0x0fc19dc68b8cd5b5\",\n        \"0x240ca1cc77ac9c65\",\n        \"0x2de92c6f592b0275\",\n        \"0x4a7484aa6ea6e483\",\n        \"0x5cb0a9dcbd41fbd4\",\n        \"0x76f988da831153b5\",\n        \"0x983e5152ee66dfab\",\n        \"0xa831c66d2db43210\",\n        \"0xb00327c898fb213f\",\n        \"0xbf597fc7beef0ee4\",\n        \"0xc6e00bf33da88fc2\",\n        \"0xd5a79147930aa725\",\n        \"0x06ca6351e003826f\",\n        \"0x142929670a0e6e70\",\n        \"0x27b70a8546d22ffc\",\n        \"0x2e1b21385c26c926\",\n        \"0x4d2c6dfc5ac42aed\",\n        \"0x53380d139d95b3df\",\n        \"0x650a73548baf63de\",\n        \"0x766a0abb3c77b2a8\",\n        \"0x81c2c92e47edaee6\",\n        \"0x92722c851482353b\",\n        \"0xa2bfe8a14cf10364\",\n        \"0xa81a664bbc423001\",\n        \"0xc24b8b70d0f89791\",\n        \"0xc76c51a30654be30\",\n        \"0xd192e819d6ef5218\",\n        \"0xd69906245565a910\",\n        \"0xf40e35855771202a\",\n        \"0x106aa07032bbd1b8\",\n        \"0x19a4c116b8d2d0c8\",\n        \"0x1e376c085141ab53\",\n        \"0x2748774cdf8eeb99\",\n        \"0x34b0bcb5e19b48a8\",\n        \"0x391c0cb3c5c95a63\",\n        \"0x4ed8aa4ae3418acb\",\n        \"0x5b9cca4f7763e373\",\n        \"0x682e6ff3d6b2b8a3\",\n        \"0x748f82ee5defb2fc\",\n        \"0x78a5636f43172f60\",\n        \"0x84c87814a1f0ab72\",\n        \"0x8cc702081a6439ec\",\n        \"0x90befffa23631e28\",\n        \"0xa4506cebde82bde9\",\n        \"0xbef9a3f7b2c67915\",\n        \"0xc67178f2e372532b\",\n        \"0xca273eceea26619c\",\n        \"0xd186b8c721c0c207\",\n        \"0xeada7dd6cde0eb1e\",\n        \"0xf57d4f7fee6ed178\",\n        \"0x06f067aa72176fba\",\n        \"0x0a637dc5a2c898a6\",\n        \"0x113f9804bef90dae\",\n        \"0x1b710b35131c471b\",\n        \"0x28db77f523047d84\",\n        \"0x32caab7b40c72493\",\n        \"0x3c9ebe0a15c9bebc\",\n        \"0x431d67c49c100d4c\",\n        \"0x4cc5d4becb3e42b6\",\n        \"0x597f299cfc657e2a\",\n        \"0x5fcb6fab3ad6faec\",\n        \"0x6c44198c4a475817\"\n    ].map((n)=>BigInt(n))))();\nconst SHA512_Kh = /* @__PURE__ */ (()=>K512[0])();\nconst SHA512_Kl = /* @__PURE__ */ (()=>K512[1])();\n// Reusable temporary buffers\nconst SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);\nconst SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);\nclass SHA512 extends _md_ts_1.HashMD {\n    constructor(outputLen = 64){\n        super(128, outputLen, 16, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = _md_ts_1.SHA512_IV[0] | 0;\n        this.Al = _md_ts_1.SHA512_IV[1] | 0;\n        this.Bh = _md_ts_1.SHA512_IV[2] | 0;\n        this.Bl = _md_ts_1.SHA512_IV[3] | 0;\n        this.Ch = _md_ts_1.SHA512_IV[4] | 0;\n        this.Cl = _md_ts_1.SHA512_IV[5] | 0;\n        this.Dh = _md_ts_1.SHA512_IV[6] | 0;\n        this.Dl = _md_ts_1.SHA512_IV[7] | 0;\n        this.Eh = _md_ts_1.SHA512_IV[8] | 0;\n        this.El = _md_ts_1.SHA512_IV[9] | 0;\n        this.Fh = _md_ts_1.SHA512_IV[10] | 0;\n        this.Fl = _md_ts_1.SHA512_IV[11] | 0;\n        this.Gh = _md_ts_1.SHA512_IV[12] | 0;\n        this.Gl = _md_ts_1.SHA512_IV[13] | 0;\n        this.Hh = _md_ts_1.SHA512_IV[14] | 0;\n        this.Hl = _md_ts_1.SHA512_IV[15] | 0;\n    }\n    // prettier-ignore\n    get() {\n        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        return [\n            Ah,\n            Al,\n            Bh,\n            Bl,\n            Ch,\n            Cl,\n            Dh,\n            Dl,\n            Eh,\n            El,\n            Fh,\n            Fl,\n            Gh,\n            Gl,\n            Hh,\n            Hl\n        ];\n    }\n    // prettier-ignore\n    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {\n        this.Ah = Ah | 0;\n        this.Al = Al | 0;\n        this.Bh = Bh | 0;\n        this.Bl = Bl | 0;\n        this.Ch = Ch | 0;\n        this.Cl = Cl | 0;\n        this.Dh = Dh | 0;\n        this.Dl = Dl | 0;\n        this.Eh = Eh | 0;\n        this.El = El | 0;\n        this.Fh = Fh | 0;\n        this.Fl = Fl | 0;\n        this.Gh = Gh | 0;\n        this.Gl = Gl | 0;\n        this.Hh = Hh | 0;\n        this.Hl = Hl | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array\n        for(let i = 0; i < 16; i++, offset += 4){\n            SHA512_W_H[i] = view.getUint32(offset);\n            SHA512_W_L[i] = view.getUint32(offset += 4);\n        }\n        for(let i = 16; i < 80; i++){\n            // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)\n            const W15h = SHA512_W_H[i - 15] | 0;\n            const W15l = SHA512_W_L[i - 15] | 0;\n            const s0h = u64.rotrSH(W15h, W15l, 1) ^ u64.rotrSH(W15h, W15l, 8) ^ u64.shrSH(W15h, W15l, 7);\n            const s0l = u64.rotrSL(W15h, W15l, 1) ^ u64.rotrSL(W15h, W15l, 8) ^ u64.shrSL(W15h, W15l, 7);\n            // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)\n            const W2h = SHA512_W_H[i - 2] | 0;\n            const W2l = SHA512_W_L[i - 2] | 0;\n            const s1h = u64.rotrSH(W2h, W2l, 19) ^ u64.rotrBH(W2h, W2l, 61) ^ u64.shrSH(W2h, W2l, 6);\n            const s1l = u64.rotrSL(W2h, W2l, 19) ^ u64.rotrBL(W2h, W2l, 61) ^ u64.shrSL(W2h, W2l, 6);\n            // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];\n            const SUMl = u64.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);\n            const SUMh = u64.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);\n            SHA512_W_H[i] = SUMh | 0;\n            SHA512_W_L[i] = SUMl | 0;\n        }\n        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        // Compression function main loop, 80 rounds\n        for(let i = 0; i < 80; i++){\n            // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)\n            const sigma1h = u64.rotrSH(Eh, El, 14) ^ u64.rotrSH(Eh, El, 18) ^ u64.rotrBH(Eh, El, 41);\n            const sigma1l = u64.rotrSL(Eh, El, 14) ^ u64.rotrSL(Eh, El, 18) ^ u64.rotrBL(Eh, El, 41);\n            //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const CHIh = Eh & Fh ^ ~Eh & Gh;\n            const CHIl = El & Fl ^ ~El & Gl;\n            // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]\n            // prettier-ignore\n            const T1ll = u64.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);\n            const T1h = u64.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);\n            const T1l = T1ll | 0;\n            // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)\n            const sigma0h = u64.rotrSH(Ah, Al, 28) ^ u64.rotrBH(Ah, Al, 34) ^ u64.rotrBH(Ah, Al, 39);\n            const sigma0l = u64.rotrSL(Ah, Al, 28) ^ u64.rotrBL(Ah, Al, 34) ^ u64.rotrBL(Ah, Al, 39);\n            const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;\n            const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;\n            Hh = Gh | 0;\n            Hl = Gl | 0;\n            Gh = Fh | 0;\n            Gl = Fl | 0;\n            Fh = Eh | 0;\n            Fl = El | 0;\n            ({ h: Eh, l: El } = u64.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));\n            Dh = Ch | 0;\n            Dl = Cl | 0;\n            Ch = Bh | 0;\n            Cl = Bl | 0;\n            Bh = Ah | 0;\n            Bl = Al | 0;\n            const All = u64.add3L(T1l, sigma0l, MAJl);\n            Ah = u64.add3H(All, T1h, sigma0h, MAJh);\n            Al = All | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        ({ h: Ah, l: Al } = u64.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));\n        ({ h: Bh, l: Bl } = u64.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));\n        ({ h: Ch, l: Cl } = u64.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));\n        ({ h: Dh, l: Dl } = u64.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));\n        ({ h: Eh, l: El } = u64.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));\n        ({ h: Fh, l: Fl } = u64.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));\n        ({ h: Gh, l: Gl } = u64.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));\n        ({ h: Hh, l: Hl } = u64.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));\n        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);\n    }\n    roundClean() {\n        (0, utils_ts_1.clean)(SHA512_W_H, SHA512_W_L);\n    }\n    destroy() {\n        (0, utils_ts_1.clean)(this.buffer);\n        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n    }\n}\nexports.SHA512 = SHA512;\nclass SHA384 extends SHA512 {\n    constructor(){\n        super(48);\n        this.Ah = _md_ts_1.SHA384_IV[0] | 0;\n        this.Al = _md_ts_1.SHA384_IV[1] | 0;\n        this.Bh = _md_ts_1.SHA384_IV[2] | 0;\n        this.Bl = _md_ts_1.SHA384_IV[3] | 0;\n        this.Ch = _md_ts_1.SHA384_IV[4] | 0;\n        this.Cl = _md_ts_1.SHA384_IV[5] | 0;\n        this.Dh = _md_ts_1.SHA384_IV[6] | 0;\n        this.Dl = _md_ts_1.SHA384_IV[7] | 0;\n        this.Eh = _md_ts_1.SHA384_IV[8] | 0;\n        this.El = _md_ts_1.SHA384_IV[9] | 0;\n        this.Fh = _md_ts_1.SHA384_IV[10] | 0;\n        this.Fl = _md_ts_1.SHA384_IV[11] | 0;\n        this.Gh = _md_ts_1.SHA384_IV[12] | 0;\n        this.Gl = _md_ts_1.SHA384_IV[13] | 0;\n        this.Hh = _md_ts_1.SHA384_IV[14] | 0;\n        this.Hl = _md_ts_1.SHA384_IV[15] | 0;\n    }\n}\nexports.SHA384 = SHA384;\n/**\n * Truncated SHA512/256 and SHA512/224.\n * SHA512_IV is XORed with 0xa5a5a5a5a5a5a5a5, then used as \"intermediary\" IV of SHA512/t.\n * Then t hashes string to produce result IV.\n * See `test/misc/sha2-gen-iv.js`.\n */ /** SHA512/224 IV */ const T224_IV = /* @__PURE__ */ Uint32Array.from([\n    0x8c3d37c8,\n    0x19544da2,\n    0x73e19966,\n    0x89dcd4d6,\n    0x1dfab7ae,\n    0x32ff9c82,\n    0x679dd514,\n    0x582f9fcf,\n    0x0f6d2b69,\n    0x7bd44da8,\n    0x77e36f73,\n    0x04c48942,\n    0x3f9d85a8,\n    0x6a1d36c8,\n    0x1112e6ad,\n    0x91d692a1\n]);\n/** SHA512/256 IV */ const T256_IV = /* @__PURE__ */ Uint32Array.from([\n    0x22312194,\n    0xfc2bf72c,\n    0x9f555fa3,\n    0xc84c64c2,\n    0x2393b86b,\n    0x6f53b151,\n    0x96387719,\n    0x5940eabd,\n    0x96283ee2,\n    0xa88effe3,\n    0xbe5e1e25,\n    0x53863992,\n    0x2b0199fc,\n    0x2c85b8aa,\n    0x0eb72ddc,\n    0x81c52ca2\n]);\nclass SHA512_224 extends SHA512 {\n    constructor(){\n        super(28);\n        this.Ah = T224_IV[0] | 0;\n        this.Al = T224_IV[1] | 0;\n        this.Bh = T224_IV[2] | 0;\n        this.Bl = T224_IV[3] | 0;\n        this.Ch = T224_IV[4] | 0;\n        this.Cl = T224_IV[5] | 0;\n        this.Dh = T224_IV[6] | 0;\n        this.Dl = T224_IV[7] | 0;\n        this.Eh = T224_IV[8] | 0;\n        this.El = T224_IV[9] | 0;\n        this.Fh = T224_IV[10] | 0;\n        this.Fl = T224_IV[11] | 0;\n        this.Gh = T224_IV[12] | 0;\n        this.Gl = T224_IV[13] | 0;\n        this.Hh = T224_IV[14] | 0;\n        this.Hl = T224_IV[15] | 0;\n    }\n}\nexports.SHA512_224 = SHA512_224;\nclass SHA512_256 extends SHA512 {\n    constructor(){\n        super(32);\n        this.Ah = T256_IV[0] | 0;\n        this.Al = T256_IV[1] | 0;\n        this.Bh = T256_IV[2] | 0;\n        this.Bl = T256_IV[3] | 0;\n        this.Ch = T256_IV[4] | 0;\n        this.Cl = T256_IV[5] | 0;\n        this.Dh = T256_IV[6] | 0;\n        this.Dl = T256_IV[7] | 0;\n        this.Eh = T256_IV[8] | 0;\n        this.El = T256_IV[9] | 0;\n        this.Fh = T256_IV[10] | 0;\n        this.Fl = T256_IV[11] | 0;\n        this.Gh = T256_IV[12] | 0;\n        this.Gl = T256_IV[13] | 0;\n        this.Hh = T256_IV[14] | 0;\n        this.Hl = T256_IV[15] | 0;\n    }\n}\nexports.SHA512_256 = SHA512_256;\n/**\n * SHA2-256 hash function from RFC 4634.\n *\n * It is the fastest JS hash, even faster than Blake3.\n * To break sha256 using birthday attack, attackers need to try 2^128 hashes.\n * BTC network is doing 2^70 hashes/sec (2^95 hashes/year) as per 2025.\n */ exports.sha256 = (0, utils_ts_1.createHasher)(()=>new SHA256());\n/** SHA2-224 hash function from RFC 4634 */ exports.sha224 = (0, utils_ts_1.createHasher)(()=>new SHA224());\n/** SHA2-512 hash function from RFC 4634. */ exports.sha512 = (0, utils_ts_1.createHasher)(()=>new SHA512());\n/** SHA2-384 hash function from RFC 4634. */ exports.sha384 = (0, utils_ts_1.createHasher)(()=>new SHA384());\n/**\n * SHA2-512/256 \"truncated\" hash function, with improved resistance to length extension attacks.\n * See the paper on [truncated SHA512](https://eprint.iacr.org/2010/548.pdf).\n */ exports.sha512_256 = (0, utils_ts_1.createHasher)(()=>new SHA512_256());\n/**\n * SHA2-512/224 \"truncated\" hash function, with improved resistance to length extension attacks.\n * See the paper on [truncated SHA512](https://eprint.iacr.org/2010/548.pdf).\n */ exports.sha512_224 = (0, utils_ts_1.createHasher)(()=>new SHA512_224()); //# sourceMappingURL=sha2.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9zaGEyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxrQkFBa0IsR0FBR0Esa0JBQWtCLEdBQUdBLGNBQWMsR0FBR0EsY0FBYyxHQUFHQSxjQUFjLEdBQUdBLGNBQWMsR0FBR0Esa0JBQWtCLEdBQUdBLGtCQUFrQixHQUFHQSxjQUFjLEdBQUdBLGNBQWMsR0FBR0EsY0FBYyxHQUFHQSxjQUFjLEdBQUcsS0FBSztBQUNqTzs7Ozs7O0NBTUMsR0FDRCxNQUFNYyxXQUFXQyxtQkFBT0EsQ0FBQywyREFBVTtBQUNuQyxNQUFNQyxNQUFNRCxtQkFBT0EsQ0FBQyw2REFBVztBQUMvQixNQUFNRSxhQUFhRixtQkFBT0EsQ0FBQywrREFBWTtBQUN2Qzs7O0NBR0MsR0FDRCxrQkFBa0I7QUFDbEIsTUFBTUcsV0FBVyxhQUFhLEdBQUdDLFlBQVlDLElBQUksQ0FBQztJQUM5QztJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQ3BGO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFDcEY7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUNwRjtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQ3BGO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFDcEY7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUNwRjtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQ3BGO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7Q0FDdkY7QUFDRCw2REFBNkQsR0FDN0QsTUFBTUMsV0FBVyxhQUFhLEdBQUcsSUFBSUYsWUFBWTtBQUNqRCxNQUFNTixlQUFlQyxTQUFTUSxNQUFNO0lBQ2hDQyxZQUFZQyxZQUFZLEVBQUUs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RSxJQUFNLElBQUlsSCxlQUM1RCxnQ0FBZ0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mYXJjYXN0ZXJzdGF0cy8uL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL3NoYTIuanM/MTQwYiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc2hhNTEyXzIyNCA9IGV4cG9ydHMuc2hhNTEyXzI1NiA9IGV4cG9ydHMuc2hhMzg0ID0gZXhwb3J0cy5zaGE1MTIgPSBleHBvcnRzLnNoYTIyNCA9IGV4cG9ydHMuc2hhMjU2ID0gZXhwb3J0cy5TSEE1MTJfMjU2ID0gZXhwb3J0cy5TSEE1MTJfMjI0ID0gZXhwb3J0cy5TSEEzODQgPSBleHBvcnRzLlNIQTUxMiA9IGV4cG9ydHMuU0hBMjI0ID0gZXhwb3J0cy5TSEEyNTYgPSB2b2lkIDA7XG4vKipcbiAqIFNIQTIgaGFzaCBmdW5jdGlvbi4gQS5rLmEuIHNoYTI1Niwgc2hhMzg0LCBzaGE1MTIsIHNoYTUxMl8yMjQsIHNoYTUxMl8yNTYuXG4gKiBTSEEyNTYgaXMgdGhlIGZhc3Rlc3QgaGFzaCBpbXBsZW1lbnRhYmxlIGluIEpTLCBldmVuIGZhc3RlciB0aGFuIEJsYWtlMy5cbiAqIENoZWNrIG91dCBbUkZDIDQ2MzRdKGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvcmZjNDYzNCkgYW5kXG4gKiBbRklQUyAxODAtNF0oaHR0cHM6Ly9udmxwdWJzLm5pc3QuZ292L25pc3RwdWJzL0ZJUFMvTklTVC5GSVBTLjE4MC00LnBkZikuXG4gKiBAbW9kdWxlXG4gKi9cbmNvbnN0IF9tZF90c18xID0gcmVxdWlyZShcIi4vX21kLmpzXCIpO1xuY29uc3QgdTY0ID0gcmVxdWlyZShcIi4vX3U2NC5qc1wiKTtcbmNvbnN0IHV0aWxzX3RzXzEgPSByZXF1aXJlKFwiLi91dGlscy5qc1wiKTtcbi8qKlxuICogUm91bmQgY29uc3RhbnRzOlxuICogRmlyc3QgMzIgYml0cyBvZiBmcmFjdGlvbmFsIHBhcnRzIG9mIHRoZSBjdWJlIHJvb3RzIG9mIHRoZSBmaXJzdCA2NCBwcmltZXMgMi4uMzExKVxuICovXG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IFNIQTI1Nl9LID0gLyogQF9fUFVSRV9fICovIFVpbnQzMkFycmF5LmZyb20oW1xuICAgIDB4NDI4YTJmOTgsIDB4NzEzNzQ0OTEsIDB4YjVjMGZiY2YsIDB4ZTliNWRiYTUsIDB4Mzk1NmMyNWIsIDB4NTlmMTExZjEsIDB4OTIzZjgyYTQsIDB4YWIxYzVlZDUsXG4gICAgMHhkODA3YWE5OCwgMHgxMjgzNWIwMSwgMHgyNDMxODViZSwgMHg1NTBjN2RjMywgMHg3MmJlNWQ3NCwgMHg4MGRlYjFmZSwgMHg5YmRjMDZhNywgMHhjMTliZjE3NCxcbiAgICAweGU0OWI2OWMxLCAweGVmYmU0Nzg2LCAweDBmYzE5ZGM2LCAweDI0MGNhMWNjLCAweDJkZTkyYzZmLCAweDRhNzQ4NGFhLCAweDVjYjBhOWRjLCAweDc2Zjk4OGRhLFxuICAgIDB4OTgzZTUxNTIsIDB4YTgzMWM2NmQsIDB4YjAwMzI3YzgsIDB4YmY1OTdmYzcsIDB4YzZlMDBiZjMsIDB4ZDVhNzkxNDcsIDB4MDZjYTYzNTEsIDB4MTQyOTI5NjcsXG4gICAgMHgyN2I3MGE4NSwgMHgyZTFiMjEzOCwgMHg0ZDJjNmRmYywgMHg1MzM4MGQxMywgMHg2NTBhNzM1NCwgMHg3NjZhMGFiYiwgMHg4MWMyYzkyZSwgMHg5MjcyMmM4NSxcbiAgICAweGEyYmZlOGExLCAweGE4MWE2NjRiLCAweGMyNGI4YjcwLCAweGM3NmM1MWEzLCAweGQxOTJlODE5LCAweGQ2OTkwNjI0LCAweGY0MGUzNTg1LCAweDEwNmFhMDcwLFxuICAgIDB4MTlhNGMxMTYsIDB4MWUzNzZjMDgsIDB4Mjc0ODc3NGMsIDB4MzRiMGJjYjUsIDB4MzkxYzBjYjMsIDB4NGVkOGFhNGEsIDB4NWI5Y2NhNGYsIDB4NjgyZTZmZjMsXG4gICAgMHg3NDhmODJlZSwgMHg3OGE1NjM2ZiwgMHg4NGM4NzgxNCwgMHg4Y2M3MDIwOCwgMHg5MGJlZmZmYSwgMHhhNDUwNmNlYiwgMHhiZWY5YTNmNywgMHhjNjcxNzhmMlxuXSk7XG4vKiogUmV1c2FibGUgdGVtcG9yYXJ5IGJ1ZmZlci4gXCJXXCIgY29tZXMgc3RyYWlnaHQgZnJvbSBzcGVjLiAqL1xuY29uc3QgU0hBMjU2X1cgPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQzMkFycmF5KDY0KTtcbmNsYXNzIFNIQTI1NiBleHRlbmRzIF9tZF90c18xLkhhc2hNRCB7XG4gICAgY29uc3RydWN0b3Iob3V0cHV0TGVuID0gMzIpIHtcbiAgICAgICAgc3VwZXIoNjQsIG91dHB1dExlbiwgOCwgZmFsc2UpO1xuICAgICAgICAvLyBXZSBjYW5ub3QgdXNlIGFycmF5IGhlcmUgc2luY2UgYXJyYXkgYWxsb3dzIGluZGV4aW5nIGJ5IHZhcmlhYmxlXG4gICAgICAgIC8vIHdoaWNoIG1lYW5zIG9wdGltaXplci9jb21waWxlciBjYW5ub3QgdXNlIHJlZ2lzdGVycy5cbiAgICAgICAgdGhpcy5BID0gX21kX3RzXzEuU0hBMjU2X0lWWzBdIHwgMDtcbiAgICAgICAgdGhpcy5CID0gX21kX3RzXzEuU0hBMjU2X0lWWzFdIHwgMDtcbiAgICAgICAgdGhpcy5DID0gX21kX3RzXzEuU0hBMjU2X0lWWzJdIHwgMDtcbiAgICAgICAgdGhpcy5EID0gX21kX3RzXzEuU0hBMjU2X0lWWzNdIHwgMDtcbiAgICAgICAgdGhpcy5FID0gX21kX3RzXzEuU0hBMjU2X0lWWzRdIHwgMDtcbiAgICAgICAgdGhpcy5GID0gX21kX3RzXzEuU0hBMjU2X0lWWzVdIHwgMDtcbiAgICAgICAgdGhpcy5HID0gX21kX3RzXzEuU0hBMjU2X0lWWzZdIHwgMDtcbiAgICAgICAgdGhpcy5IID0gX21kX3RzXzEuU0hBMjU2X0lWWzddIHwgMDtcbiAgICB9XG4gICAgZ2V0KCkge1xuICAgICAgICBjb25zdCB7IEEsIEIsIEMsIEQsIEUsIEYsIEcsIEggfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBbQSwgQiwgQywgRCwgRSwgRiwgRywgSF07XG4gICAgfVxuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIHNldChBLCBCLCBDLCBELCBFLCBGLCBHLCBIKSB7XG4gICAgICAgIHRoaXMuQSA9IEEgfCAwO1xuICAgICAgICB0aGlzLkIgPSBCIHwgMDtcbiAgICAgICAgdGhpcy5DID0gQyB8IDA7XG4gICAgICAgIHRoaXMuRCA9IEQgfCAwO1xuICAgICAgICB0aGlzLkUgPSBFIHwgMDtcbiAgICAgICAgdGhpcy5GID0gRiB8IDA7XG4gICAgICAgIHRoaXMuRyA9IEcgfCAwO1xuICAgICAgICB0aGlzLkggPSBIIHwgMDtcbiAgICB9XG4gICAgcHJvY2Vzcyh2aWV3LCBvZmZzZXQpIHtcbiAgICAgICAgLy8gRXh0ZW5kIHRoZSBmaXJzdCAxNiB3b3JkcyBpbnRvIHRoZSByZW1haW5pbmcgNDggd29yZHMgd1sxNi4uNjNdIG9mIHRoZSBtZXNzYWdlIHNjaGVkdWxlIGFycmF5XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKywgb2Zmc2V0ICs9IDQpXG4gICAgICAgICAgICBTSEEyNTZfV1tpXSA9IHZpZXcuZ2V0VWludDMyKG9mZnNldCwgZmFsc2UpO1xuICAgICAgICBmb3IgKGxldCBpID0gMTY7IGkgPCA2NDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBXMTUgPSBTSEEyNTZfV1tpIC0gMTVdO1xuICAgICAgICAgICAgY29uc3QgVzIgPSBTSEEyNTZfV1tpIC0gMl07XG4gICAgICAgICAgICBjb25zdCBzMCA9ICgwLCB1dGlsc190c18xLnJvdHIpKFcxNSwgNykgXiAoMCwgdXRpbHNfdHNfMS5yb3RyKShXMTUsIDE4KSBeIChXMTUgPj4+IDMpO1xuICAgICAgICAgICAgY29uc3QgczEgPSAoMCwgdXRpbHNfdHNfMS5yb3RyKShXMiwgMTcpIF4gKDAsIHV0aWxzX3RzXzEucm90cikoVzIsIDE5KSBeIChXMiA+Pj4gMTApO1xuICAgICAgICAgICAgU0hBMjU2X1dbaV0gPSAoczEgKyBTSEEyNTZfV1tpIC0gN10gKyBzMCArIFNIQTI1Nl9XW2kgLSAxNl0pIHwgMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb21wcmVzc2lvbiBmdW5jdGlvbiBtYWluIGxvb3AsIDY0IHJvdW5kc1xuICAgICAgICBsZXQgeyBBLCBCLCBDLCBELCBFLCBGLCBHLCBIIH0gPSB0aGlzO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDY0OyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHNpZ21hMSA9ICgwLCB1dGlsc190c18xLnJvdHIpKEUsIDYpIF4gKDAsIHV0aWxzX3RzXzEucm90cikoRSwgMTEpIF4gKDAsIHV0aWxzX3RzXzEucm90cikoRSwgMjUpO1xuICAgICAgICAgICAgY29uc3QgVDEgPSAoSCArIHNpZ21hMSArICgwLCBfbWRfdHNfMS5DaGkpKEUsIEYsIEcpICsgU0hBMjU2X0tbaV0gKyBTSEEyNTZfV1tpXSkgfCAwO1xuICAgICAgICAgICAgY29uc3Qgc2lnbWEwID0gKDAsIHV0aWxzX3RzXzEucm90cikoQSwgMikgXiAoMCwgdXRpbHNfdHNfMS5yb3RyKShBLCAxMykgXiAoMCwgdXRpbHNfdHNfMS5yb3RyKShBLCAyMik7XG4gICAgICAgICAgICBjb25zdCBUMiA9IChzaWdtYTAgKyAoMCwgX21kX3RzXzEuTWFqKShBLCBCLCBDKSkgfCAwO1xuICAgICAgICAgICAgSCA9IEc7XG4gICAgICAgICAgICBHID0gRjtcbiAgICAgICAgICAgIEYgPSBFO1xuICAgICAgICAgICAgRSA9IChEICsgVDEpIHwgMDtcbiAgICAgICAgICAgIEQgPSBDO1xuICAgICAgICAgICAgQyA9IEI7XG4gICAgICAgICAgICBCID0gQTtcbiAgICAgICAgICAgIEEgPSAoVDEgKyBUMikgfCAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFkZCB0aGUgY29tcHJlc3NlZCBjaHVuayB0byB0aGUgY3VycmVudCBoYXNoIHZhbHVlXG4gICAgICAgIEEgPSAoQSArIHRoaXMuQSkgfCAwO1xuICAgICAgICBCID0gKEIgKyB0aGlzLkIpIHwgMDtcbiAgICAgICAgQyA9IChDICsgdGhpcy5DKSB8IDA7XG4gICAgICAgIEQgPSAoRCArIHRoaXMuRCkgfCAwO1xuICAgICAgICBFID0gKEUgKyB0aGlzLkUpIHwgMDtcbiAgICAgICAgRiA9IChGICsgdGhpcy5GKSB8IDA7XG4gICAgICAgIEcgPSAoRyArIHRoaXMuRykgfCAwO1xuICAgICAgICBIID0gKEggKyB0aGlzLkgpIHwgMDtcbiAgICAgICAgdGhpcy5zZXQoQSwgQiwgQywgRCwgRSwgRiwgRywgSCk7XG4gICAgfVxuICAgIHJvdW5kQ2xlYW4oKSB7XG4gICAgICAgICgwLCB1dGlsc190c18xLmNsZWFuKShTSEEyNTZfVyk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuc2V0KDAsIDAsIDAsIDAsIDAsIDAsIDAsIDApO1xuICAgICAgICAoMCwgdXRpbHNfdHNfMS5jbGVhbikodGhpcy5idWZmZXIpO1xuICAgIH1cbn1cbmV4cG9ydHMuU0hBMjU2ID0gU0hBMjU2O1xuY2xhc3MgU0hBMjI0IGV4dGVuZHMgU0hBMjU2IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoMjgpO1xuICAgICAgICB0aGlzLkEgPSBfbWRfdHNfMS5TSEEyMjRfSVZbMF0gfCAwO1xuICAgICAgICB0aGlzLkIgPSBfbWRfdHNfMS5TSEEyMjRfSVZbMV0gfCAwO1xuICAgICAgICB0aGlzLkMgPSBfbWRfdHNfMS5TSEEyMjRfSVZbMl0gfCAwO1xuICAgICAgICB0aGlzLkQgPSBfbWRfdHNfMS5TSEEyMjRfSVZbM10gfCAwO1xuICAgICAgICB0aGlzLkUgPSBfbWRfdHNfMS5TSEEyMjRfSVZbNF0gfCAwO1xuICAgICAgICB0aGlzLkYgPSBfbWRfdHNfMS5TSEEyMjRfSVZbNV0gfCAwO1xuICAgICAgICB0aGlzLkcgPSBfbWRfdHNfMS5TSEEyMjRfSVZbNl0gfCAwO1xuICAgICAgICB0aGlzLkggPSBfbWRfdHNfMS5TSEEyMjRfSVZbN10gfCAwO1xuICAgIH1cbn1cbmV4cG9ydHMuU0hBMjI0ID0gU0hBMjI0O1xuLy8gU0hBMi01MTIgaXMgc2xvd2VyIHRoYW4gc2hhMjU2IGluIGpzIGJlY2F1c2UgdTY0IG9wZXJhdGlvbnMgYXJlIHNsb3cuXG4vLyBSb3VuZCBjb250YW50c1xuLy8gRmlyc3QgMzIgYml0cyBvZiB0aGUgZnJhY3Rpb25hbCBwYXJ0cyBvZiB0aGUgY3ViZSByb290cyBvZiB0aGUgZmlyc3QgODAgcHJpbWVzIDIuLjQwOVxuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBLNTEyID0gLyogQF9fUFVSRV9fICovICgoKSA9PiB1NjQuc3BsaXQoW1xuICAgICcweDQyOGEyZjk4ZDcyOGFlMjInLCAnMHg3MTM3NDQ5MTIzZWY2NWNkJywgJzB4YjVjMGZiY2ZlYzRkM2IyZicsICcweGU5YjVkYmE1ODE4OWRiYmMnLFxuICAgICcweDM5NTZjMjViZjM0OGI1MzgnLCAnMHg1OWYxMTFmMWI2MDVkMDE5JywgJzB4OTIzZjgyYTRhZjE5NGY5YicsICcweGFiMWM1ZWQ1ZGE2ZDgxMTgnLFxuICAgICcweGQ4MDdhYTk4YTMwMzAyNDInLCAnMHgxMjgzNWIwMTQ1NzA2ZmJlJywgJzB4MjQzMTg1YmU0ZWU0YjI4YycsICcweDU1MGM3ZGMzZDVmZmI0ZTInLFxuICAgICcweDcyYmU1ZDc0ZjI3Yjg5NmYnLCAnMHg4MGRlYjFmZTNiMTY5NmIxJywgJzB4OWJkYzA2YTcyNWM3MTIzNScsICcweGMxOWJmMTc0Y2Y2OTI2OTQnLFxuICAgICcweGU0OWI2OWMxOWVmMTRhZDInLCAnMHhlZmJlNDc4NjM4NGYyNWUzJywgJzB4MGZjMTlkYzY4YjhjZDViNScsICcweDI0MGNhMWNjNzdhYzljNjUnLFxuICAgICcweDJkZTkyYzZmNTkyYjAyNzUnLCAnMHg0YTc0ODRhYTZlYTZlNDgzJywgJzB4NWNiMGE5ZGNiZDQxZmJkNCcsICcweDc2Zjk4OGRhODMxMTUzYjUnLFxuICAgICcweDk4M2U1MTUyZWU2NmRmYWInLCAnMHhhODMxYzY2ZDJkYjQzMjEwJywgJzB4YjAwMzI3Yzg5OGZiMjEzZicsICcweGJmNTk3ZmM3YmVlZjBlZTQnLFxuICAgICcweGM2ZTAwYmYzM2RhODhmYzInLCAnMHhkNWE3OTE0NzkzMGFhNzI1JywgJzB4MDZjYTYzNTFlMDAzODI2ZicsICcweDE0MjkyOTY3MGEwZTZlNzAnLFxuICAgICcweDI3YjcwYTg1NDZkMjJmZmMnLCAnMHgyZTFiMjEzODVjMjZjOTI2JywgJzB4NGQyYzZkZmM1YWM0MmFlZCcsICcweDUzMzgwZDEzOWQ5NWIzZGYnLFxuICAgICcweDY1MGE3MzU0OGJhZjYzZGUnLCAnMHg3NjZhMGFiYjNjNzdiMmE4JywgJzB4ODFjMmM5MmU0N2VkYWVlNicsICcweDkyNzIyYzg1MTQ4MjM1M2InLFxuICAgICcweGEyYmZlOGExNGNmMTAzNjQnLCAnMHhhODFhNjY0YmJjNDIzMDAxJywgJzB4YzI0YjhiNzBkMGY4OTc5MScsICcweGM3NmM1MWEzMDY1NGJlMzAnLFxuICAgICcweGQxOTJlODE5ZDZlZjUyMTgnLCAnMHhkNjk5MDYyNDU1NjVhOTEwJywgJzB4ZjQwZTM1ODU1NzcxMjAyYScsICcweDEwNmFhMDcwMzJiYmQxYjgnLFxuICAgICcweDE5YTRjMTE2YjhkMmQwYzgnLCAnMHgxZTM3NmMwODUxNDFhYjUzJywgJzB4Mjc0ODc3NGNkZjhlZWI5OScsICcweDM0YjBiY2I1ZTE5YjQ4YTgnLFxuICAgICcweDM5MWMwY2IzYzVjOTVhNjMnLCAnMHg0ZWQ4YWE0YWUzNDE4YWNiJywgJzB4NWI5Y2NhNGY3NzYzZTM3MycsICcweDY4MmU2ZmYzZDZiMmI4YTMnLFxuICAgICcweDc0OGY4MmVlNWRlZmIyZmMnLCAnMHg3OGE1NjM2ZjQzMTcyZjYwJywgJzB4ODRjODc4MTRhMWYwYWI3MicsICcweDhjYzcwMjA4MWE2NDM5ZWMnLFxuICAgICcweDkwYmVmZmZhMjM2MzFlMjgnLCAnMHhhNDUwNmNlYmRlODJiZGU5JywgJzB4YmVmOWEzZjdiMmM2NzkxNScsICcweGM2NzE3OGYyZTM3MjUzMmInLFxuICAgICcweGNhMjczZWNlZWEyNjYxOWMnLCAnMHhkMTg2YjhjNzIxYzBjMjA3JywgJzB4ZWFkYTdkZDZjZGUwZWIxZScsICcweGY1N2Q0ZjdmZWU2ZWQxNzgnLFxuICAgICcweDA2ZjA2N2FhNzIxNzZmYmEnLCAnMHgwYTYzN2RjNWEyYzg5OGE2JywgJzB4MTEzZjk4MDRiZWY5MGRhZScsICcweDFiNzEwYjM1MTMxYzQ3MWInLFxuICAgICcweDI4ZGI3N2Y1MjMwNDdkODQnLCAnMHgzMmNhYWI3YjQwYzcyNDkzJywgJzB4M2M5ZWJlMGExNWM5YmViYycsICcweDQzMWQ2N2M0OWMxMDBkNGMnLFxuICAgICcweDRjYzVkNGJlY2IzZTQyYjYnLCAnMHg1OTdmMjk5Y2ZjNjU3ZTJhJywgJzB4NWZjYjZmYWIzYWQ2ZmFlYycsICcweDZjNDQxOThjNGE0NzU4MTcnXG5dLm1hcChuID0+IEJpZ0ludChuKSkpKSgpO1xuY29uc3QgU0hBNTEyX0toID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBLNTEyWzBdKSgpO1xuY29uc3QgU0hBNTEyX0tsID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBLNTEyWzFdKSgpO1xuLy8gUmV1c2FibGUgdGVtcG9yYXJ5IGJ1ZmZlcnNcbmNvbnN0IFNIQTUxMl9XX0ggPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQzMkFycmF5KDgwKTtcbmNvbnN0IFNIQTUxMl9XX0wgPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQzMkFycmF5KDgwKTtcbmNsYXNzIFNIQTUxMiBleHRlbmRzIF9tZF90c18xLkhhc2hNRCB7XG4gICAgY29uc3RydWN0b3Iob3V0cHV0TGVuID0gNjQpIHtcbiAgICAgICAgc3VwZXIoMTI4LCBvdXRwdXRMZW4sIDE2LCBmYWxzZSk7XG4gICAgICAgIC8vIFdlIGNhbm5vdCB1c2UgYXJyYXkgaGVyZSBzaW5jZSBhcnJheSBhbGxvd3MgaW5kZXhpbmcgYnkgdmFyaWFibGVcbiAgICAgICAgLy8gd2hpY2ggbWVhbnMgb3B0aW1pemVyL2NvbXBpbGVyIGNhbm5vdCB1c2UgcmVnaXN0ZXJzLlxuICAgICAgICAvLyBoIC0tIGhpZ2ggMzIgYml0cywgbCAtLSBsb3cgMzIgYml0c1xuICAgICAgICB0aGlzLkFoID0gX21kX3RzXzEuU0hBNTEyX0lWWzBdIHwgMDtcbiAgICAgICAgdGhpcy5BbCA9IF9tZF90c18xLlNIQTUxMl9JVlsxXSB8IDA7XG4gICAgICAgIHRoaXMuQmggPSBfbWRfdHNfMS5TSEE1MTJfSVZbMl0gfCAwO1xuICAgICAgICB0aGlzLkJsID0gX21kX3RzXzEuU0hBNTEyX0lWWzNdIHwgMDtcbiAgICAgICAgdGhpcy5DaCA9IF9tZF90c18xLlNIQTUxMl9JVls0XSB8IDA7XG4gICAgICAgIHRoaXMuQ2wgPSBfbWRfdHNfMS5TSEE1MTJfSVZbNV0gfCAwO1xuICAgICAgICB0aGlzLkRoID0gX21kX3RzXzEuU0hBNTEyX0lWWzZdIHwgMDtcbiAgICAgICAgdGhpcy5EbCA9IF9tZF90c18xLlNIQTUxMl9JVls3XSB8IDA7XG4gICAgICAgIHRoaXMuRWggPSBfbWRfdHNfMS5TSEE1MTJfSVZbOF0gfCAwO1xuICAgICAgICB0aGlzLkVsID0gX21kX3RzXzEuU0hBNTEyX0lWWzldIHwgMDtcbiAgICAgICAgdGhpcy5GaCA9IF9tZF90c18xLlNIQTUxMl9JVlsxMF0gfCAwO1xuICAgICAgICB0aGlzLkZsID0gX21kX3RzXzEuU0hBNTEyX0lWWzExXSB8IDA7XG4gICAgICAgIHRoaXMuR2ggPSBfbWRfdHNfMS5TSEE1MTJfSVZbMTJdIHwgMDtcbiAgICAgICAgdGhpcy5HbCA9IF9tZF90c18xLlNIQTUxMl9JVlsxM10gfCAwO1xuICAgICAgICB0aGlzLkhoID0gX21kX3RzXzEuU0hBNTEyX0lWWzE0XSB8IDA7XG4gICAgICAgIHRoaXMuSGwgPSBfbWRfdHNfMS5TSEE1MTJfSVZbMTVdIHwgMDtcbiAgICB9XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgZ2V0KCkge1xuICAgICAgICBjb25zdCB7IEFoLCBBbCwgQmgsIEJsLCBDaCwgQ2wsIERoLCBEbCwgRWgsIEVsLCBGaCwgRmwsIEdoLCBHbCwgSGgsIEhsIH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gW0FoLCBBbCwgQmgsIEJsLCBDaCwgQ2wsIERoLCBEbCwgRWgsIEVsLCBGaCwgRmwsIEdoLCBHbCwgSGgsIEhsXTtcbiAgICB9XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgc2V0KEFoLCBBbCwgQmgsIEJsLCBDaCwgQ2wsIERoLCBEbCwgRWgsIEVsLCBGaCwgRmwsIEdoLCBHbCwgSGgsIEhsKSB7XG4gICAgICAgIHRoaXMuQWggPSBBaCB8IDA7XG4gICAgICAgIHRoaXMuQWwgPSBBbCB8IDA7XG4gICAgICAgIHRoaXMuQmggPSBCaCB8IDA7XG4gICAgICAgIHRoaXMuQmwgPSBCbCB8IDA7XG4gICAgICAgIHRoaXMuQ2ggPSBDaCB8IDA7XG4gICAgICAgIHRoaXMuQ2wgPSBDbCB8IDA7XG4gICAgICAgIHRoaXMuRGggPSBEaCB8IDA7XG4gICAgICAgIHRoaXMuRGwgPSBEbCB8IDA7XG4gICAgICAgIHRoaXMuRWggPSBFaCB8IDA7XG4gICAgICAgIHRoaXMuRWwgPSBFbCB8IDA7XG4gICAgICAgIHRoaXMuRmggPSBGaCB8IDA7XG4gICAgICAgIHRoaXMuRmwgPSBGbCB8IDA7XG4gICAgICAgIHRoaXMuR2ggPSBHaCB8IDA7XG4gICAgICAgIHRoaXMuR2wgPSBHbCB8IDA7XG4gICAgICAgIHRoaXMuSGggPSBIaCB8IDA7XG4gICAgICAgIHRoaXMuSGwgPSBIbCB8IDA7XG4gICAgfVxuICAgIHByb2Nlc3Modmlldywgb2Zmc2V0KSB7XG4gICAgICAgIC8vIEV4dGVuZCB0aGUgZmlyc3QgMTYgd29yZHMgaW50byB0aGUgcmVtYWluaW5nIDY0IHdvcmRzIHdbMTYuLjc5XSBvZiB0aGUgbWVzc2FnZSBzY2hlZHVsZSBhcnJheVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyssIG9mZnNldCArPSA0KSB7XG4gICAgICAgICAgICBTSEE1MTJfV19IW2ldID0gdmlldy5nZXRVaW50MzIob2Zmc2V0KTtcbiAgICAgICAgICAgIFNIQTUxMl9XX0xbaV0gPSB2aWV3LmdldFVpbnQzMigob2Zmc2V0ICs9IDQpKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMTY7IGkgPCA4MDsgaSsrKSB7XG4gICAgICAgICAgICAvLyBzMCA6PSAod1tpLTE1XSByaWdodHJvdGF0ZSAxKSB4b3IgKHdbaS0xNV0gcmlnaHRyb3RhdGUgOCkgeG9yICh3W2ktMTVdIHJpZ2h0c2hpZnQgNylcbiAgICAgICAgICAgIGNvbnN0IFcxNWggPSBTSEE1MTJfV19IW2kgLSAxNV0gfCAwO1xuICAgICAgICAgICAgY29uc3QgVzE1bCA9IFNIQTUxMl9XX0xbaSAtIDE1XSB8IDA7XG4gICAgICAgICAgICBjb25zdCBzMGggPSB1NjQucm90clNIKFcxNWgsIFcxNWwsIDEpIF4gdTY0LnJvdHJTSChXMTVoLCBXMTVsLCA4KSBeIHU2NC5zaHJTSChXMTVoLCBXMTVsLCA3KTtcbiAgICAgICAgICAgIGNvbnN0IHMwbCA9IHU2NC5yb3RyU0woVzE1aCwgVzE1bCwgMSkgXiB1NjQucm90clNMKFcxNWgsIFcxNWwsIDgpIF4gdTY0LnNoclNMKFcxNWgsIFcxNWwsIDcpO1xuICAgICAgICAgICAgLy8gczEgOj0gKHdbaS0yXSByaWdodHJvdGF0ZSAxOSkgeG9yICh3W2ktMl0gcmlnaHRyb3RhdGUgNjEpIHhvciAod1tpLTJdIHJpZ2h0c2hpZnQgNilcbiAgICAgICAgICAgIGNvbnN0IFcyaCA9IFNIQTUxMl9XX0hbaSAtIDJdIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IFcybCA9IFNIQTUxMl9XX0xbaSAtIDJdIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IHMxaCA9IHU2NC5yb3RyU0goVzJoLCBXMmwsIDE5KSBeIHU2NC5yb3RyQkgoVzJoLCBXMmwsIDYxKSBeIHU2NC5zaHJTSChXMmgsIFcybCwgNik7XG4gICAgICAgICAgICBjb25zdCBzMWwgPSB1NjQucm90clNMKFcyaCwgVzJsLCAxOSkgXiB1NjQucm90ckJMKFcyaCwgVzJsLCA2MSkgXiB1NjQuc2hyU0woVzJoLCBXMmwsIDYpO1xuICAgICAgICAgICAgLy8gU0hBMjU2X1dbaV0gPSBzMCArIHMxICsgU0hBMjU2X1dbaSAtIDddICsgU0hBMjU2X1dbaSAtIDE2XTtcbiAgICAgICAgICAgIGNvbnN0IFNVTWwgPSB1NjQuYWRkNEwoczBsLCBzMWwsIFNIQTUxMl9XX0xbaSAtIDddLCBTSEE1MTJfV19MW2kgLSAxNl0pO1xuICAgICAgICAgICAgY29uc3QgU1VNaCA9IHU2NC5hZGQ0SChTVU1sLCBzMGgsIHMxaCwgU0hBNTEyX1dfSFtpIC0gN10sIFNIQTUxMl9XX0hbaSAtIDE2XSk7XG4gICAgICAgICAgICBTSEE1MTJfV19IW2ldID0gU1VNaCB8IDA7XG4gICAgICAgICAgICBTSEE1MTJfV19MW2ldID0gU1VNbCB8IDA7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHsgQWgsIEFsLCBCaCwgQmwsIENoLCBDbCwgRGgsIERsLCBFaCwgRWwsIEZoLCBGbCwgR2gsIEdsLCBIaCwgSGwgfSA9IHRoaXM7XG4gICAgICAgIC8vIENvbXByZXNzaW9uIGZ1bmN0aW9uIG1haW4gbG9vcCwgODAgcm91bmRzXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgODA7IGkrKykge1xuICAgICAgICAgICAgLy8gUzEgOj0gKGUgcmlnaHRyb3RhdGUgMTQpIHhvciAoZSByaWdodHJvdGF0ZSAxOCkgeG9yIChlIHJpZ2h0cm90YXRlIDQxKVxuICAgICAgICAgICAgY29uc3Qgc2lnbWExaCA9IHU2NC5yb3RyU0goRWgsIEVsLCAxNCkgXiB1NjQucm90clNIKEVoLCBFbCwgMTgpIF4gdTY0LnJvdHJCSChFaCwgRWwsIDQxKTtcbiAgICAgICAgICAgIGNvbnN0IHNpZ21hMWwgPSB1NjQucm90clNMKEVoLCBFbCwgMTQpIF4gdTY0LnJvdHJTTChFaCwgRWwsIDE4KSBeIHU2NC5yb3RyQkwoRWgsIEVsLCA0MSk7XG4gICAgICAgICAgICAvL2NvbnN0IFQxID0gKEggKyBzaWdtYTEgKyBDaGkoRSwgRiwgRykgKyBTSEEyNTZfS1tpXSArIFNIQTI1Nl9XW2ldKSB8IDA7XG4gICAgICAgICAgICBjb25zdCBDSEloID0gKEVoICYgRmgpIF4gKH5FaCAmIEdoKTtcbiAgICAgICAgICAgIGNvbnN0IENISWwgPSAoRWwgJiBGbCkgXiAofkVsICYgR2wpO1xuICAgICAgICAgICAgLy8gVDEgPSBIICsgc2lnbWExICsgQ2hpKEUsIEYsIEcpICsgU0hBNTEyX0tbaV0gKyBTSEE1MTJfV1tpXVxuICAgICAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgICAgICBjb25zdCBUMWxsID0gdTY0LmFkZDVMKEhsLCBzaWdtYTFsLCBDSElsLCBTSEE1MTJfS2xbaV0sIFNIQTUxMl9XX0xbaV0pO1xuICAgICAgICAgICAgY29uc3QgVDFoID0gdTY0LmFkZDVIKFQxbGwsIEhoLCBzaWdtYTFoLCBDSEloLCBTSEE1MTJfS2hbaV0sIFNIQTUxMl9XX0hbaV0pO1xuICAgICAgICAgICAgY29uc3QgVDFsID0gVDFsbCB8IDA7XG4gICAgICAgICAgICAvLyBTMCA6PSAoYSByaWdodHJvdGF0ZSAyOCkgeG9yIChhIHJpZ2h0cm90YXRlIDM0KSB4b3IgKGEgcmlnaHRyb3RhdGUgMzkpXG4gICAgICAgICAgICBjb25zdCBzaWdtYTBoID0gdTY0LnJvdHJTSChBaCwgQWwsIDI4KSBeIHU2NC5yb3RyQkgoQWgsIEFsLCAzNCkgXiB1NjQucm90ckJIKEFoLCBBbCwgMzkpO1xuICAgICAgICAgICAgY29uc3Qgc2lnbWEwbCA9IHU2NC5yb3RyU0woQWgsIEFsLCAyOCkgXiB1NjQucm90ckJMKEFoLCBBbCwgMzQpIF4gdTY0LnJvdHJCTChBaCwgQWwsIDM5KTtcbiAgICAgICAgICAgIGNvbnN0IE1BSmggPSAoQWggJiBCaCkgXiAoQWggJiBDaCkgXiAoQmggJiBDaCk7XG4gICAgICAgICAgICBjb25zdCBNQUpsID0gKEFsICYgQmwpIF4gKEFsICYgQ2wpIF4gKEJsICYgQ2wpO1xuICAgICAgICAgICAgSGggPSBHaCB8IDA7XG4gICAgICAgICAgICBIbCA9IEdsIHwgMDtcbiAgICAgICAgICAgIEdoID0gRmggfCAwO1xuICAgICAgICAgICAgR2wgPSBGbCB8IDA7XG4gICAgICAgICAgICBGaCA9IEVoIHwgMDtcbiAgICAgICAgICAgIEZsID0gRWwgfCAwO1xuICAgICAgICAgICAgKHsgaDogRWgsIGw6IEVsIH0gPSB1NjQuYWRkKERoIHwgMCwgRGwgfCAwLCBUMWggfCAwLCBUMWwgfCAwKSk7XG4gICAgICAgICAgICBEaCA9IENoIHwgMDtcbiAgICAgICAgICAgIERsID0gQ2wgfCAwO1xuICAgICAgICAgICAgQ2ggPSBCaCB8IDA7XG4gICAgICAgICAgICBDbCA9IEJsIHwgMDtcbiAgICAgICAgICAgIEJoID0gQWggfCAwO1xuICAgICAgICAgICAgQmwgPSBBbCB8IDA7XG4gICAgICAgICAgICBjb25zdCBBbGwgPSB1NjQuYWRkM0woVDFsLCBzaWdtYTBsLCBNQUpsKTtcbiAgICAgICAgICAgIEFoID0gdTY0LmFkZDNIKEFsbCwgVDFoLCBzaWdtYTBoLCBNQUpoKTtcbiAgICAgICAgICAgIEFsID0gQWxsIHwgMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgdGhlIGNvbXByZXNzZWQgY2h1bmsgdG8gdGhlIGN1cnJlbnQgaGFzaCB2YWx1ZVxuICAgICAgICAoeyBoOiBBaCwgbDogQWwgfSA9IHU2NC5hZGQodGhpcy5BaCB8IDAsIHRoaXMuQWwgfCAwLCBBaCB8IDAsIEFsIHwgMCkpO1xuICAgICAgICAoeyBoOiBCaCwgbDogQmwgfSA9IHU2NC5hZGQodGhpcy5CaCB8IDAsIHRoaXMuQmwgfCAwLCBCaCB8IDAsIEJsIHwgMCkpO1xuICAgICAgICAoeyBoOiBDaCwgbDogQ2wgfSA9IHU2NC5hZGQodGhpcy5DaCB8IDAsIHRoaXMuQ2wgfCAwLCBDaCB8IDAsIENsIHwgMCkpO1xuICAgICAgICAoeyBoOiBEaCwgbDogRGwgfSA9IHU2NC5hZGQodGhpcy5EaCB8IDAsIHRoaXMuRGwgfCAwLCBEaCB8IDAsIERsIHwgMCkpO1xuICAgICAgICAoeyBoOiBFaCwgbDogRWwgfSA9IHU2NC5hZGQodGhpcy5FaCB8IDAsIHRoaXMuRWwgfCAwLCBFaCB8IDAsIEVsIHwgMCkpO1xuICAgICAgICAoeyBoOiBGaCwgbDogRmwgfSA9IHU2NC5hZGQodGhpcy5GaCB8IDAsIHRoaXMuRmwgfCAwLCBGaCB8IDAsIEZsIHwgMCkpO1xuICAgICAgICAoeyBoOiBHaCwgbDogR2wgfSA9IHU2NC5hZGQodGhpcy5HaCB8IDAsIHRoaXMuR2wgfCAwLCBHaCB8IDAsIEdsIHwgMCkpO1xuICAgICAgICAoeyBoOiBIaCwgbDogSGwgfSA9IHU2NC5hZGQodGhpcy5IaCB8IDAsIHRoaXMuSGwgfCAwLCBIaCB8IDAsIEhsIHwgMCkpO1xuICAgICAgICB0aGlzLnNldChBaCwgQWwsIEJoLCBCbCwgQ2gsIENsLCBEaCwgRGwsIEVoLCBFbCwgRmgsIEZsLCBHaCwgR2wsIEhoLCBIbCk7XG4gICAgfVxuICAgIHJvdW5kQ2xlYW4oKSB7XG4gICAgICAgICgwLCB1dGlsc190c18xLmNsZWFuKShTSEE1MTJfV19ILCBTSEE1MTJfV19MKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgKDAsIHV0aWxzX3RzXzEuY2xlYW4pKHRoaXMuYnVmZmVyKTtcbiAgICAgICAgdGhpcy5zZXQoMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCk7XG4gICAgfVxufVxuZXhwb3J0cy5TSEE1MTIgPSBTSEE1MTI7XG5jbGFzcyBTSEEzODQgZXh0ZW5kcyBTSEE1MTIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcig0OCk7XG4gICAgICAgIHRoaXMuQWggPSBfbWRfdHNfMS5TSEEzODRfSVZbMF0gfCAwO1xuICAgICAgICB0aGlzLkFsID0gX21kX3RzXzEuU0hBMzg0X0lWWzFdIHwgMDtcbiAgICAgICAgdGhpcy5CaCA9IF9tZF90c18xLlNIQTM4NF9JVlsyXSB8IDA7XG4gICAgICAgIHRoaXMuQmwgPSBfbWRfdHNfMS5TSEEzODRfSVZbM10gfCAwO1xuICAgICAgICB0aGlzLkNoID0gX21kX3RzXzEuU0hBMzg0X0lWWzRdIHwgMDtcbiAgICAgICAgdGhpcy5DbCA9IF9tZF90c18xLlNIQTM4NF9JVls1XSB8IDA7XG4gICAgICAgIHRoaXMuRGggPSBfbWRfdHNfMS5TSEEzODRfSVZbNl0gfCAwO1xuICAgICAgICB0aGlzLkRsID0gX21kX3RzXzEuU0hBMzg0X0lWWzddIHwgMDtcbiAgICAgICAgdGhpcy5FaCA9IF9tZF90c18xLlNIQTM4NF9JVls4XSB8IDA7XG4gICAgICAgIHRoaXMuRWwgPSBfbWRfdHNfMS5TSEEzODRfSVZbOV0gfCAwO1xuICAgICAgICB0aGlzLkZoID0gX21kX3RzXzEuU0hBMzg0X0lWWzEwXSB8IDA7XG4gICAgICAgIHRoaXMuRmwgPSBfbWRfdHNfMS5TSEEzODRfSVZbMTFdIHwgMDtcbiAgICAgICAgdGhpcy5HaCA9IF9tZF90c18xLlNIQTM4NF9JVlsxMl0gfCAwO1xuICAgICAgICB0aGlzLkdsID0gX21kX3RzXzEuU0hBMzg0X0lWWzEzXSB8IDA7XG4gICAgICAgIHRoaXMuSGggPSBfbWRfdHNfMS5TSEEzODRfSVZbMTRdIHwgMDtcbiAgICAgICAgdGhpcy5IbCA9IF9tZF90c18xLlNIQTM4NF9JVlsxNV0gfCAwO1xuICAgIH1cbn1cbmV4cG9ydHMuU0hBMzg0ID0gU0hBMzg0O1xuLyoqXG4gKiBUcnVuY2F0ZWQgU0hBNTEyLzI1NiBhbmQgU0hBNTEyLzIyNC5cbiAqIFNIQTUxMl9JViBpcyBYT1JlZCB3aXRoIDB4YTVhNWE1YTVhNWE1YTVhNSwgdGhlbiB1c2VkIGFzIFwiaW50ZXJtZWRpYXJ5XCIgSVYgb2YgU0hBNTEyL3QuXG4gKiBUaGVuIHQgaGFzaGVzIHN0cmluZyB0byBwcm9kdWNlIHJlc3VsdCBJVi5cbiAqIFNlZSBgdGVzdC9taXNjL3NoYTItZ2VuLWl2LmpzYC5cbiAqL1xuLyoqIFNIQTUxMi8yMjQgSVYgKi9cbmNvbnN0IFQyMjRfSVYgPSAvKiBAX19QVVJFX18gKi8gVWludDMyQXJyYXkuZnJvbShbXG4gICAgMHg4YzNkMzdjOCwgMHgxOTU0NGRhMiwgMHg3M2UxOTk2NiwgMHg4OWRjZDRkNiwgMHgxZGZhYjdhZSwgMHgzMmZmOWM4MiwgMHg2NzlkZDUxNCwgMHg1ODJmOWZjZixcbiAgICAweDBmNmQyYjY5LCAweDdiZDQ0ZGE4LCAweDc3ZTM2ZjczLCAweDA0YzQ4OTQyLCAweDNmOWQ4NWE4LCAweDZhMWQzNmM4LCAweDExMTJlNmFkLCAweDkxZDY5MmExLFxuXSk7XG4vKiogU0hBNTEyLzI1NiBJViAqL1xuY29uc3QgVDI1Nl9JViA9IC8qIEBfX1BVUkVfXyAqLyBVaW50MzJBcnJheS5mcm9tKFtcbiAgICAweDIyMzEyMTk0LCAweGZjMmJmNzJjLCAweDlmNTU1ZmEzLCAweGM4NGM2NGMyLCAweDIzOTNiODZiLCAweDZmNTNiMTUxLCAweDk2Mzg3NzE5LCAweDU5NDBlYWJkLFxuICAgIDB4OTYyODNlZTIsIDB4YTg4ZWZmZTMsIDB4YmU1ZTFlMjUsIDB4NTM4NjM5OTIsIDB4MmIwMTk5ZmMsIDB4MmM4NWI4YWEsIDB4MGViNzJkZGMsIDB4ODFjNTJjYTIsXG5dKTtcbmNsYXNzIFNIQTUxMl8yMjQgZXh0ZW5kcyBTSEE1MTIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigyOCk7XG4gICAgICAgIHRoaXMuQWggPSBUMjI0X0lWWzBdIHwgMDtcbiAgICAgICAgdGhpcy5BbCA9IFQyMjRfSVZbMV0gfCAwO1xuICAgICAgICB0aGlzLkJoID0gVDIyNF9JVlsyXSB8IDA7XG4gICAgICAgIHRoaXMuQmwgPSBUMjI0X0lWWzNdIHwgMDtcbiAgICAgICAgdGhpcy5DaCA9IFQyMjRfSVZbNF0gfCAwO1xuICAgICAgICB0aGlzLkNsID0gVDIyNF9JVls1XSB8IDA7XG4gICAgICAgIHRoaXMuRGggPSBUMjI0X0lWWzZdIHwgMDtcbiAgICAgICAgdGhpcy5EbCA9IFQyMjRfSVZbN10gfCAwO1xuICAgICAgICB0aGlzLkVoID0gVDIyNF9JVls4XSB8IDA7XG4gICAgICAgIHRoaXMuRWwgPSBUMjI0X0lWWzldIHwgMDtcbiAgICAgICAgdGhpcy5GaCA9IFQyMjRfSVZbMTBdIHwgMDtcbiAgICAgICAgdGhpcy5GbCA9IFQyMjRfSVZbMTFdIHwgMDtcbiAgICAgICAgdGhpcy5HaCA9IFQyMjRfSVZbMTJdIHwgMDtcbiAgICAgICAgdGhpcy5HbCA9IFQyMjRfSVZbMTNdIHwgMDtcbiAgICAgICAgdGhpcy5IaCA9IFQyMjRfSVZbMTRdIHwgMDtcbiAgICAgICAgdGhpcy5IbCA9IFQyMjRfSVZbMTVdIHwgMDtcbiAgICB9XG59XG5leHBvcnRzLlNIQTUxMl8yMjQgPSBTSEE1MTJfMjI0O1xuY2xhc3MgU0hBNTEyXzI1NiBleHRlbmRzIFNIQTUxMiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKDMyKTtcbiAgICAgICAgdGhpcy5BaCA9IFQyNTZfSVZbMF0gfCAwO1xuICAgICAgICB0aGlzLkFsID0gVDI1Nl9JVlsxXSB8IDA7XG4gICAgICAgIHRoaXMuQmggPSBUMjU2X0lWWzJdIHwgMDtcbiAgICAgICAgdGhpcy5CbCA9IFQyNTZfSVZbM10gfCAwO1xuICAgICAgICB0aGlzLkNoID0gVDI1Nl9JVls0XSB8IDA7XG4gICAgICAgIHRoaXMuQ2wgPSBUMjU2X0lWWzVdIHwgMDtcbiAgICAgICAgdGhpcy5EaCA9IFQyNTZfSVZbNl0gfCAwO1xuICAgICAgICB0aGlzLkRsID0gVDI1Nl9JVls3XSB8IDA7XG4gICAgICAgIHRoaXMuRWggPSBUMjU2X0lWWzhdIHwgMDtcbiAgICAgICAgdGhpcy5FbCA9IFQyNTZfSVZbOV0gfCAwO1xuICAgICAgICB0aGlzLkZoID0gVDI1Nl9JVlsxMF0gfCAwO1xuICAgICAgICB0aGlzLkZsID0gVDI1Nl9JVlsxMV0gfCAwO1xuICAgICAgICB0aGlzLkdoID0gVDI1Nl9JVlsxMl0gfCAwO1xuICAgICAgICB0aGlzLkdsID0gVDI1Nl9JVlsxM10gfCAwO1xuICAgICAgICB0aGlzLkhoID0gVDI1Nl9JVlsxNF0gfCAwO1xuICAgICAgICB0aGlzLkhsID0gVDI1Nl9JVlsxNV0gfCAwO1xuICAgIH1cbn1cbmV4cG9ydHMuU0hBNTEyXzI1NiA9IFNIQTUxMl8yNTY7XG4vKipcbiAqIFNIQTItMjU2IGhhc2ggZnVuY3Rpb24gZnJvbSBSRkMgNDYzNC5cbiAqXG4gKiBJdCBpcyB0aGUgZmFzdGVzdCBKUyBoYXNoLCBldmVuIGZhc3RlciB0aGFuIEJsYWtlMy5cbiAqIFRvIGJyZWFrIHNoYTI1NiB1c2luZyBiaXJ0aGRheSBhdHRhY2ssIGF0dGFja2VycyBuZWVkIHRvIHRyeSAyXjEyOCBoYXNoZXMuXG4gKiBCVEMgbmV0d29yayBpcyBkb2luZyAyXjcwIGhhc2hlcy9zZWMgKDJeOTUgaGFzaGVzL3llYXIpIGFzIHBlciAyMDI1LlxuICovXG5leHBvcnRzLnNoYTI1NiA9ICgwLCB1dGlsc190c18xLmNyZWF0ZUhhc2hlcikoKCkgPT4gbmV3IFNIQTI1NigpKTtcbi8qKiBTSEEyLTIyNCBoYXNoIGZ1bmN0aW9uIGZyb20gUkZDIDQ2MzQgKi9cbmV4cG9ydHMuc2hhMjI0ID0gKDAsIHV0aWxzX3RzXzEuY3JlYXRlSGFzaGVyKSgoKSA9PiBuZXcgU0hBMjI0KCkpO1xuLyoqIFNIQTItNTEyIGhhc2ggZnVuY3Rpb24gZnJvbSBSRkMgNDYzNC4gKi9cbmV4cG9ydHMuc2hhNTEyID0gKDAsIHV0aWxzX3RzXzEuY3JlYXRlSGFzaGVyKSgoKSA9PiBuZXcgU0hBNTEyKCkpO1xuLyoqIFNIQTItMzg0IGhhc2ggZnVuY3Rpb24gZnJvbSBSRkMgNDYzNC4gKi9cbmV4cG9ydHMuc2hhMzg0ID0gKDAsIHV0aWxzX3RzXzEuY3JlYXRlSGFzaGVyKSgoKSA9PiBuZXcgU0hBMzg0KCkpO1xuLyoqXG4gKiBTSEEyLTUxMi8yNTYgXCJ0cnVuY2F0ZWRcIiBoYXNoIGZ1bmN0aW9uLCB3aXRoIGltcHJvdmVkIHJlc2lzdGFuY2UgdG8gbGVuZ3RoIGV4dGVuc2lvbiBhdHRhY2tzLlxuICogU2VlIHRoZSBwYXBlciBvbiBbdHJ1bmNhdGVkIFNIQTUxMl0oaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAxMC81NDgucGRmKS5cbiAqL1xuZXhwb3J0cy5zaGE1MTJfMjU2ID0gKDAsIHV0aWxzX3RzXzEuY3JlYXRlSGFzaGVyKSgoKSA9PiBuZXcgU0hBNTEyXzI1NigpKTtcbi8qKlxuICogU0hBMi01MTIvMjI0IFwidHJ1bmNhdGVkXCIgaGFzaCBmdW5jdGlvbiwgd2l0aCBpbXByb3ZlZCByZXNpc3RhbmNlIHRvIGxlbmd0aCBleHRlbnNpb24gYXR0YWNrcy5cbiAqIFNlZSB0aGUgcGFwZXIgb24gW3RydW5jYXRlZCBTSEE1MTJdKGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMTAvNTQ4LnBkZikuXG4gKi9cbmV4cG9ydHMuc2hhNTEyXzIyNCA9ICgwLCB1dGlsc190c18xLmNyZWF0ZUhhc2hlcikoKCkgPT4gbmV3IFNIQTUxMl8yMjQoKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaGEyLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInNoYTUxMl8yMjQiLCJzaGE1MTJfMjU2Iiwic2hhMzg0Iiwic2hhNTEyIiwic2hhMjI0Iiwic2hhMjU2IiwiU0hBNTEyXzI1NiIsIlNIQTUxMl8yMjQiLCJTSEEzODQiLCJTSEE1MTIiLCJTSEEyMjQiLCJTSEEyNTYiLCJfbWRfdHNfMSIsInJlcXVpcmUiLCJ1NjQiLCJ1dGlsc190c18xIiwiU0hBMjU2X0siLCJVaW50MzJBcnJheSIsImZyb20iLCJTSEEyNTZfVyIsIkhhc2hNRCIsImNvbnN0cnVjdG9yIiwib3V0cHV0TGVuIiwiQSIsIlNIQTI1Nl9JViIsIkIiLCJDIiwiRCIsIkUiLCJGIiwiRyIsIkgiLCJnZXQiLCJzZXQiLCJwcm9jZXNzIiwidmlldyIsIm9mZnNldCIsImkiLCJnZXRVaW50MzIiLCJXMTUiLCJXMiIsInMwIiwicm90ciIsInMxIiwic2lnbWExIiwiVDEiLCJDaGkiLCJzaWdtYTAiLCJUMiIsIk1haiIsInJvdW5kQ2xlYW4iLCJjbGVhbiIsImRlc3Ryb3kiLCJidWZmZXIiLCJTSEEyMjRfSVYiLCJLNTEyIiwic3BsaXQiLCJtYXAiLCJuIiwiQmlnSW50IiwiU0hBNTEyX0toIiwiU0hBNTEyX0tsIiwiU0hBNTEyX1dfSCIsIlNIQTUxMl9XX0wiLCJBaCIsIlNIQTUxMl9JViIsIkFsIiwiQmgiLCJCbCIsIkNoIiwiQ2wiLCJEaCIsIkRsIiwiRWgiLCJFbCIsIkZoIiwiRmwiLCJHaCIsIkdsIiwiSGgiLCJIbCIsIlcxNWgiLCJXMTVsIiwiczBoIiwicm90clNIIiwic2hyU0giLCJzMGwiLCJyb3RyU0wiLCJzaHJTTCIsIlcyaCIsIlcybCIsInMxaCIsInJvdHJCSCIsInMxbCIsInJvdHJCTCIsIlNVTWwiLCJhZGQ0TCIsIlNVTWgiLCJhZGQ0SCIsInNpZ21hMWgiLCJzaWdtYTFsIiwiQ0hJaCIsIkNISWwiLCJUMWxsIiwiYWRkNUwiLCJUMWgiLCJhZGQ1SCIsIlQxbCIsInNpZ21hMGgiLCJzaWdtYTBsIiwiTUFKaCIsIk1BSmwiLCJoIiwibCIsImFkZCIsIkFsbCIsImFkZDNMIiwiYWRkM0giLCJTSEEzODRfSVYiLCJUMjI0X0lWIiwiVDI1Nl9JViIsImNyZWF0ZUhhc2hlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@noble/hashes/sha2.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@noble/hashes/sha256.js":
/*!**********************************************!*\
  !*** ./node_modules/@noble/hashes/sha256.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.sha224 = exports.SHA224 = exports.sha256 = exports.SHA256 = void 0;\n/**\n * SHA2-256 a.k.a. sha256. In JS, it is the fastest hash, even faster than Blake3.\n *\n * To break sha256 using birthday attack, attackers need to try 2^128 hashes.\n * BTC network is doing 2^70 hashes/sec (2^95 hashes/year) as per 2025.\n *\n * Check out [FIPS 180-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf).\n * @module\n * @deprecated\n */ const sha2_ts_1 = __webpack_require__(/*! ./sha2.js */ \"(rsc)/./node_modules/@noble/hashes/sha2.js\");\n/** @deprecated Use import from `noble/hashes/sha2` module */ exports.SHA256 = sha2_ts_1.SHA256;\n/** @deprecated Use import from `noble/hashes/sha2` module */ exports.sha256 = sha2_ts_1.sha256;\n/** @deprecated Use import from `noble/hashes/sha2` module */ exports.SHA224 = sha2_ts_1.SHA224;\n/** @deprecated Use import from `noble/hashes/sha2` module */ exports.sha224 = sha2_ts_1.sha224; //# sourceMappingURL=sha256.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9zaGEyNTYuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGNBQWMsR0FBR0EsY0FBYyxHQUFHQSxjQUFjLEdBQUdBLGNBQWMsR0FBRyxLQUFLO0FBQ3pFOzs7Ozs7Ozs7Q0FTQyxHQUNELE1BQU1NLFlBQVlDLG1CQUFPQSxDQUFDLDZEQUFXO0FBQ3JDLDJEQUEyRCxHQUMzRFAsY0FBYyxHQUFHTSxVQUFVRCxNQUFNO0FBQ2pDLDJEQUEyRCxHQUMzREwsY0FBYyxHQUFHTSxVQUFVRixNQUFNO0FBQ2pDLDJEQUEyRCxHQUMzREosY0FBYyxHQUFHTSxVQUFVSCxNQUFNO0FBQ2pDLDJEQUEyRCxHQUMzREgsY0FBYyxHQUFHTSxVQUFVSixNQUFNLEVBQ2pDLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL2ZhcmNhc3RlcnN0YXRzLy4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvc2hhMjU2LmpzPzI5NTkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnNoYTIyNCA9IGV4cG9ydHMuU0hBMjI0ID0gZXhwb3J0cy5zaGEyNTYgPSBleHBvcnRzLlNIQTI1NiA9IHZvaWQgMDtcbi8qKlxuICogU0hBMi0yNTYgYS5rLmEuIHNoYTI1Ni4gSW4gSlMsIGl0IGlzIHRoZSBmYXN0ZXN0IGhhc2gsIGV2ZW4gZmFzdGVyIHRoYW4gQmxha2UzLlxuICpcbiAqIFRvIGJyZWFrIHNoYTI1NiB1c2luZyBiaXJ0aGRheSBhdHRhY2ssIGF0dGFja2VycyBuZWVkIHRvIHRyeSAyXjEyOCBoYXNoZXMuXG4gKiBCVEMgbmV0d29yayBpcyBkb2luZyAyXjcwIGhhc2hlcy9zZWMgKDJeOTUgaGFzaGVzL3llYXIpIGFzIHBlciAyMDI1LlxuICpcbiAqIENoZWNrIG91dCBbRklQUyAxODAtNF0oaHR0cHM6Ly9udmxwdWJzLm5pc3QuZ292L25pc3RwdWJzL0ZJUFMvTklTVC5GSVBTLjE4MC00LnBkZikuXG4gKiBAbW9kdWxlXG4gKiBAZGVwcmVjYXRlZFxuICovXG5jb25zdCBzaGEyX3RzXzEgPSByZXF1aXJlKFwiLi9zaGEyLmpzXCIpO1xuLyoqIEBkZXByZWNhdGVkIFVzZSBpbXBvcnQgZnJvbSBgbm9ibGUvaGFzaGVzL3NoYTJgIG1vZHVsZSAqL1xuZXhwb3J0cy5TSEEyNTYgPSBzaGEyX3RzXzEuU0hBMjU2O1xuLyoqIEBkZXByZWNhdGVkIFVzZSBpbXBvcnQgZnJvbSBgbm9ibGUvaGFzaGVzL3NoYTJgIG1vZHVsZSAqL1xuZXhwb3J0cy5zaGEyNTYgPSBzaGEyX3RzXzEuc2hhMjU2O1xuLyoqIEBkZXByZWNhdGVkIFVzZSBpbXBvcnQgZnJvbSBgbm9ibGUvaGFzaGVzL3NoYTJgIG1vZHVsZSAqL1xuZXhwb3J0cy5TSEEyMjQgPSBzaGEyX3RzXzEuU0hBMjI0O1xuLyoqIEBkZXByZWNhdGVkIFVzZSBpbXBvcnQgZnJvbSBgbm9ibGUvaGFzaGVzL3NoYTJgIG1vZHVsZSAqL1xuZXhwb3J0cy5zaGEyMjQgPSBzaGEyX3RzXzEuc2hhMjI0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2hhMjU2LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInNoYTIyNCIsIlNIQTIyNCIsInNoYTI1NiIsIlNIQTI1NiIsInNoYTJfdHNfMSIsInJlcXVpcmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@noble/hashes/sha256.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@noble/hashes/sha3.js":
/*!********************************************!*\
  !*** ./node_modules/@noble/hashes/sha3.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.shake256 = exports.shake128 = exports.keccak_512 = exports.keccak_384 = exports.keccak_256 = exports.keccak_224 = exports.sha3_512 = exports.sha3_384 = exports.sha3_256 = exports.sha3_224 = exports.Keccak = void 0;\nexports.keccakP = keccakP;\n/**\n * SHA3 (keccak) hash function, based on a new \"Sponge function\" design.\n * Different from older hashes, the internal state is bigger than output size.\n *\n * Check out [FIPS-202](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf),\n * [Website](https://keccak.team/keccak.html),\n * [the differences between SHA-3 and Keccak](https://crypto.stackexchange.com/questions/15727/what-are-the-key-differences-between-the-draft-sha-3-standard-and-the-keccak-sub).\n *\n * Check out `sha3-addons` module for cSHAKE, k12, and others.\n * @module\n */ const _u64_ts_1 = __webpack_require__(/*! ./_u64.js */ \"(rsc)/./node_modules/@noble/hashes/_u64.js\");\n// prettier-ignore\nconst utils_ts_1 = __webpack_require__(/*! ./utils.js */ \"(rsc)/./node_modules/@noble/hashes/utils.js\");\n// No __PURE__ annotations in sha3 header:\n// EVERYTHING is in fact used on every export.\n// Various per round constants calculations\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst _7n = BigInt(7);\nconst _256n = BigInt(256);\nconst _0x71n = BigInt(0x71);\nconst SHA3_PI = [];\nconst SHA3_ROTL = [];\nconst _SHA3_IOTA = [];\nfor(let round = 0, R = _1n, x = 1, y = 0; round < 24; round++){\n    // Pi\n    [x, y] = [\n        y,\n        (2 * x + 3 * y) % 5\n    ];\n    SHA3_PI.push(2 * (5 * y + x));\n    // Rotational\n    SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);\n    // Iota\n    let t = _0n;\n    for(let j = 0; j < 7; j++){\n        R = (R << _1n ^ (R >> _7n) * _0x71n) % _256n;\n        if (R & _2n) t ^= _1n << (_1n << /* @__PURE__ */ BigInt(j)) - _1n;\n    }\n    _SHA3_IOTA.push(t);\n}\nconst IOTAS = (0, _u64_ts_1.split)(_SHA3_IOTA, true);\nconst SHA3_IOTA_H = IOTAS[0];\nconst SHA3_IOTA_L = IOTAS[1];\n// Left rotation (without 0, 32, 64)\nconst rotlH = (h, l, s)=>s > 32 ? (0, _u64_ts_1.rotlBH)(h, l, s) : (0, _u64_ts_1.rotlSH)(h, l, s);\nconst rotlL = (h, l, s)=>s > 32 ? (0, _u64_ts_1.rotlBL)(h, l, s) : (0, _u64_ts_1.rotlSL)(h, l, s);\n/** `keccakf1600` internal function, additionally allows to adjust round count. */ function keccakP(s, rounds = 24) {\n    const B = new Uint32Array(5 * 2);\n    // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)\n    for(let round = 24 - rounds; round < 24; round++){\n        // Theta Œ∏\n        for(let x = 0; x < 10; x++)B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];\n        for(let x = 0; x < 10; x += 2){\n            const idx1 = (x + 8) % 10;\n            const idx0 = (x + 2) % 10;\n            const B0 = B[idx0];\n            const B1 = B[idx0 + 1];\n            const Th = rotlH(B0, B1, 1) ^ B[idx1];\n            const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];\n            for(let y = 0; y < 50; y += 10){\n                s[x + y] ^= Th;\n                s[x + y + 1] ^= Tl;\n            }\n        }\n        // Rho (œÅ) and Pi (œÄ)\n        let curH = s[2];\n        let curL = s[3];\n        for(let t = 0; t < 24; t++){\n            const shift = SHA3_ROTL[t];\n            const Th = rotlH(curH, curL, shift);\n            const Tl = rotlL(curH, curL, shift);\n            const PI = SHA3_PI[t];\n            curH = s[PI];\n            curL = s[PI + 1];\n            s[PI] = Th;\n            s[PI + 1] = Tl;\n        }\n        // Chi (œá)\n        for(let y = 0; y < 50; y += 10){\n            for(let x = 0; x < 10; x++)B[x] = s[y + x];\n            for(let x = 0; x < 10; x++)s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];\n        }\n        // Iota (Œπ)\n        s[0] ^= SHA3_IOTA_H[round];\n        s[1] ^= SHA3_IOTA_L[round];\n    }\n    (0, utils_ts_1.clean)(B);\n}\n/** Keccak sponge function. */ class Keccak extends utils_ts_1.Hash {\n    // NOTE: we accept arguments in bytes instead of bits here.\n    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24){\n        super();\n        this.pos = 0;\n        this.posOut = 0;\n        this.finished = false;\n        this.destroyed = false;\n        this.enableXOF = false;\n        this.blockLen = blockLen;\n        this.suffix = suffix;\n        this.outputLen = outputLen;\n        this.enableXOF = enableXOF;\n        this.rounds = rounds;\n        // Can be passed from user as dkLen\n        (0, utils_ts_1.anumber)(outputLen);\n        // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes\n        // 0 < blockLen < 200\n        if (!(0 < blockLen && blockLen < 200)) throw new Error(\"only keccak-f1600 function is supported\");\n        this.state = new Uint8Array(200);\n        this.state32 = (0, utils_ts_1.u32)(this.state);\n    }\n    clone() {\n        return this._cloneInto();\n    }\n    keccak() {\n        (0, utils_ts_1.swap32IfBE)(this.state32);\n        keccakP(this.state32, this.rounds);\n        (0, utils_ts_1.swap32IfBE)(this.state32);\n        this.posOut = 0;\n        this.pos = 0;\n    }\n    update(data) {\n        (0, utils_ts_1.aexists)(this);\n        data = (0, utils_ts_1.toBytes)(data);\n        (0, utils_ts_1.abytes)(data);\n        const { blockLen, state } = this;\n        const len = data.length;\n        for(let pos = 0; pos < len;){\n            const take = Math.min(blockLen - this.pos, len - pos);\n            for(let i = 0; i < take; i++)state[this.pos++] ^= data[pos++];\n            if (this.pos === blockLen) this.keccak();\n        }\n        return this;\n    }\n    finish() {\n        if (this.finished) return;\n        this.finished = true;\n        const { state, suffix, pos, blockLen } = this;\n        // Do the padding\n        state[pos] ^= suffix;\n        if ((suffix & 0x80) !== 0 && pos === blockLen - 1) this.keccak();\n        state[blockLen - 1] ^= 0x80;\n        this.keccak();\n    }\n    writeInto(out) {\n        (0, utils_ts_1.aexists)(this, false);\n        (0, utils_ts_1.abytes)(out);\n        this.finish();\n        const bufferOut = this.state;\n        const { blockLen } = this;\n        for(let pos = 0, len = out.length; pos < len;){\n            if (this.posOut >= blockLen) this.keccak();\n            const take = Math.min(blockLen - this.posOut, len - pos);\n            out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);\n            this.posOut += take;\n            pos += take;\n        }\n        return out;\n    }\n    xofInto(out) {\n        // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF\n        if (!this.enableXOF) throw new Error(\"XOF is not possible for this instance\");\n        return this.writeInto(out);\n    }\n    xof(bytes) {\n        (0, utils_ts_1.anumber)(bytes);\n        return this.xofInto(new Uint8Array(bytes));\n    }\n    digestInto(out) {\n        (0, utils_ts_1.aoutput)(out, this);\n        if (this.finished) throw new Error(\"digest() was already called\");\n        this.writeInto(out);\n        this.destroy();\n        return out;\n    }\n    digest() {\n        return this.digestInto(new Uint8Array(this.outputLen));\n    }\n    destroy() {\n        this.destroyed = true;\n        (0, utils_ts_1.clean)(this.state);\n    }\n    _cloneInto(to) {\n        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;\n        to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));\n        to.state32.set(this.state32);\n        to.pos = this.pos;\n        to.posOut = this.posOut;\n        to.finished = this.finished;\n        to.rounds = rounds;\n        // Suffix can change in cSHAKE\n        to.suffix = suffix;\n        to.outputLen = outputLen;\n        to.enableXOF = enableXOF;\n        to.destroyed = this.destroyed;\n        return to;\n    }\n}\nexports.Keccak = Keccak;\nconst gen = (suffix, blockLen, outputLen)=>(0, utils_ts_1.createHasher)(()=>new Keccak(blockLen, suffix, outputLen));\n/** SHA3-224 hash function. */ exports.sha3_224 = (()=>gen(0x06, 144, 224 / 8))();\n/** SHA3-256 hash function. Different from keccak-256. */ exports.sha3_256 = (()=>gen(0x06, 136, 256 / 8))();\n/** SHA3-384 hash function. */ exports.sha3_384 = (()=>gen(0x06, 104, 384 / 8))();\n/** SHA3-512 hash function. */ exports.sha3_512 = (()=>gen(0x06, 72, 512 / 8))();\n/** keccak-224 hash function. */ exports.keccak_224 = (()=>gen(0x01, 144, 224 / 8))();\n/** keccak-256 hash function. Different from SHA3-256. */ exports.keccak_256 = (()=>gen(0x01, 136, 256 / 8))();\n/** keccak-384 hash function. */ exports.keccak_384 = (()=>gen(0x01, 104, 384 / 8))();\n/** keccak-512 hash function. */ exports.keccak_512 = (()=>gen(0x01, 72, 512 / 8))();\nconst genShake = (suffix, blockLen, outputLen)=>(0, utils_ts_1.createXOFer)((opts = {})=>new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true));\n/** SHAKE128 XOF with 128-bit security. */ exports.shake128 = (()=>genShake(0x1f, 168, 128 / 8))();\n/** SHAKE256 XOF with 256-bit security. */ exports.shake256 = (()=>genShake(0x1f, 136, 256 / 8))(); //# sourceMappingURL=sha3.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9zaGEzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxnQkFBZ0IsR0FBR0EsZ0JBQWdCLEdBQUdBLGtCQUFrQixHQUFHQSxrQkFBa0IsR0FBR0Esa0JBQWtCLEdBQUdBLGtCQUFrQixHQUFHQSxnQkFBZ0IsR0FBR0EsZ0JBQWdCLEdBQUdBLGdCQUFnQixHQUFHQSxnQkFBZ0IsR0FBR0EsY0FBYyxHQUFHLEtBQUs7QUFDNU5BLGVBQWUsR0FBR2E7QUFDbEI7Ozs7Ozs7Ozs7Q0FVQyxHQUNELE1BQU1DLFlBQVlDLG1CQUFPQSxDQUFDLDZEQUFXO0FBQ3JDLGtCQUFrQjtBQUNsQixNQUFNQyxhQUFhRCxtQkFBT0EsQ0FBQywrREFBWTtBQUN2QywwQ0FBMEM7QUFDMUMsOENBQThDO0FBQzlDLDJDQUEyQztBQUMzQyxNQUFNRSxNQUFNQyxPQUFPO0FBQ25CLE1BQU1DLE1BQU1ELE9BQU87QUFDbkIsTUFBTUUsTUFBTUYsT0FBTztBQUNuQixNQUFNRyxNQUFNSCxPQUFPO0FBQ25CLE1BQU1JLFFBQVFKLE9BQU87QUFDckIsTUFBTUssU0FBU0wsT0FBTztBQUN0QixNQUFNTSxVQUFVLEVBQUU7QUFDbEIsTUFBTUMsWUFBWSxFQUFFO0FBQ3BCLE1BQU1DLGFBQWEsRUFBRTtBQUNyQixJQUFLLElBQUlDLFFBQVEsR0FBR0MsSUFBSVQsS0FBS1UsSUFBSSxHQUFHQyxJQUFJLEdBQUdILFFBQVEsSUFBSUEsUUFBUztJQUM1RCxLQUFLO0lBQ0wsQ0FBQ0UsR0FBR0MsRUFBRSxHQUFHO1FBQUNBO1FBQUksS0FBSUQsSUFBSSxJQUFJQyxDQUFBQSxJQUFLO0tBQUU7SUFDakNOLFFBQVFPLElBQUksQ0FBQyxJQUFLLEtBQUlELElBQUlELENBQUFBO0lBQzFCLGFBQWE7SUFDYkosVUFBVU0sSUFBSSxDQUFDLENBQUdKLFFBQVEsS0FBTUEsQ0FBQUEs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QU0sRUFBQztBQUNsRCw4QkFBOEIsR0FDOUIxRyxrQkFBa0IsR0FBRyxDQUFDLElBQU0wRyxJQUFJLE1BQU0sSUFBSSxNQUFNLEVBQUM7QUFDakQsTUFBTUUsV0FBVyxDQUFDNUMsUUFBUUQsVUFBVUUsWUFBYyxDQUFDLEdBQUdqRCxXQUFXNkYsV0FBVyxFQUFFLENBQUNDLE9BQU8sQ0FBQyxDQUFDLEdBQUssSUFBSWxHLE9BQU9tRCxVQUFVQyxRQUFROEMsS0FBS0MsS0FBSyxLQUFLQyxZQUFZL0MsWUFBWTZDLEtBQUtDLEtBQUssRUFBRTtBQUM3Syx3Q0FBd0MsR0FDeEMvRyxnQkFBZ0IsR0FBRyxDQUFDLElBQU00RyxTQUFTLE1BQU0sS0FBSyxNQUFNLEVBQUM7QUFDckQsd0NBQXdDLEdBQ3hDNUcsZ0JBQWdCLEdBQUcsQ0FBQyxJQUFNNEcsU0FBUyxNQUFNLEtBQUssTUFBTSxFQUFDLEtBQ3JELGdDQUFnQyIsInNvdXJjZXMiOlsid2VicGFjazovL2ZhcmNhc3RlcnN0YXRzLy4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvc2hhMy5qcz8wNzk4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zaGFrZTI1NiA9IGV4cG9ydHMuc2hha2UxMjggPSBleHBvcnRzLmtlY2Nha181MTIgPSBleHBvcnRzLmtlY2Nha18zODQgPSBleHBvcnRzLmtlY2Nha18yNTYgPSBleHBvcnRzLmtlY2Nha18yMjQgPSBleHBvcnRzLnNoYTNfNTEyID0gZXhwb3J0cy5zaGEzXzM4NCA9IGV4cG9ydHMuc2hhM18yNTYgPSBleHBvcnRzLnNoYTNfMjI0ID0gZXhwb3J0cy5LZWNjYWsgPSB2b2lkIDA7XG5leHBvcnRzLmtlY2Nha1AgPSBrZWNjYWtQO1xuLyoqXG4gKiBTSEEzIChrZWNjYWspIGhhc2ggZnVuY3Rpb24sIGJhc2VkIG9uIGEgbmV3IFwiU3BvbmdlIGZ1bmN0aW9uXCIgZGVzaWduLlxuICogRGlmZmVyZW50IGZyb20gb2xkZXIgaGFzaGVzLCB0aGUgaW50ZXJuYWwgc3RhdGUgaXMgYmlnZ2VyIHRoYW4gb3V0cHV0IHNpemUuXG4gKlxuICogQ2hlY2sgb3V0IFtGSVBTLTIwMl0oaHR0cHM6Ly9udmxwdWJzLm5pc3QuZ292L25pc3RwdWJzL0ZJUFMvTklTVC5GSVBTLjIwMi5wZGYpLFxuICogW1dlYnNpdGVdKGh0dHBzOi8va2VjY2FrLnRlYW0va2VjY2FrLmh0bWwpLFxuICogW3RoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIFNIQS0zIGFuZCBLZWNjYWtdKGh0dHBzOi8vY3J5cHRvLnN0YWNrZXhjaGFuZ2UuY29tL3F1ZXN0aW9ucy8xNTcyNy93aGF0LWFyZS10aGUta2V5LWRpZmZlcmVuY2VzLWJldHdlZW4tdGhlLWRyYWZ0LXNoYS0zLXN0YW5kYXJkLWFuZC10aGUta2VjY2FrLXN1YikuXG4gKlxuICogQ2hlY2sgb3V0IGBzaGEzLWFkZG9uc2AgbW9kdWxlIGZvciBjU0hBS0UsIGsxMiwgYW5kIG90aGVycy5cbiAqIEBtb2R1bGVcbiAqL1xuY29uc3QgX3U2NF90c18xID0gcmVxdWlyZShcIi4vX3U2NC5qc1wiKTtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgdXRpbHNfdHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzLmpzXCIpO1xuLy8gTm8gX19QVVJFX18gYW5ub3RhdGlvbnMgaW4gc2hhMyBoZWFkZXI6XG4vLyBFVkVSWVRISU5HIGlzIGluIGZhY3QgdXNlZCBvbiBldmVyeSBleHBvcnQuXG4vLyBWYXJpb3VzIHBlciByb3VuZCBjb25zdGFudHMgY2FsY3VsYXRpb25zXG5jb25zdCBfMG4gPSBCaWdJbnQoMCk7XG5jb25zdCBfMW4gPSBCaWdJbnQoMSk7XG5jb25zdCBfMm4gPSBCaWdJbnQoMik7XG5jb25zdCBfN24gPSBCaWdJbnQoNyk7XG5jb25zdCBfMjU2biA9IEJpZ0ludCgyNTYpO1xuY29uc3QgXzB4NzFuID0gQmlnSW50KDB4NzEpO1xuY29uc3QgU0hBM19QSSA9IFtdO1xuY29uc3QgU0hBM19ST1RMID0gW107XG5jb25zdCBfU0hBM19JT1RBID0gW107XG5mb3IgKGxldCByb3VuZCA9IDAsIFIgPSBfMW4sIHggPSAxLCB5ID0gMDsgcm91bmQgPCAyNDsgcm91bmQrKykge1xuICAgIC8vIFBpXG4gICAgW3gsIHldID0gW3ksICgyICogeCArIDMgKiB5KSAlIDVdO1xuICAgIFNIQTNfUEkucHVzaCgyICogKDUgKiB5ICsgeCkpO1xuICAgIC8vIFJvdGF0aW9uYWxcbiAgICBTSEEzX1JPVEwucHVzaCgoKChyb3VuZCArIDEpICogKHJvdW5kICsgMikpIC8gMikgJSA2NCk7XG4gICAgLy8gSW90YVxuICAgIGxldCB0ID0gXzBuO1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgNzsgaisrKSB7XG4gICAgICAgIFIgPSAoKFIgPDwgXzFuKSBeICgoUiA+PiBfN24pICogXzB4NzFuKSkgJSBfMjU2bjtcbiAgICAgICAgaWYgKFIgJiBfMm4pXG4gICAgICAgICAgICB0IF49IF8xbiA8PCAoKF8xbiA8PCAvKiBAX19QVVJFX18gKi8gQmlnSW50KGopKSAtIF8xbik7XG4gICAgfVxuICAgIF9TSEEzX0lPVEEucHVzaCh0KTtcbn1cbmNvbnN0IElPVEFTID0gKDAsIF91NjRfdHNfMS5zcGxpdCkoX1NIQTNfSU9UQSwgdHJ1ZSk7XG5jb25zdCBTSEEzX0lPVEFfSCA9IElPVEFTWzBdO1xuY29uc3QgU0hBM19JT1RBX0wgPSBJT1RBU1sxXTtcbi8vIExlZnQgcm90YXRpb24gKHdpdGhvdXQgMCwgMzIsIDY0KVxuY29uc3Qgcm90bEggPSAoaCwgbCwgcykgPT4gKHMgPiAzMiA/ICgwLCBfdTY0X3RzXzEucm90bEJIKShoLCBsLCBzKSA6ICgwLCBfdTY0X3RzXzEucm90bFNIKShoLCBsLCBzKSk7XG5jb25zdCByb3RsTCA9IChoLCBsLCBzKSA9PiAocyA+IDMyID8gKDAsIF91NjRfdHNfMS5yb3RsQkwpKGgsIGwsIHMpIDogKDAsIF91NjRfdHNfMS5yb3RsU0wpKGgsIGwsIHMpKTtcbi8qKiBga2VjY2FrZjE2MDBgIGludGVybmFsIGZ1bmN0aW9uLCBhZGRpdGlvbmFsbHkgYWxsb3dzIHRvIGFkanVzdCByb3VuZCBjb3VudC4gKi9cbmZ1bmN0aW9uIGtlY2Nha1Aocywgcm91bmRzID0gMjQpIHtcbiAgICBjb25zdCBCID0gbmV3IFVpbnQzMkFycmF5KDUgKiAyKTtcbiAgICAvLyBOT1RFOiBhbGwgaW5kaWNlcyBhcmUgeDIgc2luY2Ugd2Ugc3RvcmUgc3RhdGUgYXMgdTMyIGluc3RlYWQgb2YgdTY0IChiaWdpbnRzIHRvIHNsb3cgaW4ganMpXG4gICAgZm9yIChsZXQgcm91bmQgPSAyNCAtIHJvdW5kczsgcm91bmQgPCAyNDsgcm91bmQrKykge1xuICAgICAgICAvLyBUaGV0YSDOuFxuICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IDEwOyB4KyspXG4gICAgICAgICAgICBCW3hdID0gc1t4XSBeIHNbeCArIDEwXSBeIHNbeCArIDIwXSBeIHNbeCArIDMwXSBeIHNbeCArIDQwXTtcbiAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCAxMDsgeCArPSAyKSB7XG4gICAgICAgICAgICBjb25zdCBpZHgxID0gKHggKyA4KSAlIDEwO1xuICAgICAgICAgICAgY29uc3QgaWR4MCA9ICh4ICsgMikgJSAxMDtcbiAgICAgICAgICAgIGNvbnN0IEIwID0gQltpZHgwXTtcbiAgICAgICAgICAgIGNvbnN0IEIxID0gQltpZHgwICsgMV07XG4gICAgICAgICAgICBjb25zdCBUaCA9IHJvdGxIKEIwLCBCMSwgMSkgXiBCW2lkeDFdO1xuICAgICAgICAgICAgY29uc3QgVGwgPSByb3RsTChCMCwgQjEsIDEpIF4gQltpZHgxICsgMV07XG4gICAgICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IDUwOyB5ICs9IDEwKSB7XG4gICAgICAgICAgICAgICAgc1t4ICsgeV0gXj0gVGg7XG4gICAgICAgICAgICAgICAgc1t4ICsgeSArIDFdIF49IFRsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFJobyAoz4EpIGFuZCBQaSAoz4ApXG4gICAgICAgIGxldCBjdXJIID0gc1syXTtcbiAgICAgICAgbGV0IGN1ckwgPSBzWzNdO1xuICAgICAgICBmb3IgKGxldCB0ID0gMDsgdCA8IDI0OyB0KyspIHtcbiAgICAgICAgICAgIGNvbnN0IHNoaWZ0ID0gU0hBM19ST1RMW3RdO1xuICAgICAgICAgICAgY29uc3QgVGggPSByb3RsSChjdXJILCBjdXJMLCBzaGlmdCk7XG4gICAgICAgICAgICBjb25zdCBUbCA9IHJvdGxMKGN1ckgsIGN1ckwsIHNoaWZ0KTtcbiAgICAgICAgICAgIGNvbnN0IFBJID0gU0hBM19QSVt0XTtcbiAgICAgICAgICAgIGN1ckggPSBzW1BJXTtcbiAgICAgICAgICAgIGN1ckwgPSBzW1BJICsgMV07XG4gICAgICAgICAgICBzW1BJXSA9IFRoO1xuICAgICAgICAgICAgc1tQSSArIDFdID0gVGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hpICjPhylcbiAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCA1MDsgeSArPSAxMCkge1xuICAgICAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCAxMDsgeCsrKVxuICAgICAgICAgICAgICAgIEJbeF0gPSBzW3kgKyB4XTtcbiAgICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgMTA7IHgrKylcbiAgICAgICAgICAgICAgICBzW3kgKyB4XSBePSB+QlsoeCArIDIpICUgMTBdICYgQlsoeCArIDQpICUgMTBdO1xuICAgICAgICB9XG4gICAgICAgIC8vIElvdGEgKM65KVxuICAgICAgICBzWzBdIF49IFNIQTNfSU9UQV9IW3JvdW5kXTtcbiAgICAgICAgc1sxXSBePSBTSEEzX0lPVEFfTFtyb3VuZF07XG4gICAgfVxuICAgICgwLCB1dGlsc190c18xLmNsZWFuKShCKTtcbn1cbi8qKiBLZWNjYWsgc3BvbmdlIGZ1bmN0aW9uLiAqL1xuY2xhc3MgS2VjY2FrIGV4dGVuZHMgdXRpbHNfdHNfMS5IYXNoIHtcbiAgICAvLyBOT1RFOiB3ZSBhY2NlcHQgYXJndW1lbnRzIGluIGJ5dGVzIGluc3RlYWQgb2YgYml0cyBoZXJlLlxuICAgIGNvbnN0cnVjdG9yKGJsb2NrTGVuLCBzdWZmaXgsIG91dHB1dExlbiwgZW5hYmxlWE9GID0gZmFsc2UsIHJvdW5kcyA9IDI0KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgdGhpcy5wb3NPdXQgPSAwO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZW5hYmxlWE9GID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYmxvY2tMZW4gPSBibG9ja0xlbjtcbiAgICAgICAgdGhpcy5zdWZmaXggPSBzdWZmaXg7XG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gb3V0cHV0TGVuO1xuICAgICAgICB0aGlzLmVuYWJsZVhPRiA9IGVuYWJsZVhPRjtcbiAgICAgICAgdGhpcy5yb3VuZHMgPSByb3VuZHM7XG4gICAgICAgIC8vIENhbiBiZSBwYXNzZWQgZnJvbSB1c2VyIGFzIGRrTGVuXG4gICAgICAgICgwLCB1dGlsc190c18xLmFudW1iZXIpKG91dHB1dExlbik7XG4gICAgICAgIC8vIDE2MDAgPSA1eDUgbWF0cml4IG9mIDY0Yml0LiAgMTYwMCBiaXRzID09PSAyMDAgYnl0ZXNcbiAgICAgICAgLy8gMCA8IGJsb2NrTGVuIDwgMjAwXG4gICAgICAgIGlmICghKDAgPCBibG9ja0xlbiAmJiBibG9ja0xlbiA8IDIwMCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ29ubHkga2VjY2FrLWYxNjAwIGZ1bmN0aW9uIGlzIHN1cHBvcnRlZCcpO1xuICAgICAgICB0aGlzLnN0YXRlID0gbmV3IFVpbnQ4QXJyYXkoMjAwKTtcbiAgICAgICAgdGhpcy5zdGF0ZTMyID0gKDAsIHV0aWxzX3RzXzEudTMyKSh0aGlzLnN0YXRlKTtcbiAgICB9XG4gICAgY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jbG9uZUludG8oKTtcbiAgICB9XG4gICAga2VjY2FrKCkge1xuICAgICAgICAoMCwgdXRpbHNfdHNfMS5zd2FwMzJJZkJFKSh0aGlzLnN0YXRlMzIpO1xuICAgICAgICBrZWNjYWtQKHRoaXMuc3RhdGUzMiwgdGhpcy5yb3VuZHMpO1xuICAgICAgICAoMCwgdXRpbHNfdHNfMS5zd2FwMzJJZkJFKSh0aGlzLnN0YXRlMzIpO1xuICAgICAgICB0aGlzLnBvc091dCA9IDA7XG4gICAgICAgIHRoaXMucG9zID0gMDtcbiAgICB9XG4gICAgdXBkYXRlKGRhdGEpIHtcbiAgICAgICAgKDAsIHV0aWxzX3RzXzEuYWV4aXN0cykodGhpcyk7XG4gICAgICAgIGRhdGEgPSAoMCwgdXRpbHNfdHNfMS50b0J5dGVzKShkYXRhKTtcbiAgICAgICAgKDAsIHV0aWxzX3RzXzEuYWJ5dGVzKShkYXRhKTtcbiAgICAgICAgY29uc3QgeyBibG9ja0xlbiwgc3RhdGUgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGxlbiA9IGRhdGEubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBwb3MgPSAwOyBwb3MgPCBsZW47KSB7XG4gICAgICAgICAgICBjb25zdCB0YWtlID0gTWF0aC5taW4oYmxvY2tMZW4gLSB0aGlzLnBvcywgbGVuIC0gcG9zKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGFrZTsgaSsrKVxuICAgICAgICAgICAgICAgIHN0YXRlW3RoaXMucG9zKytdIF49IGRhdGFbcG9zKytdO1xuICAgICAgICAgICAgaWYgKHRoaXMucG9zID09PSBibG9ja0xlbilcbiAgICAgICAgICAgICAgICB0aGlzLmtlY2NhaygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBmaW5pc2goKSB7XG4gICAgICAgIGlmICh0aGlzLmZpbmlzaGVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgeyBzdGF0ZSwgc3VmZml4LCBwb3MsIGJsb2NrTGVuIH0gPSB0aGlzO1xuICAgICAgICAvLyBEbyB0aGUgcGFkZGluZ1xuICAgICAgICBzdGF0ZVtwb3NdIF49IHN1ZmZpeDtcbiAgICAgICAgaWYgKChzdWZmaXggJiAweDgwKSAhPT0gMCAmJiBwb3MgPT09IGJsb2NrTGVuIC0gMSlcbiAgICAgICAgICAgIHRoaXMua2VjY2FrKCk7XG4gICAgICAgIHN0YXRlW2Jsb2NrTGVuIC0gMV0gXj0gMHg4MDtcbiAgICAgICAgdGhpcy5rZWNjYWsoKTtcbiAgICB9XG4gICAgd3JpdGVJbnRvKG91dCkge1xuICAgICAgICAoMCwgdXRpbHNfdHNfMS5hZXhpc3RzKSh0aGlzLCBmYWxzZSk7XG4gICAgICAgICgwLCB1dGlsc190c18xLmFieXRlcykob3V0KTtcbiAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgY29uc3QgYnVmZmVyT3V0ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgY29uc3QgeyBibG9ja0xlbiB9ID0gdGhpcztcbiAgICAgICAgZm9yIChsZXQgcG9zID0gMCwgbGVuID0gb3V0Lmxlbmd0aDsgcG9zIDwgbGVuOykge1xuICAgICAgICAgICAgaWYgKHRoaXMucG9zT3V0ID49IGJsb2NrTGVuKVxuICAgICAgICAgICAgICAgIHRoaXMua2VjY2FrKCk7XG4gICAgICAgICAgICBjb25zdCB0YWtlID0gTWF0aC5taW4oYmxvY2tMZW4gLSB0aGlzLnBvc091dCwgbGVuIC0gcG9zKTtcbiAgICAgICAgICAgIG91dC5zZXQoYnVmZmVyT3V0LnN1YmFycmF5KHRoaXMucG9zT3V0LCB0aGlzLnBvc091dCArIHRha2UpLCBwb3MpO1xuICAgICAgICAgICAgdGhpcy5wb3NPdXQgKz0gdGFrZTtcbiAgICAgICAgICAgIHBvcyArPSB0YWtlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIHhvZkludG8ob3V0KSB7XG4gICAgICAgIC8vIFNoYTMvS2VjY2FrIHVzYWdlIHdpdGggWE9GIGlzIHByb2JhYmx5IG1pc3Rha2UsIG9ubHkgU0hBS0UgaW5zdGFuY2VzIGNhbiBkbyBYT0ZcbiAgICAgICAgaWYgKCF0aGlzLmVuYWJsZVhPRilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignWE9GIGlzIG5vdCBwb3NzaWJsZSBmb3IgdGhpcyBpbnN0YW5jZScpO1xuICAgICAgICByZXR1cm4gdGhpcy53cml0ZUludG8ob3V0KTtcbiAgICB9XG4gICAgeG9mKGJ5dGVzKSB7XG4gICAgICAgICgwLCB1dGlsc190c18xLmFudW1iZXIpKGJ5dGVzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMueG9mSW50byhuZXcgVWludDhBcnJheShieXRlcykpO1xuICAgIH1cbiAgICBkaWdlc3RJbnRvKG91dCkge1xuICAgICAgICAoMCwgdXRpbHNfdHNfMS5hb3V0cHV0KShvdXQsIHRoaXMpO1xuICAgICAgICBpZiAodGhpcy5maW5pc2hlZClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZGlnZXN0KCkgd2FzIGFscmVhZHkgY2FsbGVkJyk7XG4gICAgICAgIHRoaXMud3JpdGVJbnRvKG91dCk7XG4gICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICBkaWdlc3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRpZ2VzdEludG8obmV3IFVpbnQ4QXJyYXkodGhpcy5vdXRwdXRMZW4pKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xuICAgICAgICAoMCwgdXRpbHNfdHNfMS5jbGVhbikodGhpcy5zdGF0ZSk7XG4gICAgfVxuICAgIF9jbG9uZUludG8odG8pIHtcbiAgICAgICAgY29uc3QgeyBibG9ja0xlbiwgc3VmZml4LCBvdXRwdXRMZW4sIHJvdW5kcywgZW5hYmxlWE9GIH0gPSB0aGlzO1xuICAgICAgICB0byB8fCAodG8gPSBuZXcgS2VjY2FrKGJsb2NrTGVuLCBzdWZmaXgsIG91dHB1dExlbiwgZW5hYmxlWE9GLCByb3VuZHMpKTtcbiAgICAgICAgdG8uc3RhdGUzMi5zZXQodGhpcy5zdGF0ZTMyKTtcbiAgICAgICAgdG8ucG9zID0gdGhpcy5wb3M7XG4gICAgICAgIHRvLnBvc091dCA9IHRoaXMucG9zT3V0O1xuICAgICAgICB0by5maW5pc2hlZCA9IHRoaXMuZmluaXNoZWQ7XG4gICAgICAgIHRvLnJvdW5kcyA9IHJvdW5kcztcbiAgICAgICAgLy8gU3VmZml4IGNhbiBjaGFuZ2UgaW4gY1NIQUtFXG4gICAgICAgIHRvLnN1ZmZpeCA9IHN1ZmZpeDtcbiAgICAgICAgdG8ub3V0cHV0TGVuID0gb3V0cHV0TGVuO1xuICAgICAgICB0by5lbmFibGVYT0YgPSBlbmFibGVYT0Y7XG4gICAgICAgIHRvLmRlc3Ryb3llZCA9IHRoaXMuZGVzdHJveWVkO1xuICAgICAgICByZXR1cm4gdG87XG4gICAgfVxufVxuZXhwb3J0cy5LZWNjYWsgPSBLZWNjYWs7XG5jb25zdCBnZW4gPSAoc3VmZml4LCBibG9ja0xlbiwgb3V0cHV0TGVuKSA9PiAoMCwgdXRpbHNfdHNfMS5jcmVhdGVIYXNoZXIpKCgpID0+IG5ldyBLZWNjYWsoYmxvY2tMZW4sIHN1ZmZpeCwgb3V0cHV0TGVuKSk7XG4vKiogU0hBMy0yMjQgaGFzaCBmdW5jdGlvbi4gKi9cbmV4cG9ydHMuc2hhM18yMjQgPSAoKCkgPT4gZ2VuKDB4MDYsIDE0NCwgMjI0IC8gOCkpKCk7XG4vKiogU0hBMy0yNTYgaGFzaCBmdW5jdGlvbi4gRGlmZmVyZW50IGZyb20ga2VjY2FrLTI1Ni4gKi9cbmV4cG9ydHMuc2hhM18yNTYgPSAoKCkgPT4gZ2VuKDB4MDYsIDEzNiwgMjU2IC8gOCkpKCk7XG4vKiogU0hBMy0zODQgaGFzaCBmdW5jdGlvbi4gKi9cbmV4cG9ydHMuc2hhM18zODQgPSAoKCkgPT4gZ2VuKDB4MDYsIDEwNCwgMzg0IC8gOCkpKCk7XG4vKiogU0hBMy01MTIgaGFzaCBmdW5jdGlvbi4gKi9cbmV4cG9ydHMuc2hhM181MTIgPSAoKCkgPT4gZ2VuKDB4MDYsIDcyLCA1MTIgLyA4KSkoKTtcbi8qKiBrZWNjYWstMjI0IGhhc2ggZnVuY3Rpb24uICovXG5leHBvcnRzLmtlY2Nha18yMjQgPSAoKCkgPT4gZ2VuKDB4MDEsIDE0NCwgMjI0IC8gOCkpKCk7XG4vKioga2VjY2FrLTI1NiBoYXNoIGZ1bmN0aW9uLiBEaWZmZXJlbnQgZnJvbSBTSEEzLTI1Ni4gKi9cbmV4cG9ydHMua2VjY2FrXzI1NiA9ICgoKSA9PiBnZW4oMHgwMSwgMTM2LCAyNTYgLyA4KSkoKTtcbi8qKiBrZWNjYWstMzg0IGhhc2ggZnVuY3Rpb24uICovXG5leHBvcnRzLmtlY2Nha18zODQgPSAoKCkgPT4gZ2VuKDB4MDEsIDEwNCwgMzg0IC8gOCkpKCk7XG4vKioga2VjY2FrLTUxMiBoYXNoIGZ1bmN0aW9uLiAqL1xuZXhwb3J0cy5rZWNjYWtfNTEyID0gKCgpID0+IGdlbigweDAxLCA3MiwgNTEyIC8gOCkpKCk7XG5jb25zdCBnZW5TaGFrZSA9IChzdWZmaXgsIGJsb2NrTGVuLCBvdXRwdXRMZW4pID0+ICgwLCB1dGlsc190c18xLmNyZWF0ZVhPRmVyKSgob3B0cyA9IHt9KSA9PiBuZXcgS2VjY2FrKGJsb2NrTGVuLCBzdWZmaXgsIG9wdHMuZGtMZW4gPT09IHVuZGVmaW5lZCA/IG91dHB1dExlbiA6IG9wdHMuZGtMZW4sIHRydWUpKTtcbi8qKiBTSEFLRTEyOCBYT0Ygd2l0aCAxMjgtYml0IHNlY3VyaXR5LiAqL1xuZXhwb3J0cy5zaGFrZTEyOCA9ICgoKSA9PiBnZW5TaGFrZSgweDFmLCAxNjgsIDEyOCAvIDgpKSgpO1xuLyoqIFNIQUtFMjU2IFhPRiB3aXRoIDI1Ni1iaXQgc2VjdXJpdHkuICovXG5leHBvcnRzLnNoYWtlMjU2ID0gKCgpID0+IGdlblNoYWtlKDB4MWYsIDEzNiwgMjU2IC8gOCkpKCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaGEzLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInNoYWtlMjU2Iiwic2hha2UxMjgiLCJrZWNjYWtfNTEyIiwia2VjY2FrXzM4NCIsImtlY2Nha18yNTYiLCJrZWNjYWtfMjI0Iiwic2hhM181MTIiLCJzaGEzXzM4NCIsInNoYTNfMjU2Iiwic2hhM18yMjQiLCJLZWNjYWsiLCJrZWNjYWtQIiwiX3U2NF90c18xIiwicmVxdWlyZSIsInV0aWxzX3RzXzEiLCJfMG4iLCJCaWdJbnQiLCJfMW4iLCJfMm4iLCJfN24iLCJfMjU2biIsIl8weDcxbiIsIlNIQTNfUEkiLCJTSEEzX1JPVEwiLCJfU0hBM19JT1RBIiwicm91bmQiLCJSIiwieCIsInkiLCJwdXNoIiwidCIsImoiLCJJT1RBUyIsInNwbGl0IiwiU0hBM19JT1RBX0giLCJTSEEzX0lPVEFfTCIsInJvdGxIIiwiaCIsImwiLCJzIiwicm90bEJIIiwicm90bFNIIiwicm90bEwiLCJyb3RsQkwiLCJyb3RsU0wiLCJyb3VuZHMiLCJCIiwiVWludDMyQXJyYXkiLCJpZHgxIiwiaWR4MCIsIkIwIiwiQjEiLCJUaCIsIlRsIiwiY3VySCIsImN1ckwiLCJzaGlmdCIsIlBJIiwiY2xlYW4iLCJIYXNoIiwiY29uc3RydWN0b3IiLCJibG9ja0xlbiIsInN1ZmZpeCIsIm91dHB1dExlbiIsImVuYWJsZVhPRiIsInBvcyIsInBvc091dCIsImZpbmlzaGVkIiwiZGVzdHJveWVkIiwiYW51bWJlciIsIkVycm9yIiwic3RhdGUiLCJVaW50OEFycmF5Iiwic3RhdGUzMiIsInUzMiIsImNsb25lIiwiX2Nsb25lSW50byIsImtlY2NhayIsInN3YXAzMklmQkUiLCJ1cGRhdGUiLCJkYXRhIiwiYWV4aXN0cyIsInRvQnl0ZXMiLCJhYnl0ZXMiLCJsZW4iLCJsZW5ndGgiLCJ0YWtlIiwiTWF0aCIsIm1pbiIsImkiLCJmaW5pc2giLCJ3cml0ZUludG8iLCJvdXQiLCJidWZmZXJPdXQiLCJzZXQiLCJzdWJhcnJheSIsInhvZkludG8iLCJ4b2YiLCJieXRlcyIsImRpZ2VzdEludG8iLCJhb3V0cHV0IiwiZGVzdHJveSIsImRpZ2VzdCIsInRvIiwiZ2VuIiwiY3JlYXRlSGFzaGVyIiwiZ2VuU2hha2UiLCJjcmVhdGVYT0ZlciIsIm9wdHMiLCJka0xlbiIsInVuZGVmaW5lZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@noble/hashes/sha3.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@noble/hashes/utils.js":
/*!*********************************************!*\
  !*** ./node_modules/@noble/hashes/utils.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * Utilities for hex, bytes, CSPRNG.\n * @module\n */ /*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.wrapXOFConstructorWithOpts = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.Hash = exports.nextTick = exports.swap32IfBE = exports.byteSwapIfBE = exports.swap8IfBE = exports.isLE = void 0;\nexports.isBytes = isBytes;\nexports.anumber = anumber;\nexports.abytes = abytes;\nexports.ahash = ahash;\nexports.aexists = aexists;\nexports.aoutput = aoutput;\nexports.u8 = u8;\nexports.u32 = u32;\nexports.clean = clean;\nexports.createView = createView;\nexports.rotr = rotr;\nexports.rotl = rotl;\nexports.byteSwap = byteSwap;\nexports.byteSwap32 = byteSwap32;\nexports.bytesToHex = bytesToHex;\nexports.hexToBytes = hexToBytes;\nexports.asyncLoop = asyncLoop;\nexports.utf8ToBytes = utf8ToBytes;\nexports.bytesToUtf8 = bytesToUtf8;\nexports.toBytes = toBytes;\nexports.kdfInputToBytes = kdfInputToBytes;\nexports.concatBytes = concatBytes;\nexports.checkOpts = checkOpts;\nexports.createHasher = createHasher;\nexports.createOptHasher = createOptHasher;\nexports.createXOFer = createXOFer;\nexports.randomBytes = randomBytes;\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\nconst crypto_1 = __webpack_require__(/*! @noble/hashes/crypto */ \"(rsc)/./node_modules/@noble/hashes/cryptoNode.js\");\n/** Checks if something is Uint8Array. Be careful: nodejs Buffer will return true. */ function isBytes(a) {\n    return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === \"Uint8Array\";\n}\n/** Asserts something is positive integer. */ function anumber(n) {\n    if (!Number.isSafeInteger(n) || n < 0) throw new Error(\"positive integer expected, got \" + n);\n}\n/** Asserts something is Uint8Array. */ function abytes(b, ...lengths) {\n    if (!isBytes(b)) throw new Error(\"Uint8Array expected\");\n    if (lengths.length > 0 && !lengths.includes(b.length)) throw new Error(\"Uint8Array expected of length \" + lengths + \", got length=\" + b.length);\n}\n/** Asserts something is hash */ function ahash(h) {\n    if (typeof h !== \"function\" || typeof h.create !== \"function\") throw new Error(\"Hash should be wrapped by utils.createHasher\");\n    anumber(h.outputLen);\n    anumber(h.blockLen);\n}\n/** Asserts a hash instance has not been destroyed / finished */ function aexists(instance, checkFinished = true) {\n    if (instance.destroyed) throw new Error(\"Hash instance has been destroyed\");\n    if (checkFinished && instance.finished) throw new Error(\"Hash#digest() has already been called\");\n}\n/** Asserts output is properly-sized byte array */ function aoutput(out, instance) {\n    abytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error(\"digestInto() expects output buffer of length at least \" + min);\n    }\n}\n/** Cast u8 / u16 / u32 to u8. */ function u8(arr) {\n    return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n/** Cast u8 / u16 / u32 to u32. */ function u32(arr) {\n    return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n}\n/** Zeroize a byte array. Warning: JS provides no guarantees. */ function clean(...arrays) {\n    for(let i = 0; i < arrays.length; i++){\n        arrays[i].fill(0);\n    }\n}\n/** Create DataView of an array for easy byte-level manipulation. */ function createView(arr) {\n    return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n/** The rotate right (circular right shift) operation for uint32 */ function rotr(word, shift) {\n    return word << 32 - shift | word >>> shift;\n}\n/** The rotate left (circular left shift) operation for uint32 */ function rotl(word, shift) {\n    return word << shift | word >>> 32 - shift >>> 0;\n}\n/** Is current platform little-endian? Most are. Big-Endian platform: IBM */ exports.isLE = (()=>new Uint8Array(new Uint32Array([\n        0x11223344\n    ]).buffer)[0] === 0x44)();\n/** The byte swap operation for uint32 */ function byteSwap(word) {\n    return word << 24 & 0xff000000 | word << 8 & 0xff0000 | word >>> 8 & 0xff00 | word >>> 24 & 0xff;\n}\n/** Conditionally byte swap if on a big-endian platform */ exports.swap8IfBE = exports.isLE ? (n)=>n : (n)=>byteSwap(n);\n/** @deprecated */ exports.byteSwapIfBE = exports.swap8IfBE;\n/** In place byte swap for Uint32Array */ function byteSwap32(arr) {\n    for(let i = 0; i < arr.length; i++){\n        arr[i] = byteSwap(arr[i]);\n    }\n    return arr;\n}\nexports.swap32IfBE = exports.isLE ? (u)=>u : byteSwap32;\n// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex\nconst hasHexBuiltin = /* @__PURE__ */ (()=>// @ts-ignore\n    typeof Uint8Array.from([]).toHex === \"function\" && typeof Uint8Array.fromHex === \"function\")();\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({\n    length: 256\n}, (_, i)=>i.toString(16).padStart(2, \"0\"));\n/**\n * Convert byte array to hex string. Uses built-in function, when available.\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */ function bytesToHex(bytes) {\n    abytes(bytes);\n    // @ts-ignore\n    if (hasHexBuiltin) return bytes.toHex();\n    // pre-caching improves the speed 6x\n    let hex = \"\";\n    for(let i = 0; i < bytes.length; i++){\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = {\n    _0: 48,\n    _9: 57,\n    A: 65,\n    F: 70,\n    a: 97,\n    f: 102\n};\nfunction asciiToBase16(ch) {\n    if (ch >= asciis._0 && ch <= asciis._9) return ch - asciis._0; // '2' => 50-48\n    if (ch >= asciis.A && ch <= asciis.F) return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n    if (ch >= asciis.a && ch <= asciis.f) return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n    return;\n}\n/**\n * Convert hex string to byte array. Uses built-in function, when available.\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */ function hexToBytes(hex) {\n    if (typeof hex !== \"string\") throw new Error(\"hex string expected, got \" + typeof hex);\n    // @ts-ignore\n    if (hasHexBuiltin) return Uint8Array.fromHex(hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2) throw new Error(\"hex string expected, got unpadded hex of length \" + hl);\n    const array = new Uint8Array(al);\n    for(let ai = 0, hi = 0; ai < al; ai++, hi += 2){\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n    }\n    return array;\n}\n/**\n * There is no setImmediate in browser and setTimeout is slow.\n * Call of async fn will return Promise, which will be fullfiled only on\n * next scheduler queue processing step and this is exactly what we need.\n */ const nextTick = async ()=>{};\nexports.nextTick = nextTick;\n/** Returns control to thread each 'tick' ms to avoid blocking. */ async function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for(let i = 0; i < iters; i++){\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick) continue;\n        await (0, exports.nextTick)();\n        ts += diff;\n    }\n}\n/**\n * Converts string to bytes using UTF8 encoding.\n * @example utf8ToBytes('abc') // Uint8Array.from([97, 98, 99])\n */ function utf8ToBytes(str) {\n    if (typeof str !== \"string\") throw new Error(\"string expected\");\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * Converts bytes to string using UTF8 encoding.\n * @example bytesToUtf8(Uint8Array.from([97, 98, 99])) // 'abc'\n */ function bytesToUtf8(bytes) {\n    return new TextDecoder().decode(bytes);\n}\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */ function toBytes(data) {\n    if (typeof data === \"string\") data = utf8ToBytes(data);\n    abytes(data);\n    return data;\n}\n/**\n * Helper for KDFs: consumes uint8array or string.\n * When string is passed, does utf8 decoding, using TextDecoder.\n */ function kdfInputToBytes(data) {\n    if (typeof data === \"string\") data = utf8ToBytes(data);\n    abytes(data);\n    return data;\n}\n/** Copies several Uint8Arrays into one. */ function concatBytes(...arrays) {\n    let sum = 0;\n    for(let i = 0; i < arrays.length; i++){\n        const a = arrays[i];\n        abytes(a);\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for(let i = 0, pad = 0; i < arrays.length; i++){\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\nfunction checkOpts(defaults, opts) {\n    if (opts !== undefined && ({}).toString.call(opts) !== \"[object Object]\") throw new Error(\"options should be object or undefined\");\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\n/** For runtime check if class implements interface */ class Hash {\n}\nexports.Hash = Hash;\n/** Wraps hash function, creating an interface on top of it */ function createHasher(hashCons) {\n    const hashC = (msg)=>hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = ()=>hashCons();\n    return hashC;\n}\nfunction createOptHasher(hashCons) {\n    const hashC = (msg, opts)=>hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts)=>hashCons(opts);\n    return hashC;\n}\nfunction createXOFer(hashCons) {\n    const hashC = (msg, opts)=>hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts)=>hashCons(opts);\n    return hashC;\n}\nexports.wrapConstructor = createHasher;\nexports.wrapConstructorWithOpts = createOptHasher;\nexports.wrapXOFConstructorWithOpts = createXOFer;\n/** Cryptographically secure PRNG. Uses internal OS-level `crypto.getRandomValues`. */ function randomBytes(bytesLength = 32) {\n    if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === \"function\") {\n        return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));\n    }\n    // Legacy Node.js compatibility\n    if (crypto_1.crypto && typeof crypto_1.crypto.randomBytes === \"function\") {\n        return Uint8Array.from(crypto_1.crypto.randomBytes(bytesLength));\n    }\n    throw new Error(\"crypto.getRandomValues must be defined\");\n} //# sourceMappingURL=utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy91dGlscy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiOzs7Q0FHQyxHQUNELG9FQUFvRSxHQUNwRUEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGtDQUFrQyxHQUFHQSwrQkFBK0IsR0FBR0EsdUJBQXVCLEdBQUdBLFlBQVksR0FBR0EsZ0JBQWdCLEdBQUdBLGtCQUFrQixHQUFHQSxvQkFBb0IsR0FBR0EsaUJBQWlCLEdBQUdBLFlBQVksR0FBRyxLQUFLO0FBQ3ZOQSxlQUFlLEdBQUdXO0FBQ2xCWCxlQUFlLEdBQUdZO0FBQ2xCWixjQUFjLEdBQUdhO0FBQ2pCYixhQUFhLEdBQUdjO0FBQ2hCZCxlQUFlLEdBQUdlO0FBQ2xCZixlQUFlLEdBQUdnQjtBQUNsQmhCLFVBQVUsR0FBR2lCO0FBQ2JqQixXQUFXLEdBQUdrQjtBQUNkbEIsYUFBYSxHQUFHbUI7QUFDaEJuQixrQkFBa0IsR0FBR29CO0FBQ3JCcEIsWUFBWSxHQUFHcUI7QUFDZnJCLFlBQVksR0FBR3NCO0FBQ2Z0QixnQkFBZ0IsR0FBR3VCO0FBQ25CdkIsa0JBQWtCLEdBQUd3QjtBQUNyQnhCLGtCQUFrQixHQUFHeUI7QUFDckJ6QixrQkFBa0IsR0FBRzBCO0FBQ3JCMUIsaUJBQWlCLEdBQUcyQjtBQUNwQjNCLG1CQUFtQixHQUFHNEI7QUFDdEI1QixtQkFBbUIsR0FBRzZCO0FBQ3RCN0IsZUFBZSxHQUFHOEI7QUFDbEI5Qix1QkFBdUIsR0FBRytCO0FBQzFCL0IsbUJBQW1CLEdBQUdnQztBQUN0QmhDLGlCQUFpQixHQUFHaUM7QUFDcEJqQyxvQkFBb0IsR0FBR2tDO0FBQ3ZCbEMsdUJBQXVCLEdBQUdtQztBQUMxQm5DLG1CQUFtQixHQUFHb0M7QUFDdEJwQyxtQkFBbUIsR0FBR3FDO0FBQ3RCLG9GQUFvRjtBQUNwRixzRUFBc0U7QUFDdEUsa0VBQWtFO0FBQ2xFLDhEQUE4RDtBQUM5RCwrREFBK0Q7QUFDL0QsMkVB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LE1BQU0sQ0FBQ0MsZUFBZSxDQUFDLElBQUloRyxXQUFXOEY7SUFDMUQ7SUFDQSwrQkFBK0I7SUFDL0IsSUFBSWpHLFNBQVNrRyxNQUFNLElBQUksT0FBT2xHLFNBQVNrRyxNQUFNLENBQUNuRyxXQUFXLEtBQUssWUFBWTtRQUN0RSxPQUFPSSxXQUFXc0MsSUFBSSxDQUFDekMsU0FBU2tHLE1BQU0sQ0FBQ25HLFdBQVcsQ0FBQ2tHO0lBQ3ZEO0lBQ0EsTUFBTSxJQUFJdEYsTUFBTTtBQUNwQixFQUNBLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL2ZhcmNhc3RlcnN0YXRzLy4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvdXRpbHMuanM/NTUxMCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogVXRpbGl0aWVzIGZvciBoZXgsIGJ5dGVzLCBDU1BSTkcuXG4gKiBAbW9kdWxlXG4gKi9cbi8qISBub2JsZS1oYXNoZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMud3JhcFhPRkNvbnN0cnVjdG9yV2l0aE9wdHMgPSBleHBvcnRzLndyYXBDb25zdHJ1Y3RvcldpdGhPcHRzID0gZXhwb3J0cy53cmFwQ29uc3RydWN0b3IgPSBleHBvcnRzLkhhc2ggPSBleHBvcnRzLm5leHRUaWNrID0gZXhwb3J0cy5zd2FwMzJJZkJFID0gZXhwb3J0cy5ieXRlU3dhcElmQkUgPSBleHBvcnRzLnN3YXA4SWZCRSA9IGV4cG9ydHMuaXNMRSA9IHZvaWQgMDtcbmV4cG9ydHMuaXNCeXRlcyA9IGlzQnl0ZXM7XG5leHBvcnRzLmFudW1iZXIgPSBhbnVtYmVyO1xuZXhwb3J0cy5hYnl0ZXMgPSBhYnl0ZXM7XG5leHBvcnRzLmFoYXNoID0gYWhhc2g7XG5leHBvcnRzLmFleGlzdHMgPSBhZXhpc3RzO1xuZXhwb3J0cy5hb3V0cHV0ID0gYW91dHB1dDtcbmV4cG9ydHMudTggPSB1ODtcbmV4cG9ydHMudTMyID0gdTMyO1xuZXhwb3J0cy5jbGVhbiA9IGNsZWFuO1xuZXhwb3J0cy5jcmVhdGVWaWV3ID0gY3JlYXRlVmlldztcbmV4cG9ydHMucm90ciA9IHJvdHI7XG5leHBvcnRzLnJvdGwgPSByb3RsO1xuZXhwb3J0cy5ieXRlU3dhcCA9IGJ5dGVTd2FwO1xuZXhwb3J0cy5ieXRlU3dhcDMyID0gYnl0ZVN3YXAzMjtcbmV4cG9ydHMuYnl0ZXNUb0hleCA9IGJ5dGVzVG9IZXg7XG5leHBvcnRzLmhleFRvQnl0ZXMgPSBoZXhUb0J5dGVzO1xuZXhwb3J0cy5hc3luY0xvb3AgPSBhc3luY0xvb3A7XG5leHBvcnRzLnV0ZjhUb0J5dGVzID0gdXRmOFRvQnl0ZXM7XG5leHBvcnRzLmJ5dGVzVG9VdGY4ID0gYnl0ZXNUb1V0Zjg7XG5leHBvcnRzLnRvQnl0ZXMgPSB0b0J5dGVzO1xuZXhwb3J0cy5rZGZJbnB1dFRvQnl0ZXMgPSBrZGZJbnB1dFRvQnl0ZXM7XG5leHBvcnRzLmNvbmNhdEJ5dGVzID0gY29uY2F0Qnl0ZXM7XG5leHBvcnRzLmNoZWNrT3B0cyA9IGNoZWNrT3B0cztcbmV4cG9ydHMuY3JlYXRlSGFzaGVyID0gY3JlYXRlSGFzaGVyO1xuZXhwb3J0cy5jcmVhdGVPcHRIYXNoZXIgPSBjcmVhdGVPcHRIYXNoZXI7XG5leHBvcnRzLmNyZWF0ZVhPRmVyID0gY3JlYXRlWE9GZXI7XG5leHBvcnRzLnJhbmRvbUJ5dGVzID0gcmFuZG9tQnl0ZXM7XG4vLyBXZSB1c2UgV2ViQ3J5cHRvIGFrYSBnbG9iYWxUaGlzLmNyeXB0bywgd2hpY2ggZXhpc3RzIGluIGJyb3dzZXJzIGFuZCBub2RlLmpzIDE2Ky5cbi8vIG5vZGUuanMgdmVyc2lvbnMgZWFybGllciB0aGFuIHYxOSBkb24ndCBkZWNsYXJlIGl0IGluIGdsb2JhbCBzY29wZS5cbi8vIEZvciBub2RlLmpzLCBwYWNrYWdlLmpzb24jZXhwb3J0cyBmaWVsZCBtYXBwaW5nIHJld3JpdGVzIGltcG9ydFxuLy8gZnJvbSBgY3J5cHRvYCB0byBgY3J5cHRvTm9kZWAsIHdoaWNoIGltcG9ydHMgbmF0aXZlIG1vZHVsZS5cbi8vIE1ha2VzIHRoZSB1dGlscyB1bi1pbXBvcnRhYmxlIGluIGJyb3dzZXJzIHdpdGhvdXQgYSBidW5kbGVyLlxuLy8gT25jZSBub2RlLmpzIDE4IGlzIGRlcHJlY2F0ZWQgKDIwMjUtMDQtMzApLCB3ZSBjYW4ganVzdCBkcm9wIHRoZSBpbXBvcnQuXG5jb25zdCBjcnlwdG9fMSA9IHJlcXVpcmUoXCJAbm9ibGUvaGFzaGVzL2NyeXB0b1wiKTtcbi8qKiBDaGVja3MgaWYgc29tZXRoaW5nIGlzIFVpbnQ4QXJyYXkuIEJlIGNhcmVmdWw6IG5vZGVqcyBCdWZmZXIgd2lsbCByZXR1cm4gdHJ1ZS4gKi9cbmZ1bmN0aW9uIGlzQnl0ZXMoYSkge1xuICAgIHJldHVybiBhIGluc3RhbmNlb2YgVWludDhBcnJheSB8fCAoQXJyYXlCdWZmZXIuaXNWaWV3KGEpICYmIGEuY29uc3RydWN0b3IubmFtZSA9PT0gJ1VpbnQ4QXJyYXknKTtcbn1cbi8qKiBBc3NlcnRzIHNvbWV0aGluZyBpcyBwb3NpdGl2ZSBpbnRlZ2VyLiAqL1xuZnVuY3Rpb24gYW51bWJlcihuKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihuKSB8fCBuIDwgMClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwb3NpdGl2ZSBpbnRlZ2VyIGV4cGVjdGVkLCBnb3QgJyArIG4pO1xufVxuLyoqIEFzc2VydHMgc29tZXRoaW5nIGlzIFVpbnQ4QXJyYXkuICovXG5mdW5jdGlvbiBhYnl0ZXMoYiwgLi4ubGVuZ3Rocykge1xuICAgIGlmICghaXNCeXRlcyhiKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGV4cGVjdGVkJyk7XG4gICAgaWYgKGxlbmd0aHMubGVuZ3RoID4gMCAmJiAhbGVuZ3Rocy5pbmNsdWRlcyhiLmxlbmd0aCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVWludDhBcnJheSBleHBlY3RlZCBvZiBsZW5ndGggJyArIGxlbmd0aHMgKyAnLCBnb3QgbGVuZ3RoPScgKyBiLmxlbmd0aCk7XG59XG4vKiogQXNzZXJ0cyBzb21ldGhpbmcgaXMgaGFzaCAqL1xuZnVuY3Rpb24gYWhhc2goaCkge1xuICAgIGlmICh0eXBlb2YgaCAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaC5jcmVhdGUgIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSGFzaCBzaG91bGQgYmUgd3JhcHBlZCBieSB1dGlscy5jcmVhdGVIYXNoZXInKTtcbiAgICBhbnVtYmVyKGgub3V0cHV0TGVuKTtcbiAgICBhbnVtYmVyKGguYmxvY2tMZW4pO1xufVxuLyoqIEFzc2VydHMgYSBoYXNoIGluc3RhbmNlIGhhcyBub3QgYmVlbiBkZXN0cm95ZWQgLyBmaW5pc2hlZCAqL1xuZnVuY3Rpb24gYWV4aXN0cyhpbnN0YW5jZSwgY2hlY2tGaW5pc2hlZCA9IHRydWUpIHtcbiAgICBpZiAoaW5zdGFuY2UuZGVzdHJveWVkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hhc2ggaW5zdGFuY2UgaGFzIGJlZW4gZGVzdHJveWVkJyk7XG4gICAgaWYgKGNoZWNrRmluaXNoZWQgJiYgaW5zdGFuY2UuZmluaXNoZWQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSGFzaCNkaWdlc3QoKSBoYXMgYWxyZWFkeSBiZWVuIGNhbGxlZCcpO1xufVxuLyoqIEFzc2VydHMgb3V0cHV0IGlzIHByb3Blcmx5LXNpemVkIGJ5dGUgYXJyYXkgKi9cbmZ1bmN0aW9uIGFvdXRwdXQob3V0LCBpbnN0YW5jZSkge1xuICAgIGFieXRlcyhvdXQpO1xuICAgIGNvbnN0IG1pbiA9IGluc3RhbmNlLm91dHB1dExlbjtcbiAgICBpZiAob3V0Lmxlbmd0aCA8IG1pbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RpZ2VzdEludG8oKSBleHBlY3RzIG91dHB1dCBidWZmZXIgb2YgbGVuZ3RoIGF0IGxlYXN0ICcgKyBtaW4pO1xuICAgIH1cbn1cbi8qKiBDYXN0IHU4IC8gdTE2IC8gdTMyIHRvIHU4LiAqL1xuZnVuY3Rpb24gdTgoYXJyKSB7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGFyci5idWZmZXIsIGFyci5ieXRlT2Zmc2V0LCBhcnIuYnl0ZUxlbmd0aCk7XG59XG4vKiogQ2FzdCB1OCAvIHUxNiAvIHUzMiB0byB1MzIuICovXG5mdW5jdGlvbiB1MzIoYXJyKSB7XG4gICAgcmV0dXJuIG5ldyBVaW50MzJBcnJheShhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgTWF0aC5mbG9vcihhcnIuYnl0ZUxlbmd0aCAvIDQpKTtcbn1cbi8qKiBaZXJvaXplIGEgYnl0ZSBhcnJheS4gV2FybmluZzogSlMgcHJvdmlkZXMgbm8gZ3VhcmFudGVlcy4gKi9cbmZ1bmN0aW9uIGNsZWFuKC4uLmFycmF5cykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFycmF5c1tpXS5maWxsKDApO1xuICAgIH1cbn1cbi8qKiBDcmVhdGUgRGF0YVZpZXcgb2YgYW4gYXJyYXkgZm9yIGVhc3kgYnl0ZS1sZXZlbCBtYW5pcHVsYXRpb24uICovXG5mdW5jdGlvbiBjcmVhdGVWaWV3KGFycikge1xuICAgIHJldHVybiBuZXcgRGF0YVZpZXcoYXJyLmJ1ZmZlciwgYXJyLmJ5dGVPZmZzZXQsIGFyci5ieXRlTGVuZ3RoKTtcbn1cbi8qKiBUaGUgcm90YXRlIHJpZ2h0IChjaXJjdWxhciByaWdodCBzaGlmdCkgb3BlcmF0aW9uIGZvciB1aW50MzIgKi9cbmZ1bmN0aW9uIHJvdHIod29yZCwgc2hpZnQpIHtcbiAgICByZXR1cm4gKHdvcmQgPDwgKDMyIC0gc2hpZnQpKSB8ICh3b3JkID4+PiBzaGlmdCk7XG59XG4vKiogVGhlIHJvdGF0ZSBsZWZ0IChjaXJjdWxhciBsZWZ0IHNoaWZ0KSBvcGVyYXRpb24gZm9yIHVpbnQzMiAqL1xuZnVuY3Rpb24gcm90bCh3b3JkLCBzaGlmdCkge1xuICAgIHJldHVybiAod29yZCA8PCBzaGlmdCkgfCAoKHdvcmQgPj4+ICgzMiAtIHNoaWZ0KSkgPj4+IDApO1xufVxuLyoqIElzIGN1cnJlbnQgcGxhdGZvcm0gbGl0dGxlLWVuZGlhbj8gTW9zdCBhcmUuIEJpZy1FbmRpYW4gcGxhdGZvcm06IElCTSAqL1xuZXhwb3J0cy5pc0xFID0gKCgpID0+IG5ldyBVaW50OEFycmF5KG5ldyBVaW50MzJBcnJheShbMHgxMTIyMzM0NF0pLmJ1ZmZlcilbMF0gPT09IDB4NDQpKCk7XG4vKiogVGhlIGJ5dGUgc3dhcCBvcGVyYXRpb24gZm9yIHVpbnQzMiAqL1xuZnVuY3Rpb24gYnl0ZVN3YXAod29yZCkge1xuICAgIHJldHVybiAoKCh3b3JkIDw8IDI0KSAmIDB4ZmYwMDAwMDApIHxcbiAgICAgICAgKCh3b3JkIDw8IDgpICYgMHhmZjAwMDApIHxcbiAgICAgICAgKCh3b3JkID4+PiA4KSAmIDB4ZmYwMCkgfFxuICAgICAgICAoKHdvcmQgPj4+IDI0KSAmIDB4ZmYpKTtcbn1cbi8qKiBDb25kaXRpb25hbGx5IGJ5dGUgc3dhcCBpZiBvbiBhIGJpZy1lbmRpYW4gcGxhdGZvcm0gKi9cbmV4cG9ydHMuc3dhcDhJZkJFID0gZXhwb3J0cy5pc0xFXG4gICAgPyAobikgPT4gblxuICAgIDogKG4pID0+IGJ5dGVTd2FwKG4pO1xuLyoqIEBkZXByZWNhdGVkICovXG5leHBvcnRzLmJ5dGVTd2FwSWZCRSA9IGV4cG9ydHMuc3dhcDhJZkJFO1xuLyoqIEluIHBsYWNlIGJ5dGUgc3dhcCBmb3IgVWludDMyQXJyYXkgKi9cbmZ1bmN0aW9uIGJ5dGVTd2FwMzIoYXJyKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYXJyW2ldID0gYnl0ZVN3YXAoYXJyW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIGFycjtcbn1cbmV4cG9ydHMuc3dhcDMySWZCRSA9IGV4cG9ydHMuaXNMRVxuICAgID8gKHUpID0+IHVcbiAgICA6IGJ5dGVTd2FwMzI7XG4vLyBCdWlsdC1pbiBoZXggY29udmVyc2lvbiBodHRwczovL2Nhbml1c2UuY29tL21kbi1qYXZhc2NyaXB0X2J1aWx0aW5zX3VpbnQ4YXJyYXlfZnJvbWhleFxuY29uc3QgaGFzSGV4QnVpbHRpbiA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gXG4vLyBAdHMtaWdub3JlXG50eXBlb2YgVWludDhBcnJheS5mcm9tKFtdKS50b0hleCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgVWludDhBcnJheS5mcm9tSGV4ID09PSAnZnVuY3Rpb24nKSgpO1xuLy8gQXJyYXkgd2hlcmUgaW5kZXggMHhmMCAoMjQwKSBpcyBtYXBwZWQgdG8gc3RyaW5nICdmMCdcbmNvbnN0IGhleGVzID0gLyogQF9fUFVSRV9fICovIEFycmF5LmZyb20oeyBsZW5ndGg6IDI1NiB9LCAoXywgaSkgPT4gaS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSk7XG4vKipcbiAqIENvbnZlcnQgYnl0ZSBhcnJheSB0byBoZXggc3RyaW5nLiBVc2VzIGJ1aWx0LWluIGZ1bmN0aW9uLCB3aGVuIGF2YWlsYWJsZS5cbiAqIEBleGFtcGxlIGJ5dGVzVG9IZXgoVWludDhBcnJheS5mcm9tKFsweGNhLCAweGZlLCAweDAxLCAweDIzXSkpIC8vICdjYWZlMDEyMydcbiAqL1xuZnVuY3Rpb24gYnl0ZXNUb0hleChieXRlcykge1xuICAgIGFieXRlcyhieXRlcyk7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGlmIChoYXNIZXhCdWlsdGluKVxuICAgICAgICByZXR1cm4gYnl0ZXMudG9IZXgoKTtcbiAgICAvLyBwcmUtY2FjaGluZyBpbXByb3ZlcyB0aGUgc3BlZWQgNnhcbiAgICBsZXQgaGV4ID0gJyc7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBoZXggKz0gaGV4ZXNbYnl0ZXNbaV1dO1xuICAgIH1cbiAgICByZXR1cm4gaGV4O1xufVxuLy8gV2UgdXNlIG9wdGltaXplZCB0ZWNobmlxdWUgdG8gY29udmVydCBoZXggc3RyaW5nIHRvIGJ5dGUgYXJyYXlcbmNvbnN0IGFzY2lpcyA9IHsgXzA6IDQ4LCBfOTogNTcsIEE6IDY1LCBGOiA3MCwgYTogOTcsIGY6IDEwMiB9O1xuZnVuY3Rpb24gYXNjaWlUb0Jhc2UxNihjaCkge1xuICAgIGlmIChjaCA+PSBhc2NpaXMuXzAgJiYgY2ggPD0gYXNjaWlzLl85KVxuICAgICAgICByZXR1cm4gY2ggLSBhc2NpaXMuXzA7IC8vICcyJyA9PiA1MC00OFxuICAgIGlmIChjaCA+PSBhc2NpaXMuQSAmJiBjaCA8PSBhc2NpaXMuRilcbiAgICAgICAgcmV0dXJuIGNoIC0gKGFzY2lpcy5BIC0gMTApOyAvLyAnQicgPT4gNjYtKDY1LTEwKVxuICAgIGlmIChjaCA+PSBhc2NpaXMuYSAmJiBjaCA8PSBhc2NpaXMuZilcbiAgICAgICAgcmV0dXJuIGNoIC0gKGFzY2lpcy5hIC0gMTApOyAvLyAnYicgPT4gOTgtKDk3LTEwKVxuICAgIHJldHVybjtcbn1cbi8qKlxuICogQ29udmVydCBoZXggc3RyaW5nIHRvIGJ5dGUgYXJyYXkuIFVzZXMgYnVpbHQtaW4gZnVuY3Rpb24sIHdoZW4gYXZhaWxhYmxlLlxuICogQGV4YW1wbGUgaGV4VG9CeXRlcygnY2FmZTAxMjMnKSAvLyBVaW50OEFycmF5LmZyb20oWzB4Y2EsIDB4ZmUsIDB4MDEsIDB4MjNdKVxuICovXG5mdW5jdGlvbiBoZXhUb0J5dGVzKGhleCkge1xuICAgIGlmICh0eXBlb2YgaGV4ICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3QgJyArIHR5cGVvZiBoZXgpO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBpZiAoaGFzSGV4QnVpbHRpbilcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbUhleChoZXgpO1xuICAgIGNvbnN0IGhsID0gaGV4Lmxlbmd0aDtcbiAgICBjb25zdCBhbCA9IGhsIC8gMjtcbiAgICBpZiAoaGwgJSAyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCB1bnBhZGRlZCBoZXggb2YgbGVuZ3RoICcgKyBobCk7XG4gICAgY29uc3QgYXJyYXkgPSBuZXcgVWludDhBcnJheShhbCk7XG4gICAgZm9yIChsZXQgYWkgPSAwLCBoaSA9IDA7IGFpIDwgYWw7IGFpKyssIGhpICs9IDIpIHtcbiAgICAgICAgY29uc3QgbjEgPSBhc2NpaVRvQmFzZTE2KGhleC5jaGFyQ29kZUF0KGhpKSk7XG4gICAgICAgIGNvbnN0IG4yID0gYXNjaWlUb0Jhc2UxNihoZXguY2hhckNvZGVBdChoaSArIDEpKTtcbiAgICAgICAgaWYgKG4xID09PSB1bmRlZmluZWQgfHwgbjIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgY2hhciA9IGhleFtoaV0gKyBoZXhbaGkgKyAxXTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290IG5vbi1oZXggY2hhcmFjdGVyIFwiJyArIGNoYXIgKyAnXCIgYXQgaW5kZXggJyArIGhpKTtcbiAgICAgICAgfVxuICAgICAgICBhcnJheVthaV0gPSBuMSAqIDE2ICsgbjI7IC8vIG11bHRpcGx5IGZpcnN0IG9jdGV0LCBlLmcuICdhMycgPT4gMTAqMTYrMyA9PiAxNjAgKyAzID0+IDE2M1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG59XG4vKipcbiAqIFRoZXJlIGlzIG5vIHNldEltbWVkaWF0ZSBpbiBicm93c2VyIGFuZCBzZXRUaW1lb3V0IGlzIHNsb3cuXG4gKiBDYWxsIG9mIGFzeW5jIGZuIHdpbGwgcmV0dXJuIFByb21pc2UsIHdoaWNoIHdpbGwgYmUgZnVsbGZpbGVkIG9ubHkgb25cbiAqIG5leHQgc2NoZWR1bGVyIHF1ZXVlIHByb2Nlc3Npbmcgc3RlcCBhbmQgdGhpcyBpcyBleGFjdGx5IHdoYXQgd2UgbmVlZC5cbiAqL1xuY29uc3QgbmV4dFRpY2sgPSBhc3luYyAoKSA9PiB7IH07XG5leHBvcnRzLm5leHRUaWNrID0gbmV4dFRpY2s7XG4vKiogUmV0dXJucyBjb250cm9sIHRvIHRocmVhZCBlYWNoICd0aWNrJyBtcyB0byBhdm9pZCBibG9ja2luZy4gKi9cbmFzeW5jIGZ1bmN0aW9uIGFzeW5jTG9vcChpdGVycywgdGljaywgY2IpIHtcbiAgICBsZXQgdHMgPSBEYXRlLm5vdygpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlcnM7IGkrKykge1xuICAgICAgICBjYihpKTtcbiAgICAgICAgLy8gRGF0ZS5ub3coKSBpcyBub3QgbW9ub3RvbmljLCBzbyBpbiBjYXNlIGlmIGNsb2NrIGdvZXMgYmFja3dhcmRzIHdlIHJldHVybiByZXR1cm4gY29udHJvbCB0b29cbiAgICAgICAgY29uc3QgZGlmZiA9IERhdGUubm93KCkgLSB0cztcbiAgICAgICAgaWYgKGRpZmYgPj0gMCAmJiBkaWZmIDwgdGljaylcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBhd2FpdCAoMCwgZXhwb3J0cy5uZXh0VGljaykoKTtcbiAgICAgICAgdHMgKz0gZGlmZjtcbiAgICB9XG59XG4vKipcbiAqIENvbnZlcnRzIHN0cmluZyB0byBieXRlcyB1c2luZyBVVEY4IGVuY29kaW5nLlxuICogQGV4YW1wbGUgdXRmOFRvQnl0ZXMoJ2FiYycpIC8vIFVpbnQ4QXJyYXkuZnJvbShbOTcsIDk4LCA5OV0pXG4gKi9cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzKHN0cikge1xuICAgIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzdHJpbmcgZXhwZWN0ZWQnKTtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkobmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHN0cikpOyAvLyBodHRwczovL2J1Z3ppbC5sYS8xNjgxODA5XG59XG4vKipcbiAqIENvbnZlcnRzIGJ5dGVzIHRvIHN0cmluZyB1c2luZyBVVEY4IGVuY29kaW5nLlxuICogQGV4YW1wbGUgYnl0ZXNUb1V0ZjgoVWludDhBcnJheS5mcm9tKFs5NywgOTgsIDk5XSkpIC8vICdhYmMnXG4gKi9cbmZ1bmN0aW9uIGJ5dGVzVG9VdGY4KGJ5dGVzKSB7XG4gICAgcmV0dXJuIG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZShieXRlcyk7XG59XG4vKipcbiAqIE5vcm1hbGl6ZXMgKG5vbi1oZXgpIHN0cmluZyBvciBVaW50OEFycmF5IHRvIFVpbnQ4QXJyYXkuXG4gKiBXYXJuaW5nOiB3aGVuIFVpbnQ4QXJyYXkgaXMgcGFzc2VkLCBpdCB3b3VsZCBOT1QgZ2V0IGNvcGllZC5cbiAqIEtlZXAgaW4gbWluZCBmb3IgZnV0dXJlIG11dGFibGUgb3BlcmF0aW9ucy5cbiAqL1xuZnVuY3Rpb24gdG9CeXRlcyhkYXRhKSB7XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJylcbiAgICAgICAgZGF0YSA9IHV0ZjhUb0J5dGVzKGRhdGEpO1xuICAgIGFieXRlcyhkYXRhKTtcbiAgICByZXR1cm4gZGF0YTtcbn1cbi8qKlxuICogSGVscGVyIGZvciBLREZzOiBjb25zdW1lcyB1aW50OGFycmF5IG9yIHN0cmluZy5cbiAqIFdoZW4gc3RyaW5nIGlzIHBhc3NlZCwgZG9lcyB1dGY4IGRlY29kaW5nLCB1c2luZyBUZXh0RGVjb2Rlci5cbiAqL1xuZnVuY3Rpb24ga2RmSW5wdXRUb0J5dGVzKGRhdGEpIHtcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKVxuICAgICAgICBkYXRhID0gdXRmOFRvQnl0ZXMoZGF0YSk7XG4gICAgYWJ5dGVzKGRhdGEpO1xuICAgIHJldHVybiBkYXRhO1xufVxuLyoqIENvcGllcyBzZXZlcmFsIFVpbnQ4QXJyYXlzIGludG8gb25lLiAqL1xuZnVuY3Rpb24gY29uY2F0Qnl0ZXMoLi4uYXJyYXlzKSB7XG4gICAgbGV0IHN1bSA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYSA9IGFycmF5c1tpXTtcbiAgICAgICAgYWJ5dGVzKGEpO1xuICAgICAgICBzdW0gKz0gYS5sZW5ndGg7XG4gICAgfVxuICAgIGNvbnN0IHJlcyA9IG5ldyBVaW50OEFycmF5KHN1bSk7XG4gICAgZm9yIChsZXQgaSA9IDAsIHBhZCA9IDA7IGkgPCBhcnJheXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYSA9IGFycmF5c1tpXTtcbiAgICAgICAgcmVzLnNldChhLCBwYWQpO1xuICAgICAgICBwYWQgKz0gYS5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiBjaGVja09wdHMoZGVmYXVsdHMsIG9wdHMpIHtcbiAgICBpZiAob3B0cyAhPT0gdW5kZWZpbmVkICYmIHt9LnRvU3RyaW5nLmNhbGwob3B0cykgIT09ICdbb2JqZWN0IE9iamVjdF0nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ29wdGlvbnMgc2hvdWxkIGJlIG9iamVjdCBvciB1bmRlZmluZWQnKTtcbiAgICBjb25zdCBtZXJnZWQgPSBPYmplY3QuYXNzaWduKGRlZmF1bHRzLCBvcHRzKTtcbiAgICByZXR1cm4gbWVyZ2VkO1xufVxuLyoqIEZvciBydW50aW1lIGNoZWNrIGlmIGNsYXNzIGltcGxlbWVudHMgaW50ZXJmYWNlICovXG5jbGFzcyBIYXNoIHtcbn1cbmV4cG9ydHMuSGFzaCA9IEhhc2g7XG4vKiogV3JhcHMgaGFzaCBmdW5jdGlvbiwgY3JlYXRpbmcgYW4gaW50ZXJmYWNlIG9uIHRvcCBvZiBpdCAqL1xuZnVuY3Rpb24gY3JlYXRlSGFzaGVyKGhhc2hDb25zKSB7XG4gICAgY29uc3QgaGFzaEMgPSAobXNnKSA9PiBoYXNoQ29ucygpLnVwZGF0ZSh0b0J5dGVzKG1zZykpLmRpZ2VzdCgpO1xuICAgIGNvbnN0IHRtcCA9IGhhc2hDb25zKCk7XG4gICAgaGFzaEMub3V0cHV0TGVuID0gdG1wLm91dHB1dExlbjtcbiAgICBoYXNoQy5ibG9ja0xlbiA9IHRtcC5ibG9ja0xlbjtcbiAgICBoYXNoQy5jcmVhdGUgPSAoKSA9PiBoYXNoQ29ucygpO1xuICAgIHJldHVybiBoYXNoQztcbn1cbmZ1bmN0aW9uIGNyZWF0ZU9wdEhhc2hlcihoYXNoQ29ucykge1xuICAgIGNvbnN0IGhhc2hDID0gKG1zZywgb3B0cykgPT4gaGFzaENvbnMob3B0cykudXBkYXRlKHRvQnl0ZXMobXNnKSkuZGlnZXN0KCk7XG4gICAgY29uc3QgdG1wID0gaGFzaENvbnMoe30pO1xuICAgIGhhc2hDLm91dHB1dExlbiA9IHRtcC5vdXRwdXRMZW47XG4gICAgaGFzaEMuYmxvY2tMZW4gPSB0bXAuYmxvY2tMZW47XG4gICAgaGFzaEMuY3JlYXRlID0gKG9wdHMpID0+IGhhc2hDb25zKG9wdHMpO1xuICAgIHJldHVybiBoYXNoQztcbn1cbmZ1bmN0aW9uIGNyZWF0ZVhPRmVyKGhhc2hDb25zKSB7XG4gICAgY29uc3QgaGFzaEMgPSAobXNnLCBvcHRzKSA9PiBoYXNoQ29ucyhvcHRzKS51cGRhdGUodG9CeXRlcyhtc2cpKS5kaWdlc3QoKTtcbiAgICBjb25zdCB0bXAgPSBoYXNoQ29ucyh7fSk7XG4gICAgaGFzaEMub3V0cHV0TGVuID0gdG1wLm91dHB1dExlbjtcbiAgICBoYXNoQy5ibG9ja0xlbiA9IHRtcC5ibG9ja0xlbjtcbiAgICBoYXNoQy5jcmVhdGUgPSAob3B0cykgPT4gaGFzaENvbnMob3B0cyk7XG4gICAgcmV0dXJuIGhhc2hDO1xufVxuZXhwb3J0cy53cmFwQ29uc3RydWN0b3IgPSBjcmVhdGVIYXNoZXI7XG5leHBvcnRzLndyYXBDb25zdHJ1Y3RvcldpdGhPcHRzID0gY3JlYXRlT3B0SGFzaGVyO1xuZXhwb3J0cy53cmFwWE9GQ29uc3RydWN0b3JXaXRoT3B0cyA9IGNyZWF0ZVhPRmVyO1xuLyoqIENyeXB0b2dyYXBoaWNhbGx5IHNlY3VyZSBQUk5HLiBVc2VzIGludGVybmFsIE9TLWxldmVsIGBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzYC4gKi9cbmZ1bmN0aW9uIHJhbmRvbUJ5dGVzKGJ5dGVzTGVuZ3RoID0gMzIpIHtcbiAgICBpZiAoY3J5cHRvXzEuY3J5cHRvICYmIHR5cGVvZiBjcnlwdG9fMS5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBjcnlwdG9fMS5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50OEFycmF5KGJ5dGVzTGVuZ3RoKSk7XG4gICAgfVxuICAgIC8vIExlZ2FjeSBOb2RlLmpzIGNvbXBhdGliaWxpdHlcbiAgICBpZiAoY3J5cHRvXzEuY3J5cHRvICYmIHR5cGVvZiBjcnlwdG9fMS5jcnlwdG8ucmFuZG9tQnl0ZXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShjcnlwdG9fMS5jcnlwdG8ucmFuZG9tQnl0ZXMoYnl0ZXNMZW5ndGgpKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzIG11c3QgYmUgZGVmaW5lZCcpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwid3JhcFhPRkNvbnN0cnVjdG9yV2l0aE9wdHMiLCJ3cmFwQ29uc3RydWN0b3JXaXRoT3B0cyIsIndyYXBDb25zdHJ1Y3RvciIsIkhhc2giLCJuZXh0VGljayIsInN3YXAzMklmQkUiLCJieXRlU3dhcElmQkUiLCJzd2FwOElmQkUiLCJpc0xFIiwiaXNCeXRlcyIsImFudW1iZXIiLCJhYnl0ZXMiLCJhaGFzaCIsImFleGlzdHMiLCJhb3V0cHV0IiwidTgiLCJ1MzIiLCJjbGVhbiIsImNyZWF0ZVZpZXciLCJyb3RyIiwicm90bCIsImJ5dGVTd2FwIiwiYnl0ZVN3YXAzMiIsImJ5dGVzVG9IZXgiLCJoZXhUb0J5dGVzIiwiYXN5bmNMb29wIiwidXRmOFRvQnl0ZXMiLCJieXRlc1RvVXRmOCIsInRvQnl0ZXMiLCJrZGZJbnB1dFRvQnl0ZXMiLCJjb25jYXRCeXRlcyIsImNoZWNrT3B0cyIsImNyZWF0ZUhhc2hlciIsImNyZWF0ZU9wdEhhc2hlciIsImNyZWF0ZVhPRmVyIiwicmFuZG9tQnl0ZXMiLCJjcnlwdG9fMSIsInJlcXVpcmUiLCJhIiwiVWludDhBcnJheSIsIkFycmF5QnVmZmVyIiwiaXNWaWV3IiwiY29uc3RydWN0b3IiLCJuYW1lIiwibiIsIk51bWJlciIsImlzU2FmZUludGVnZXIiLCJFcnJvciIsImIiLCJsZW5ndGhzIiwibGVuZ3RoIiwiaW5jbHVkZXMiLCJoIiwiY3JlYXRlIiwib3V0cHV0TGVuIiwiYmxvY2tMZW4iLCJpbnN0YW5jZSIsImNoZWNrRmluaXNoZWQiLCJkZXN0cm95ZWQiLCJmaW5pc2hlZCIsIm91dCIsIm1pbiIsImFyciIsImJ1ZmZlciIsImJ5dGVPZmZzZXQiLCJieXRlTGVuZ3RoIiwiVWludDMyQXJyYXkiLCJNYXRoIiwiZmxvb3IiLCJhcnJheXMiLCJpIiwiZmlsbCIsIkRhdGFWaWV3Iiwid29yZCIsInNoaWZ0IiwidSIsImhhc0hleEJ1aWx0aW4iLCJmcm9tIiwidG9IZXgiLCJmcm9tSGV4IiwiaGV4ZXMiLCJBcnJheSIsIl8iLCJ0b1N0cmluZyIsInBhZFN0YXJ0IiwiYnl0ZXMiLCJoZXgiLCJhc2NpaXMiLCJfMCIsIl85IiwiQSIsIkYiLCJmIiwiYXNjaWlUb0Jhc2UxNiIsImNoIiwiaGwiLCJhbCIsImFycmF5IiwiYWkiLCJoaSIsIm4xIiwiY2hhckNvZGVBdCIsIm4yIiwidW5kZWZpbmVkIiwiY2hhciIsIml0ZXJzIiwidGljayIsImNiIiwidHMiLCJEYXRlIiwibm93IiwiZGlmZiIsInN0ciIsIlRleHRFbmNvZGVyIiwiZW5jb2RlIiwiVGV4dERlY29kZXIiLCJkZWNvZGUiLCJkYXRhIiwic3VtIiwicmVzIiwicGFkIiwic2V0IiwiZGVmYXVsdHMiLCJvcHRzIiwiY2FsbCIsIm1lcmdlZCIsImFzc2lnbiIsImhhc2hDb25zIiwiaGFzaEMiLCJtc2ciLCJ1cGRhdGUiLCJkaWdlc3QiLCJ0bXAiLCJieXRlc0xlbmd0aCIsImNyeXB0byIsImdldFJhbmRvbVZhbHVlcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@noble/hashes/utils.js\n");

/***/ })

};
;